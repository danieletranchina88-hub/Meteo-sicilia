import requests
import xarray as xr
import numpy as np
import json
import os
import sys
import shutil
from datetime import datetime, timedelta

# --- CONFIGURAZIONE ---
DATASET_ID = "ICON_2I_SURFACE_PRESSURE_LEVELS"
API_LIST_URL = f"https://meteohub.agenziaitaliameteo.it/api/datasets/{DATASET_ID}/opendata"
API_DOWNLOAD_URL = "https://meteohub.agenziaitaliameteo.it/api/opendata"
OUTPUT_DIR = "data_weather"

# Limiti Geografici Sicilia
LAT_MIN, LAT_MAX = 35.0, 39.5
LON_MIN, LON_MAX = 11.0, 16.5

# LIMITATORE DI VELOCITÀ (Per sbloccare la situazione)
# True = Scarica solo 24 ore. False = Scarica tutto (più lento).
FAST_MODE = True 

def get_latest_run_files():
    print("1. Contatto MeteoHub...", flush=True)
    try:
        # Timeout breve (10s) per non restare bloccati
        r = requests.get(API_LIST_URL, timeout=10)
        r.raise_for_status()
        items = r.json()
        print(f"   Catalogo ricevuto: {len(items)} elementi.", flush=True)
    except Exception as e:
        print(f"   ERRORE CONNESSIONE: {e}", flush=True)
        return None, []

    runs = {}
    for item in items:
        if isinstance(item, dict) and 'date' in item and 'run' in item:
            key = f"{item['date']} {item['run']}"
            if key not in runs: runs[key] = []
            runs[key].append(item['filename'])
    
    if not runs: return None, []
    latest_key = sorted(runs.keys())[-1]
    run_dt = datetime.strptime(latest_key, "%Y-%m-%d %H:%M")
    
    file_list = runs[latest_key]
    # Se siamo in FAST_MODE, prendiamo solo i primi 24 file
    if FAST_MODE:
        file_list = file_list[:24]
        print("   >>> FAST MODE ATTIVA: Scarico solo le prime 24 ore.", flush=True)

    return run_dt, file_list

def process_data():
    run_dt, file_list = get_latest_run_files()
    
    if not file_list:
        print("!!! NESSUN DATO TROVATO. STOP.", flush=True)
        sys.exit(0) # Non rompiamo il sito, usciamo puliti.

    print(f"2. Inizio elaborazione di {len(file_list)} file...", flush=True)
    
    # Cancelliamo la cartella solo ora che siamo sicuri di avere qualcosa da fare
    if os.path.exists(OUTPUT_DIR): shutil.rmtree(OUTPUT_DIR)
    os.makedirs(OUTPUT_DIR)

    catalog = []
    processed_hours = set()

    for idx, filename in enumerate(file_list):
        print(f"   [{idx+1}/{len(file_list)}] Download: {filename} ...", end=" ", flush=True)
        local_path = "temp.grib2"
        try:
            # Timeout aggressivo: 30 secondi per file, altrimenti salta
            with requests.get(f"{API_DOWNLOAD_URL}/{filename}", stream=True, timeout=30) as r:
                r.raise_for_status()
                with open(local_path, 'wb') as f:
                    for chunk in r.iter_content(chunk_size=1024*1024): f.write(chunk)
            print("OK ->", end=" ", flush=True)
        except Exception as e:
            print(f"FALLITO ({str(e)[:20]}...)", flush=True)
            continue

        try:
            # Apriamo il GRIB
            ds_wind = xr.open_dataset(local_path, engine='cfgrib', 
                                      backend_kwargs={'filter_by_keys': {'typeOfLevel': 'heightAboveGround', 'level': 10}})
            
            # Tentativo opzionale per Temp e Pioggia (se fallisce pazienza)
            ds_temp = None
            ds_rain = None
            try: 
                ds_temp = xr.open_dataset(local_path, engine='cfgrib', 
                                          backend_kwargs={'filter_by_keys': {'typeOfLevel': 'heightAboveGround', 'level': 2}})
            except: pass
            
            try: 
                ds_rain = xr.open_dataset(local_path, engine='cfgrib', 
                                          backend_kwargs={'filter_by_keys': {'typeOfLevel': 'surface'}})
            except: pass
            
        except Exception as e:
            print(f"ERR GRIB ({e})", flush=True)
            continue

        # Estrazione Dati
        steps = range(ds_wind.sizes.get('step', 1))
        for i in steps:
            try:
                raw_step = ds_wind.step.values[i]
                if isinstance(raw_step, np.timedelta64): step_hours = int(raw_step / np.timedelta64(1, 'h'))
                else: step_hours = int(raw_step)

                if step_hours in processed_hours: continue

                # Elaborazione Vettoriale
                d_w = ds_wind.isel(step=i) if 'step' in ds_wind.dims else ds_wind
                d_w = d_w.sortby('latitude', ascending=False).sortby('longitude', ascending=True)

                mask = ((d_w.latitude >= LAT_MIN) & (d_w.latitude <= LAT_MAX) & 
                        (d_w.longitude >= LON_MIN) & (d_w.longitude <= LON_MAX))
                cut_w = d_w.where(mask, drop=True)

                u_key = next((k for k in ['u10','u','10u'] if k in cut_w), None)
                v_key = next((k for k in ['v10','v','10v'] if k in cut_w), None)
                
                if u_key and v_key:
                    u = np.nan_to_num(cut_w[u_key].values)
                    v = np.nan_to_num(cut_w[v_key].values)
                    
                    # Geometria
                    lat = cut_w.latitude.values
                    lon = cut_w.longitude.values
                    ny, nx = u.shape
                    la1, lo1 = float(lat[0]), float(lon[0])
                    dx = float(abs(lon[1] - lon[0]))
                    dy = float(abs(lat[0] - lat[1]))

                    # Temp & Rain
                    temp, rain = np.zeros_like(u), np.zeros_like(u)
                    
                    if ds_temp:
                        d_t = ds_temp.isel(step=i) if 'step' in ds_temp.dims else ds_temp
                        d_t = d_t.sortby('latitude', ascending=False).sortby('longitude', ascending=True)
                        cut_t = d_t.where(mask, drop=True)
                        t_key = next((k for k in ['t2m','2t','t'] if k in cut_t), None)
                        if t_key: temp = cut_t[t_key].values - 273.15
                    
                    if ds_rain:
                        d_r = ds_rain.isel(step=i) if 'step' in ds_rain.dims else ds_rain
                        d_r = d_r.sortby('latitude', ascending=False).sortby('longitude', ascending=True)
                        cut_r = d_r.where(mask, drop=True)
                        r_key = next((k for k in ['tp','tot_prec'] if k in cut_r), None)
                        if r_key: rain = np.nan_to_num(cut_r[r_key].values)

                    valid_dt = run_dt + timedelta(hours=step_hours)
                    iso_date = valid_dt.strftime("%Y-%m-%dT%H:%M:%S.000Z")

                    header = {
                        "parameterCategory": 2, "parameterNumber": 2,
                        "nx": nx, "ny": ny, "lo1": lo1, "la1": la1, "dx": dx, "dy": dy,
                        "refTime": iso_date
                    }

                    step_data = {
                        "meta": header,
                        "wind_u": { "header": header, "data": np.round(u, 1).flatten().tolist() },
                        "wind_v": { "header": header, "data": np.round(v, 1).flatten().tolist() },
                        "temp": np.round(temp, 1).flatten().tolist(),
                        "rain": np.round(rain, 2).flatten().tolist()
                    }

                    out_name = f"step_{step_hours}.json"
                    with open(f"{OUTPUT_DIR}/{out_name}", 'w') as jf: json.dump(step_data, jf)
                    
                    day_str = valid_dt.strftime("%d/%m")
                    hour_str = valid_dt.strftime("%H:00")
                    catalog.append({"file": out_name, "label": f"{day_str} {hour_str}", "hour": step_hours})
                    processed_hours.add(step_hours)
                    print(f"JSON creato (+{step_hours}h)", flush=True)
                else:
                    print("No wind keys", flush=True)

            except Exception as e: 
                print(f"Err step {i}: {e}", flush=True)
                continue

    # Salvataggio Catalogo
    if catalog:
        catalog.sort(key=lambda x: x['hour'])
        with open(f"{OUTPUT_DIR}/catalog.json", 'w') as f: json.dump(catalog, f)
        print(f"\nCOMPLETATO. Salvati {len(catalog)} step nel catalogo.", flush=True)
    else:
        print("\nNESSUN DATO ESTRATTO.", flush=True)

if __name__ == "__main__":
    process_data()
    
