<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - PRO (DARK RELIEF)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin: 0; background: #111; font-family: 'Segoe UI', sans-serif; color: white; overflow: hidden; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #111; }

    /* UI CONTROL */
    #ui-container { position: absolute; top: 10px; right: 10px; z-index: 1000; display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
    .panel { background: rgba(0,0,0,0.85); backdrop-filter: blur(6px); padding: 8px; border-radius: 14px; border: 1px solid #444; }
    .layer-btn {
      display: block; width: 170px; padding: 10px 12px; margin-bottom: 6px;
      background: transparent; color: #ccc; border: none; text-align: right;
      cursor: pointer; font-size: 13px; font-weight: 700; border-radius: 8px;
      transition: all 0.15s;
    }
    .layer-btn:hover { background: rgba(255,255,255,0.08); color: #fff; }
    .layer-btn.active { background: #007bff; color: white; }

    .map-toggle {
      padding: 8px 12px; background: rgba(255,255,255,0.06); color: #fff;
      border: 1px solid rgba(255,255,255,0.2); border-radius: 10px;
      cursor: pointer; font-size: 12px; font-weight: 800;
      transition: all 0.15s;
    }
    .map-toggle:hover { background: rgba(255,255,255,0.12); }
    .map-toggle.active { background: #eee; color: #000; }

    /* INFO */
    #info-box { position: absolute; top: 20px; left: 20px; z-index: 1000; pointer-events: none; text-shadow: 2px 2px 0 #000; }
    #val-display { font-size: 3.5em; font-weight: 900; line-height: 1; }
    #unit-display { font-size: 1.2em; color: #aaa; font-weight: 800; }

    #bottom-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: 90px;
      background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
      display: flex; align-items: center; padding: 0 20px; z-index: 2000;
    }
    #play-btn { font-size: 2.5em; background: none; border: none; color: white; cursor: pointer; margin-right: 15px; }
    #time-label { font-size: 1.4em; font-weight: 900; margin-left: 15px; min-width: 140px; text-align: center; text-shadow: 0 2px 10px #000; }
    input[type=range] { flex-grow: 1; height: 5px; cursor: pointer; accent-color: #0088ff; }

    /* Dark relief overlay: pi√π evidente */
    .hillshade-tiles {
      mix-blend-mode: multiply;
      filter: contrast(2.0) brightness(0.95);
    }

    /* Canvas: smooth */
    canvas { image-rendering: auto; }

    /* Prevent map click selecting text */
    * { -webkit-tap-highlight-color: transparent; }
  </style>
</head>

<body>
  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">Caricamento...</div>
  </div>

  <div id="ui-container">
    <div class="panel" style="display:flex; gap:6px;">
      <button class="map-toggle active" onclick="setBase('dark')">DARK</button>
      <button class="map-toggle" onclick="setBase('sat')">SATELLITE</button>
    </div>

    <div class="panel">
      <button class="layer-btn active" onclick="setLayer('temp')">TEMP üå°Ô∏è</button>
      <button class="layer-btn" onclick="setLayer('rain')">PIOGGIA ‚òî</button>
      <button class="layer-btn" onclick="setLayer('rh')">UMIDIT√Ä üíß</button>
      <button class="layer-btn" onclick="setLayer('press')">PRESSIONE ‚è≤Ô∏è</button>
      <button class="layer-btn" onclick="setLayer('cloud')">NUVOLE ‚òÅÔ∏è</button>

      <hr style="border:0; border-top:1px solid #444; margin:6px 0;">

      <!-- Vento: modalit√† sinottica (frecce+sfondo) e toggle particelle -->
      <button class="layer-btn" onclick="setLayer('wind_syn')">VENTO (SINOTTICO) üß≠</button>
      <button class="layer-btn" id="btn-particles" onclick="toggleParticles()">PARTICELLE üí®</button>

      <hr style="border:0; border-top:1px solid #444; margin:6px 0;">
      <button class="layer-btn" id="btn-iso" onclick="toggleIso()">ISOBARE „Ä∞Ô∏è</button>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  // --- GLOBALS ---
  var map, velocityLayer;
  var heatCanvas, isoCanvas, windCanvas;

  var currentData = null, catalog = [];
  var activeLayer = 'temp';
  var showIso = false, isPlaying = false;

  var baseLayers = {};
  var labelLayer = null;
  var hillshadeLayer = null;

  var showParticles = false; // toggle particelle vento
  var isDark = true;

  // --- WIND ORIGINAL SETTINGS (as requested) ---
  const WIND_MAX_VELOCITY = 18.0;
  const WIND_VELOCITY_SCALE = 0.006;
  const WIND_LINE_WIDTH = 0.8;
  const WIND_PARTICLE_AGE = 140;
  const WIND_FRAME_RATE = 60;
  const WIND_OPACITY = 0.95;

  // === ORIGINAL PARTICLE COLOR SCALE (KEEP EXACT) ===
  const WIND_COLORS = ["#000080", "#0044ff", "#00ddff", "#00ff55", "#ffff00", "#ff6600", "#ff0000", "#ff00ff"];

  // --- PALETTES (heatmaps) ---
  // Temp: -15..45 with anchors you specified
  const PALETTES = {
    temp: [
      {v:-15,c:[ 80,  0,120,0.62]}, // viola scuro
      {v:  0,c:[  0,255,255,0.62]}, // ciano
      {v: 15,c:[255,255,180,0.62]}, // giallo chiaro
      {v: 20,c:[255,235,  0,0.62]}, // giallo
      {v: 25,c:[255,190, 80,0.62]}, // arancione chiaro
      {v: 30,c:[255,140,  0,0.62]}, // arancione
      {v: 35,c:[255, 50, 50,0.62]}, // rosso
      {v: 45,c:[120,  0,  0,0.62]}  // rosso scuro
    ],
    rain: [
      {v:0,   c:[0,0,0,0]},
      {v:0.1, c:[0,200,255,0.68]},
      {v:2,   c:[0,0,255,0.78]},
      {v:10,  c:[150,0,200,0.85]}
    ],
    rh: [
      {v:20,c:[200,150, 50,0.62]},
      {v:40,c:[200,200,200,0.62]},
      {v:60,c:[100,255,100,0.62]},
      {v:80,c:[ 50,150,255,0.70]},
      {v:95,c:[  0,  0,200,0.75]}
    ],
    // Keep your press palette as-is (do NOT change unless you ask)
    press: [
      {v:980, c:[0,70,255,0.60]},
      {v:995, c:[0,170,255,0.60]},
      {v:1005,c:[0,255,200,0.60]},
      {v:1013,c:[255,255,255,0.60]},
      {v:1022,c:[255,200,0,0.60]},
      {v:1035,c:[255,60,0,0.65]}
    ],
    // Cloud cover 0..100 => white -> dark gray (as requested)
    cloud: [
      {v:0,   c:[255,255,255,0.00]},
      {v:10,  c:[245,245,245,0.18]},
      {v:30,  c:[220,220,220,0.30]},
      {v:60,  c:[170,170,170,0.45]},
      {v:85,  c:[110,110,110,0.62]},
      {v:100, c:[ 50, 50, 50,0.72]}
    ]
  };

  function lerp(a,b,t){ return a+(b-a)*t; }

  function getColor(val, type) {
    const p = PALETTES[type];
    if(!p) return [0,0,0,0];
    if(type==='rain' && val < 0.1) return [0,0,0,0];

    // clamp
    if(val <= p[0].v) return p[0].c.slice();
    if(val >= p[p.length-1].v) return p[p.length-1].c.slice();

    for(let i=0; i<p.length-1; i++) {
      if(val >= p[i].v && val <= p[i+1].v) {
        const t = (val - p[i].v) / (p[i+1].v - p[i].v);
        const c1 = p[i].c, c2 = p[i+1].c;
        return [
          Math.round(lerp(c1[0], c2[0], t)),
          Math.round(lerp(c1[1], c2[1], t)),
          Math.round(lerp(c1[2], c2[2], t)),
          lerp(c1[3], c2[3], t)
        ];
      }
    }
    return p[p.length-1].c.slice();
  }

  // --- Wind color interpolation (same palette as particles) ---
  function hexToRgb(hex){
    const h = hex.replace('#','');
    const bigint = parseInt(h, 16);
    return { r:(bigint>>16)&255, g:(bigint>>8)&255, b:bigint&255 };
  }
  function windColorFromSpeed(speedMS, alpha=0.95){
    const t = Math.max(0, Math.min(1, speedMS / WIND_MAX_VELOCITY));
    const n = WIND_COLORS.length;
    const i = Math.min(n-2, Math.floor(t*(n-1)));
    const f = (t*(n-1)) - i;
    const c1 = hexToRgb(WIND_COLORS[i]);
    const c2 = hexToRgb(WIND_COLORS[i+1]);
    const r = Math.round(lerp(c1.r, c2.r, f));
    const g = Math.round(lerp(c1.g, c2.g, f));
    const b = Math.round(lerp(c1.b, c2.b, f));
    return `rgba(${r},${g},${b},${alpha})`;
  }

  // --- INIT ---
  window.addEventListener('load', async function() {
    map = L.map('map', { zoomControl: false }).setView([37.5, 14.2], 8);

    // DARK base
    baseLayers.dark = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, attribution: '¬©OpenStreetMap, ¬©Carto' }
    ).addTo(map);

    // Hillshade overlay
    hillshadeLayer = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}',
      {
        maxZoom: 19,
        opacity: 0.75,
        className: 'hillshade-tiles',
        attribution: 'Hillshade ¬© Esri'
      }
    ).addTo(map);

    // Satellite
    baseLayers.sat = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution: 'Tiles ¬© Esri' }
    );

    // Labels ALWAYS ON TOP (good also on sat)
    labelLayer = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, opacity: 0.95, attribution: '¬©Carto' }
    ).addTo(map);

    createCanvasLayers();
    await loadCatalogAndFirstFrame();

    map.on('mousemove', updatePickerFromEvent);
    map.on('click', updatePickerFromEvent);

    document.getElementById('unit-display').innerText = unitFor(activeLayer);
  });

  function setBase(type) {
    document.querySelectorAll('.map-toggle').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');

    if(type==='dark') {
      isDark = true;
      map.removeLayer(baseLayers.sat);
      baseLayers.dark.addTo(map);
      if(hillshadeLayer) hillshadeLayer.addTo(map);
      if(labelLayer) labelLayer.setOpacity(0.95);
    } else {
      isDark = false;
      map.removeLayer(baseLayers.dark);
      if(hillshadeLayer) map.removeLayer(hillshadeLayer);
      baseLayers.sat.addTo(map);
      if(labelLayer) labelLayer.setOpacity(0.85);
    }

    // Make wind more contrasted on satellite by switching arrow alpha
    redrawAll();
  }

  // --- DATA LOAD ---
  async function loadCatalogAndFirstFrame() {
    try {
      const r = await fetch('data_weather/catalog.json?t=' + Date.now());
      if(!r.ok) throw new Error("catalog not found");
      catalog = await r.json();
      if(!catalog || catalog.length === 0) throw new Error("empty catalog");

      const slider = document.getElementById('time-slider');
      slider.max = catalog.length - 1;
      slider.value = 0;
      slider.addEventListener('input', (e) => loadStep(parseInt(e.target.value,10)));

      await loadStep(0);
      document.getElementById('unit-display').innerText = "Pronto";
    } catch(e) {
      document.getElementById('unit-display').innerText = "Errore dati";
    }
  }

  async function loadStep(idx) {
    if(!catalog[idx]) return;
    document.getElementById('time-label').innerText = catalog[idx].label;

    try {
      const r = await fetch('data_weather/' + catalog[idx].file + '?t=' + Date.now());
      if(!r.ok) throw new Error("frame not found");
      currentData = await r.json();
      redrawAll();
    } catch(e) {}
  }

  // --- CANVAS LAYERS ---
  function createCanvasLayers() {
    const mkCanvas = (z) => {
      const c = L.DomUtil.create('canvas', 'leaflet-layer');
      c.style.pointerEvents = 'none';
      c.style.zIndex = z;
      map.getPanes().overlayPane.appendChild(c);
      return c;
    };

    heatCanvas = mkCanvas(300); // heat layers
    isoCanvas  = mkCanvas(400); // isobars
    windCanvas = mkCanvas(500); // wind arrows+wind heat, below particles pane
    map.on('moveend resize', redrawAll);
  }

  function redrawAll() {
    if(!currentData) return;
    drawHeatmap();
    drawIsobars();
    drawWindSynoptic(); // for wind_syn mode (frecce+sfondo)
    updateWindParticles(); // particles toggle
  }

  // --- HEATMAP (no numeri dentro) ---
  function drawHeatmap() {
    const ctx = heatCanvas.getContext('2d');
    const s = map.getSize();
    heatCanvas.width = s.x;
    heatCanvas.height = s.y;
    L.DomUtil.setPosition(heatCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    // heat drawn for: temp/rain/rh/press/cloud
    if(!currentData) return;

    const m = currentData.meta;
    const b = map.getBounds();

    // Draw only if layer is a heat layer OR if wind_syn (draw its wind heat on windCanvas)
    const isHeatLayer = (activeLayer==='temp' || activeLayer==='rain' || activeLayer==='rh' || activeLayer==='press' || activeLayer==='cloud');
    if(!isHeatLayer) return;

    for(let y=0; y<m.ny; y++) {
      const lat = m.la1 - (y*m.dy);
      if(lat < b.getSouth()-0.1 || lat > b.getNorth()+0.1) continue;

      for(let x=0; x<m.nx; x++) {
        const lon = m.lo1 + (x*m.dx);
        if(lon < b.getWest()-0.1 || lon > b.getEast()+0.1) continue;

        const idx = y*m.nx + x;

        let val = 0;
        if(activeLayer==='temp') val = currentData.temp[idx];
        else if(activeLayer==='rain') val = currentData.rain[idx];
        else if(activeLayer==='rh')   val = currentData.rh[idx];
        else if(activeLayer==='press') val = currentData.press[idx];
        else if(activeLayer==='cloud') val = currentData.cloud ? currentData.cloud[idx] : 0;

        const c = getColor(val, activeLayer);
        if(c[3] <= 0) continue;

        const p1 = map.latLngToContainerPoint([lat, lon]);
        const p2 = map.latLngToContainerPoint([lat - m.dy, lon + m.dx]);

        const w = Math.ceil(p2.x - p1.x) + 1;
        const h = Math.ceil(p2.y - p1.y) + 1;

        ctx.fillStyle = `rgba(${c[0]},${c[1]},${c[2]},${c[3]})`;
        ctx.fillRect(Math.floor(p1.x), Math.floor(p1.y), w, h);
      }
    }
  }

  // --- ISOBARE (white on dark as requested, with labels) ---
  function drawIsobars() {
    const ctx = isoCanvas.getContext('2d');
    const s = map.getSize();
    isoCanvas.width = s.x;
    isoCanvas.height = s.y;
    L.DomUtil.setPosition(isoCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    if(!showIso || !currentData || !currentData.press) return;

    const m = currentData.meta;
    const values = currentData.press;

    const contours = d3.contours().size([m.nx, m.ny]).thresholds(d3.range(960, 1050, 2))(values);

    ctx.lineWidth = isDark ? 1.6 : 1.3;
    ctx.font = "900 12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    contours.forEach(c => {
      // Dark: force WHITE isobars (you requested)
      if(isDark) ctx.strokeStyle = "rgba(255,255,255,0.75)";
      else ctx.strokeStyle = "rgba(0,0,0,0.65)";

      ctx.beginPath();
      const labelCandidates = [];

      c.coordinates.forEach(ring => {
        ring.forEach(pts => {
          let first = true;
          const linePts = [];
          pts.forEach(coord => {
            const lat = m.la1 - (coord[1] * m.dy);
            const lon = m.lo1 + (coord[0] * m.dx);
            const p = map.latLngToContainerPoint([lat, lon]);
            linePts.push(p);
            if(first) { ctx.moveTo(p.x, p.y); first=false; }
            else ctx.lineTo(p.x, p.y);
          });
          if(linePts.length > 70) labelCandidates.push(linePts);
        });
      });

      ctx.stroke();

      // Labels
      labelCandidates.forEach(pts => {
        const mid = pts[Math.floor(pts.length/2)];
        const bg = isDark ? "rgba(0,0,0,0.65)" : "rgba(255,255,255,0.75)";
        const fg = isDark ? "#fff" : "#000";
        ctx.fillStyle = bg;
        ctx.fillRect(mid.x-16, mid.y-9, 32, 18);
        ctx.fillStyle = fg;
        ctx.fillText(Math.round(c.value), mid.x, mid.y);
      });
    });
  }

  // --- WIND SYNOPTIC (ARROWS + BACKGROUND INTENSITY) ---
  // Uses SAME color palette as particles for both arrows AND wind intensity background
  function drawWindSynoptic() {
    const ctx = windCanvas.getContext('2d');
    const s = map.getSize();
    windCanvas.width = s.x;
    windCanvas.height = s.y;
    L.DomUtil.setPosition(windCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    if(activeLayer !== 'wind_syn' || !currentData) return;

    const m = currentData.meta;
    const b = map.getBounds();

    // 1) Wind intensity background (subtle, so arrows are visible)
    // Make slightly stronger on satellite as requested
    const bgAlpha = isDark ? 0.28 : 0.36;

    for(let y=0; y<m.ny; y++) {
      const lat = m.la1 - (y*m.dy);
      if(lat < b.getSouth()-0.1 || lat > b.getNorth()+0.1) continue;

      for(let x=0; x<m.nx; x++) {
        const lon = m.lo1 + (x*m.dx);
        if(lon < b.getWest()-0.1 || lon > b.getEast()+0.1) continue;

        const idx = y*m.nx + x;
        const u = currentData.wind_u.data[idx];
        const v = currentData.wind_v.data[idx];
        const sp = Math.sqrt(u*u + v*v);

        const p1 = map.latLngToContainerPoint([lat, lon]);
        const p2 = map.latLngToContainerPoint([lat - m.dy, lon + m.dx]);
        const w = Math.ceil(p2.x - p1.x) + 1;
        const h = Math.ceil(p2.y - p1.y) + 1;

        ctx.fillStyle = windColorFromSpeed(sp, bgAlpha);
        ctx.fillRect(Math.floor(p1.x), Math.floor(p1.y), w, h);
      }
    }

    // 2) Arrows
    // Density: increase a bit for clearer synoptic look
    // Bigger arrows and higher contrast on satellite
    const zoom = map.getZoom();
    const step = (zoom >= 9) ? 2 : (zoom >= 8 ? 3 : 4); // smaller step => more arrows
    const arrowLenBase = (zoom >= 9) ? 18 : 14;
    const arrowWidth = (zoom >= 9) ? 2.2 : 1.9;
    const arrowAlpha = isDark ? 0.95 : 0.98;

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    for(let y=0; y<m.ny; y+=step) {
      const lat = m.la1 - (y*m.dy);
      if(lat < b.getSouth()-0.2 || lat > b.getNorth()+0.2) continue;

      for(let x=0; x<m.nx; x+=step) {
        const lon = m.lo1 + (x*m.dx);
        if(lon < b.getWest()-0.2 || lon > b.getEast()+0.2) continue;

        const idx = y*m.nx + x;
        const u = currentData.wind_u.data[idx];
        const v = currentData.wind_v.data[idx];
        const sp = Math.sqrt(u*u + v*v);
        if(!isFinite(sp) || sp < 0.3) continue;

        // Direction: u east, v north
        // Canvas y increases downwards, so invert north component for screen vector
        const angle = Math.atan2(-v, u);

        const p = map.latLngToContainerPoint([lat, lon]);

        // Length scaled by speed but clamped
        const L = Math.max(8, Math.min(arrowLenBase + sp*1.2, 34));

        const x2 = p.x + Math.cos(angle) * L;
        const y2 = p.y + Math.sin(angle) * L;

        // Color same as particles
        const col = windColorFromSpeed(sp, arrowAlpha);

        // Arrow shaft
        ctx.strokeStyle = col;
        ctx.lineWidth = arrowWidth;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        // Arrow head
        const head = 6.5;
        const a1 = angle + Math.PI * 0.82;
        const a2 = angle - Math.PI * 0.82;

        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 + Math.cos(a1) * head, y2 + Math.sin(a1) * head);
        ctx.lineTo(x2 + Math.cos(a2) * head, y2 + Math.sin(a2) * head);
        ctx.closePath();
        ctx.fillStyle = col;
        ctx.fill();
      }
    }
  }

  // --- WIND PARTICLES (toggle) ---
  function updateWindParticles() {
    if(velocityLayer) { map.removeLayer(velocityLayer); velocityLayer = null; }

    if(!showParticles || !currentData) return;

    // In particles mode, we ignore wind_syn background canvas (still drawn only if activeLayer=wind_syn)
    // Particles always visible on top because leaflet-velocity uses its own canvas pane.
    // Reduce particles for FPS
    const isMobile = Math.min(window.innerWidth, window.innerHeight) < 900;
    const dpr = window.devicePixelRatio || 1;
    let particleMult = isMobile ? (1/180) : (1/140);
    if(dpr >= 2) particleMult = isMobile ? (1/260) : (1/200);

    try {
      velocityLayer = L.velocityLayer({
        displayValues: false,
        data: [ currentData.wind_u, currentData.wind_v ],
        maxVelocity: WIND_MAX_VELOCITY,
        velocityScale: WIND_VELOCITY_SCALE,
        particleMultiplier: particleMult,
        lineWidth: WIND_LINE_WIDTH,
        particleAge: WIND_PARTICLE_AGE,
        frameRate: WIND_FRAME_RATE,
        opacity: WIND_OPACITY,
        colorScale: WIND_COLORS
      });
      velocityLayer.addTo(map);
    } catch(e) {}
  }

  // --- PICKER ---
  function unitFor(type){
    if(type==='wind_syn') return 'm/s';
    if(type==='temp') return '¬∞C';
    if(type==='rain') return 'mm';
    if(type==='rh') return '%';
    if(type==='press') return 'hPa';
    if(type==='cloud') return '%';
    return '';
  }

  function valueAtLatLng(latlng) {
    if(!currentData || !currentData.meta) return null;
    const m = currentData.meta;

    const y = Math.round((m.la1 - latlng.lat) / m.dy);
    const x = Math.round((latlng.lng - m.lo1) / m.dx);
    if(x < 0 || x >= m.nx || y < 0 || y >= m.ny) return null;

    const idx = y*m.nx + x;

    if(activeLayer === 'wind_syn') {
      const u = currentData.wind_u.data[idx];
      const v = currentData.wind_v.data[idx];
      return Math.sqrt(u*u + v*v);
    }
    if(activeLayer === 'temp') return currentData.temp[idx];
    if(activeLayer === 'rain') return currentData.rain[idx];
    if(activeLayer === 'rh') return currentData.rh[idx];
    if(activeLayer === 'press') return currentData.press[idx];
    if(activeLayer === 'cloud') return currentData.cloud ? currentData.cloud[idx] : 0;

    return null;
  }

  function updatePickerFromEvent(e) {
    const val = valueAtLatLng(e.latlng);
    if(val === null || val === undefined) return;

    let out = '--';
    if(activeLayer === 'wind_syn') out = val.toFixed(1);
    else if(activeLayer === 'temp') out = val.toFixed(1);
    else if(activeLayer === 'rain') out = val.toFixed(1);
    else if(activeLayer === 'rh') out = Math.round(val).toString();
    else if(activeLayer === 'press') out = Math.round(val).toString();
    else if(activeLayer === 'cloud') out = Math.round(val).toString();

    document.getElementById('val-display').innerText = out;
  }

  // --- UI ACTIONS ---
  window.setLayer = function(type) {
    activeLayer = type;

    document.querySelectorAll('.layer-btn').forEach(btn => {
      if(btn.id !== 'btn-iso' && btn.id !== 'btn-particles') btn.classList.remove('active');
    });
    event.target.classList.add('active');

    document.getElementById('unit-display').innerText = unitFor(type);
    document.getElementById('val-display').innerText = '--';

    redrawAll();
  };

  window.toggleIso = function() {
    showIso = !showIso;
    document.getElementById('btn-iso').classList.toggle('active');
    redrawAll();
  };

  // Particles toggle independent from wind layer
  window.toggleParticles = function() {
    showParticles = !showParticles;
    document.getElementById('btn-particles').classList.toggle('active');

    // If particles enabled, ensure wind layer is meaningful:
    // keep current activeLayer unchanged; just render particles on top.
    updateWindParticles();
  };

  window.togglePlay = function() {
    if(isPlaying) { isPlaying = false; document.getElementById('play-btn').innerText = "‚ñ∫"; return; }
    isPlaying = true;

    const s = document.getElementById('time-slider');
    const btn = document.getElementById('play-btn');
    btn.innerText = "‚ùö‚ùö";

    let i = parseInt(s.value, 10);
    const max = parseInt(s.max, 10);

    const interval = setInterval(() => {
      if(!isPlaying) { clearInterval(interval); btn.innerText = "‚ñ∫"; return; }
      if(i >= max) { clearInterval(interval); isPlaying=false; btn.innerText="‚ñ∫"; return; }
      i++;
      s.value = i;
      loadStep(i);
    }, 800);
  };
</script>

</body>
</html>
```Ó®Å0Ó®Ç