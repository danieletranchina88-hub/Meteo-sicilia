<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - FINAL DARK PRO</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    /* SFONDO SCURO */
    body { margin: 0; background: #1a1a1a; font-family: 'Segoe UI', sans-serif; color: #ddd; overflow: hidden; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #1a1a1a; }

    #ui-container {
      position: absolute; top: 10px; right: 10px; z-index: 2000;
      display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
    }
    .panel {
      background: rgba(30,30,30,0.85); /* Pannelli scuri */
      backdrop-filter: blur(12px);
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 12px 30px rgba(0,0,0,0.6);
      color: #eee;
    }
    .toggle {
      width: 175px;
      display:flex; align-items:center; justify-content:space-between;
      padding: 10px 12px; margin: 6px 0;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #ccc;
      border-radius: 10px;
      cursor: pointer;
      user-select:none;
      font-weight: 700;
      transition: all 0.15s;
    }
    .toggle:hover { background: rgba(255,255,255,0.1); color:#fff; }
    .toggle.active {
      background: linear-gradient(90deg, #0077ff, #0044cc);
      border-color: rgba(0,100,200,0.5);
      color: #fff;
      box-shadow: 0 4px 12px rgba(0,136,255,0.3);
    }
    
    .mini {
      width: 175px; padding: 9px 12px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05);
      color:#ccc; cursor:pointer; font-weight:800;
    }
    .mini:hover { background: rgba(255,255,255,0.1); color:#fff; }
    .mini.active { background: #eee; color:#111; border-color: #fff; }

    /* INFO BOX + WIND ROSE */
    #info-box { 
        position: absolute; top: 18px; left: 18px; z-index: 2000; 
        pointer-events: none; 
        display: flex; align-items: center; gap: 15px;
    }
    #val-group { display: flex; flex-direction: column; }
    #val-display { font-size: 3.6em; font-weight: 950; line-height: 0.9; color: #fff; text-shadow: 0 2px 5px rgba(0,0,0,0.8); }
    #unit-display { font-size: 1.15em; color: #aaa; font-weight: 850; margin-top: 4px; text-shadow: 0 1px 3px rgba(0,0,0,0.9); }

    /* ROSA DEI VENTI (Chiara per contrasto) */
    #wind-rose {
        width: 50px; height: 50px;
        background: rgba(255,255,255,0.9);
        border: 2px solid rgba(255,255,255,0.5);
        border-radius: 50%;
        display: none;
        align-items: center; justify-content: center;
        position: relative;
        box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }
    .cardinal { position: absolute; font-size: 9px; font-weight: 900; color: #111; }
    .c-n { top: 2px; left: 50%; transform: translateX(-50%); }
    .c-s { bottom: 2px; left: 50%; transform: translateX(-50%); }
    .c-e { right: 3px; top: 50%; transform: translateY(-50%); }
    .c-w { left: 3px; top: 50%; transform: translateY(-50%); }
    #rose-arrow { width: 26px; height: 26px; fill: #000; transition: transform 0.1s; }

    #bottom-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: 92px;
      background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
      display: flex; align-items: center; padding: 0 18px; z-index: 2000;
    }
    #play-btn { font-size: 2.6em; background: none; border: none; color: #fff; cursor: pointer; margin-right: 14px; }
    #time-label { font-size: 1.45em; font-weight: 950; margin-left: 14px; min-width: 150px; text-align: center; color: #fff; }
    input[type=range] { flex-grow: 1; height: 6px; cursor: pointer; accent-color: #0077ff; background: rgba(255,255,255,0.2); }

    /* TRUCCO PER MAPPA DARK RELIEF */
    /* Invertiamo i colori della mappa chiara per ottenerne una scura dettagliata */
    .dark-relief-tiles {
        filter: invert(100%) hue-rotate(180deg) brightness(0.8) contrast(1.2) grayscale(20%);
    }

    /* I layer colorati devono essere "lighten" o "screen" per vedersi sul fondo scuro */
    canvas.leaflet-layer.scalar-layer { 
        image-rendering: auto; 
        mix-blend-mode: screen; /* Screen illumina il fondo scuro */
        opacity: 0.85; 
    }

    canvas.leaflet-layer.velocity-canvas {
        mix-blend-mode: normal; 
        opacity: 0.95;
    }

  </style>
</head>

<body>
  <div id="info-box">
    <div id="val-group">
        <div id="val-display">--</div>
        <div id="unit-display">Caricamento...</div>
    </div>
    <div id="wind-rose">
        <span class="cardinal c-n">N</span>
        <span class="cardinal c-s">S</span>
        <span class="cardinal c-e">E</span>
        <span class="cardinal c-w">W</span>
        <svg id="rose-arrow" viewBox="0 0 24 24"><path d="M12 2L4.5 20.29L5.21 21L12 18L18.79 21L19.5 20.29L12 2Z" /></svg>
    </div>
  </div>

  <div id="ui-container">
    <div class="panel">
      <button id="btn-flow" class="mini active" onclick="toggleParticles()">FLUSSO üå¨Ô∏è (ON)</button>
    </div>

    <div class="panel">
      <div style="font-weight:950; opacity:0.8; margin-bottom:6px; color:#aaa;">LIVELLI</div>

      <div class="toggle active" onclick="toggleLayer('wind')">
        <span>VENTO (frecce) üß≠</span><span>‚óè</span>
      </div>

      <div class="toggle" onclick="toggleLayer('temp')">
        <span>TEMP üå°Ô∏è</span><span>‚óè</span>
      </div>

      <div class="toggle" onclick="toggleLayer('rain')">
        <span>PIOGGIA ‚òî</span><span>‚óè</span>
      </div>

      <div class="toggle" onclick="toggleLayer('rh')">
        <span>UMIDIT√Ä üíß</span><span>‚óè</span>
      </div>

      <div class="toggle" onclick="toggleLayer('press')">
        <span>PRESSIONE ‚è≤Ô∏è</span><span>‚óè</span>
      </div>

      <div class="toggle" onclick="toggleLayer('cloud')">
        <span>NUVOLE ‚òÅÔ∏è</span><span>‚óè</span>
      </div>

      <div style="height:1px; background: rgba(255,255,255,0.1); margin:10px 0;"></div>

      <div class="toggle" id="btn-iso" onclick="toggleIsobars()">
        <span>ISOBARE „Ä∞Ô∏è</span><span> </span>
      </div>
      
      <div class="toggle" id="btn-grid" onclick="toggleGrid()">
        <span>RETICOLO #</span><span> </span>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  const SICILY_BOUNDS = L.latLngBounds(L.latLng(35.0, 11.0), L.latLng(39.5, 16.5));

  const WIND_COLOR_SCALE = ["#000080", "#0044ff", "#00ddff", "#00ff55", "#ffff00", "#ff6600", "#ff0000", "#ff00ff"];

  const TEMP_STOPS = [
    {v:-10, c:[255, 255, 255]}, {v: -5, c:[180, 0, 255]}, {v:0, c:[0, 0, 255]},     
    {v:5, c:[0, 100, 255]}, {v: 10, c:[0, 180, 0]}, {v: 15, c:[100, 255, 0]},
    {v: 18, c:[200, 255, 0]}, {v: 20, c:[255, 255, 0]}, {v: 25, c:[255, 160, 0]},   
    {v: 30, c:[255, 0, 0]}, {v: 35, c:[180, 0, 0]}, {v: 40, c:[100, 0, 0]}
  ];

  const RAIN_STOPS = [
    {v:0.0, c:[0,0,0], a:0.0}, {v:0.2, c:[100, 200, 255], a:0.6},
    {v:1.0, c:[0, 150, 255], a:0.7}, {v:5.0, c:[0, 0, 255], a:0.8},     
    {v:10,  c:[255, 255, 0], a:0.8}, {v:30,  c:[255, 150, 0], a:0.85}, {v:50,  c:[255, 0, 0], a:0.9}      
  ];

  const RH_STOPS = [
    {v:20, c:[255, 100, 0], a:0.6}, {v:40, c:[255, 255, 0], a:0.5},
    {v:60, c:[255, 255, 255], a:0.4}, {v:80, c:[100, 255, 100], a:0.6}, {v:95, c:[0, 100, 255],  a:0.7}   
  ];

  const PRESS_STOPS = [
    {v:980, c:[120, 0, 255], a:0.6}, {v:1000, c:[0, 0, 255], a:0.5},
    {v:1013, c:[0, 255, 100], a:0.4}, {v:1025, c:[255, 255, 0], a:0.5},
    {v:1040, c:[255, 0, 0], a:0.6}   
  ];

  const CLOUD_STOPS = [
    {v:0, c:[255,255,255], a:0}, {v:50, c:[200,200,200], a:0.4}, {v:100, c:[100,100,100], a:0.7}
  ];

  let map, currentData = null, catalog = [];
  const selected = new Set(['wind']); 
  let showIsobars = false, showGrid = false, particlesOn = true;
  let velocityLayer = null, scalarCanvases = {}, arrowCanvas, isoCanvas, gridCanvas;
  let isPlaying = false;

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function lerp(a,b,t){ return a+(b-a)*t; }

  function interpStops(val, stops) {
    if(!stops || stops.length < 2) return {r:0,g:0,b:0,a:0};
    if(val <= stops[0].v) { const s=stops[0]; return {r:s.c[0],g:s.c[1],b:s.c[2],a:s.a||0.8}; }
    for(let i=0;i<stops.length-1;i++){
      if(val >= stops[i].v && val < stops[i+1].v){
        const s = stops[i]; 
        return { r:s.c[0], g:s.c[1], b:s.c[2], a:('a'in s)?s.a:0.8 };
      }
    }
    const s=stops[stops.length-1]; return {r:s.c[0],g:s.c[1],b:s.c[2],a:s.a||0.8};
  }

  function vividWindColor(speedMs){
    const maxV = 20.0; const t = clamp(speedMs/maxV, 0, 0.9999);
    const n = WIND_COLOR_SCALE.length; const pos = t*(n-1);
    const i = Math.floor(pos); const f = pos - i;
    const hex1=WIND_COLOR_SCALE[i], hex2=WIND_COLOR_SCALE[Math.min(i+1,n-1)];
    const r1=parseInt(hex1.slice(1,3),16), g1=parseInt(hex1.slice(3,5),16), b1=parseInt(hex1.slice(5,7),16);
    const r2=parseInt(hex2.slice(1,3),16), g2=parseInt(hex2.slice(3,5),16), b2=parseInt(hex2.slice(5,7),16);
    return {r:Math.round(lerp(r1,r2,f)), g:Math.round(lerp(g1,g2,f)), b:Math.round(lerp(b1,b2,f))};
  }

  window.addEventListener('load', async () => {
    map = L.map('map', { zoomControl: false, maxBounds: SICILY_BOUNDS.pad(0.5), background: '#1a1a1a' }).fitBounds(SICILY_BOUNDS);

    // 1. BASE: Esri Shaded Relief INVERTITA (DARK RELIEF)
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}', { 
        maxZoom: 13, 
        attribution: 'Esri',
        className: 'dark-relief-tiles' // Applica inversione colori
    }).addTo(map);

    // 2. CONFINI SICILIA
    map.createPane('boundaryPane');
    map.getPane('boundaryPane').style.zIndex = 250;
    map.getPane('boundaryPane').style.pointerEvents = 'none';
    fetch('https://raw.githubusercontent.com/openpolis/geojson-italy/master/geojson/limits_IT_regions.geojson')
        .then(r => r.json())
        .then(data => {
            const sicily = data.features.filter(f => f.properties.reg_name === "Sicilia")[0];
            L.geoJSON(sicily, {
                pane: 'boundaryPane',
                style: { color: "#555", weight: 2, fillOpacity: 0 }
            }).addTo(map);
        }).catch(e=>{});

    // 3. HILLSHADE (Invertita leggermente per adattarsi)
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}', { 
        maxZoom: 19, 
        className: 'dark-relief-tiles', // Usa lo stesso filtro
        opacity: 0.4 
    }).addTo(map);

    // 4. LABELS
    map.createPane('labelsPane'); map.getPane('labelsPane').style.zIndex = 600; map.getPane('labelsPane').style.pointerEvents = 'none';
    // Usa le etichette "Light" di Carto che, su sfondo scuro, sono leggibili
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { pane: 'labelsPane', opacity: 0.9 }).addTo(map);

    map.createPane('particlePane'); map.getPane('particlePane').style.zIndex = 800; map.getPane('particlePane').style.pointerEvents = 'none';

    createCanvasLayers();
    await loadCatalog();

    map.on('mousemove', onPick);
    map.on('click', onPick);
    map.on('moveend zoomend resize', redrawAll);
    document.getElementById('unit-display').innerText = '';
  });

  function createCanvasLayers(){
    function mkCanvas(z, cls){
      const c = L.DomUtil.create('canvas', 'leaflet-layer ' + (cls||''));
      c.style.pointerEvents = 'none'; c.style.zIndex = z;
      c.style.imageRendering = 'auto'; 
      map.getPanes().overlayPane.appendChild(c);
      return c;
    }
    scalarCanvases.wind = mkCanvas(290, 'scalar-layer'); 
    scalarCanvases.temp = mkCanvas(300, 'scalar-layer');
    scalarCanvases.rain = mkCanvas(310, 'scalar-layer');
    scalarCanvases.rh = mkCanvas(320, 'scalar-layer');
    scalarCanvases.press = mkCanvas(330, 'scalar-layer');
    scalarCanvases.cloud = mkCanvas(340, 'scalar-layer');
    arrowCanvas = mkCanvas(380);
    isoCanvas = mkCanvas(420);
    gridCanvas = mkCanvas(450);
  }

  async function loadCatalog(){
    try{
      const r = await fetch('data_weather/catalog.json?t=' + Date.now());
      if(!r.ok) throw new Error();
      catalog = await r.json();
      const slider = document.getElementById('time-slider');
      slider.max = catalog.length - 1;
      slider.addEventListener('input', (e)=> loadStep(parseInt(e.target.value)));
      await loadStep(0);
    } catch(e){}
  }

  async function loadStep(i){
    if(!catalog[i]) return;
    document.getElementById('time-label').innerText = catalog[i].label;
    try{
      const r = await fetch('data_weather/' + catalog[i].file + '?t=' + Date.now());
      currentData = await r.json();
      redrawAll();
    } catch(e){}
  }

  function redrawAll(){
    if(!currentData) return;
    drawScalars();
    drawWindArrows();
    drawIsobars();
    drawLatLonGrid();
    updateParticles();
  }

  function drawScalars(){
    ['wind','temp','rain','rh','press','cloud'].forEach(layer => {
        const canvas = scalarCanvases[layer];
        const ctx = canvas.getContext('2d');
        const s = map.getSize();
        canvas.width = s.x; canvas.height = s.y;
        L.DomUtil.setPosition(canvas, map.containerPointToLayerPoint([0,0]));
        ctx.clearRect(0,0,s.x,s.y);

        if(!selected.has(layer) || !currentData.meta) return;
        const m = currentData.meta;
        const off = document.createElement('canvas');
        off.width = m.nx; off.height = m.ny;
        const octx = off.getContext('2d');
        const img = octx.createImageData(m.nx, m.ny);
        const data = img.data;

        let arr, stops, isWindBg=false;
        if(layer==='wind') { isWindBg=true; stops = WIND_COLOR_SCALE; }
        else if(layer==='temp') { arr = currentData.temp; stops = TEMP_STOPS; }
        else if(layer==='rain') { arr = currentData.rain; stops = RAIN_STOPS; }
        else if(layer==='rh') { arr = currentData.rh; stops = RH_STOPS; }
        else if(layer==='press') { arr = currentData.press; stops = PRESS_STOPS; }
        else if(layer==='cloud') { arr = (currentData.cloud??currentData.cld); stops = CLOUD_STOPS; }

        if(!arr && !isWindBg) return;

        for(let i=0; i<m.nx*m.ny; i++){
            let val = 0, col = {r:0,g:0,b:0,a:0};
            if(isWindBg){
                const u = currentData.wind_u.data[i], v = currentData.wind_v.data[i];
                val = Math.sqrt(u*u+v*v);
                col = vividWindColor(val); col.a = 0.45;
            } else {
                val = arr[i] || 0;
                if(layer==='rain' && val < 0.1) { data[i*4+3]=0; continue; }
                if(layer==='cloud' && val < 10) { data[i*4+3]=0; continue; }
                col = interpStops(val, stops); 
            }
            const p = i*4;
            data[p] = col.r; data[p+1] = col.g; data[p+2] = col.b; data[p+3] = Math.round(col.a*255);
        }
        octx.putImageData(img, 0, 0);
        const tl = map.latLngToContainerPoint([m.la1, m.lo1]);
        const br = map.latLngToContainerPoint([m.la2, m.lo2]);
        ctx.save();
        ctx.imageSmoothingEnabled = true; 
        ctx.drawImage(off, tl.x, tl.y, br.x-tl.x, br.y-tl.y);
        ctx.restore();
    });
  }

  function drawLatLonGrid(){
    const ctx = gridCanvas.getContext('2d');
    const s = map.getSize();
    gridCanvas.width = s.x; gridCanvas.height = s.y;
    L.DomUtil.setPosition(gridCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);
    if(!showGrid) return;
    const b = map.getBounds(); const zoom = map.getZoom();
    let step = 1.0; if(zoom >= 9) step = 0.5; if(zoom >= 11) step = 0.2;
    ctx.lineWidth = 1; ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.setLineDash([5, 5]); ctx.font = "10px sans-serif"; ctx.fillStyle = "#aaa";
    const startLon = Math.ceil(b.getWest() / step) * step;
    for(let lon = startLon; lon <= b.getEast(); lon += step){
        const x = map.latLngToContainerPoint([b.getSouth(), lon]).x;
        if(x<0||x>s.x) continue;
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, s.y); ctx.stroke();
        ctx.fillText(lon.toFixed(1) + "¬∞E", x + 2, s.y - 10);
    }
    const startLat = Math.ceil(b.getSouth() / step) * step;
    for(let lat = startLat; lat <= b.getNorth(); lat += step){
        const y = map.latLngToContainerPoint([lat, b.getWest()]).y;
        if(y<0||y>s.y) continue;
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(s.x, y); ctx.stroke();
        ctx.fillText(lat.toFixed(1) + "¬∞N", 5, y - 2);
    }
    ctx.setLineDash([]);
  }

  function drawWindArrows(){
    const ctx = arrowCanvas.getContext('2d');
    const s = map.getSize();
    arrowCanvas.width = s.x; arrowCanvas.height = s.y;
    L.DomUtil.setPosition(arrowCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    if(!selected.has('wind') || !currentData) return;
    const m = currentData.meta; const zoom = map.getZoom();
    const stride = zoom >= 10 ? 2 : (zoom >= 9 ? 3 : 4);
    const baseLen = zoom >= 10 ? 28 : 22; const baseWidth = 2.5; 
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';

    for(let y=0; y<m.ny; y+=stride){
        const lat = m.la1 - y*m.dy;
        for(let x=0; x<m.nx; x+=stride){
            const idx = y*m.nx + x;
            const u = currentData.wind_u.data[idx], v = currentData.wind_v.data[idx];
            const sp = Math.sqrt(u*u+v*v);
            if(sp < 1) continue; 
            const lon = m.lo1 + x*m.dx;
            const p = map.latLngToContainerPoint([lat, lon]);
            
            const cRg = vividWindColor(sp);
            const fillStyle = `rgb(${cRg.r},${cRg.g},${cRg.b})`;
            const speedScale = clamp(sp/9.0, 0.65, 2.5); 
            const currentLen = baseLen*speedScale; const currentWidth = baseWidth*speedScale;
            const headLen = currentLen*0.4; const headWidth = headLen*0.75;
            const angle = Math.atan2(-v, u);
            
            // ASTA
            const shaftEndX = p.x + (currentLen-headLen)*Math.cos(angle);
            const shaftEndY = p.y + (currentLen-headLen)*Math.sin(angle);
            ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(shaftEndX, shaftEndY);
            ctx.strokeStyle = "#000000"; ctx.lineWidth = currentWidth+2.5; ctx.stroke(); // Bordo
            ctx.strokeStyle = fillStyle; ctx.lineWidth = currentWidth; ctx.stroke(); // Interno

            // TESTA
            const tipX = p.x + currentLen*Math.cos(angle);
            const tipY = p.y + currentLen*Math.sin(angle);
            const wing1X = shaftEndX - headWidth*Math.cos(angle - Math.PI/2);
            const wing1Y = shaftEndY - headWidth*Math.sin(angle - Math.PI/2);
            const wing2X = shaftEndX - headWidth*Math.cos(angle + Math.PI/2);
            const wing2Y = shaftEndY - headWidth*Math.sin(angle + Math.PI/2);

            ctx.beginPath(); ctx.moveTo(tipX, tipY); ctx.lineTo(wing1X, wing1Y); ctx.lineTo(wing2X, wing2Y); ctx.closePath();
            ctx.fillStyle = "#000000"; ctx.fill(); ctx.lineWidth=1.0; ctx.stroke(); // Bordo
            ctx.fillStyle = fillStyle; ctx.fill(); // Interno
        }
    }
  }

  function updateParticles(){
    if(velocityLayer) { map.removeLayer(velocityLayer); velocityLayer = null; }
    if(!particlesOn || !currentData) return;
    velocityLayer = L.velocityLayer({
      displayValues: false, data: [ currentData.wind_u, currentData.wind_v ],
      maxVelocity: 20.0, velocityScale: 0.008, particleMultiplier: 1/120, lineWidth: 2.0,            
      particleAge: 100, frameRate: 40, opacity: 1.0, colorScale: WIND_COLOR_SCALE, pane: 'particlePane' 
    });
    velocityLayer.onAdd = function(map){ L.VelocityLayer.prototype.onAdd.call(this, map); this._canvas.classList.add('velocity-canvas'); };
    velocityLayer.addTo(map);
  }

  function drawIsobars(){
    const ctx = isoCanvas.getContext('2d');
    const s = map.getSize();
    isoCanvas.width = s.x; isoCanvas.height = s.y;
    L.DomUtil.setPosition(isoCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);
    if(!showIsobars || !currentData?.press) return;
    const m = currentData.meta;
    const contours = d3.contours().size([m.nx, m.ny]).thresholds(d3.range(960, 1050, 2))(currentData.press);
    ctx.lineWidth = 1.8; ctx.strokeStyle = "rgba(255,255,255,0.7)"; // Isobare bianche su scuro
    ctx.font = "bold 12px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle";
    contours.forEach(c => {
        // FIX ISOBARE: Ignora valori irrealistici (<960) che causano linee verticali
        if(c.value < 960) return;

        ctx.beginPath();
        c.coordinates.forEach(ring => {
            let pts = [];
            let first=true;
            ring.forEach(arr => {
               arr.forEach(coord => {
                   const lat = m.la1 - coord[1]*m.dy; const lon = m.lo1 + coord[0]*m.dx;
                   const p = map.latLngToContainerPoint([lat,lon]);
                   if(first){ ctx.moveTo(p.x,p.y); first=false; } else ctx.lineTo(p.x,p.y);
                   pts.push(p);
               });
            });
            ctx.stroke();
            if(pts.length>20){
                let mid=pts[Math.floor(pts.length/2)];
                ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.fillRect(mid.x-14,mid.y-7,28,14);
                ctx.fillStyle="#fff"; ctx.fillText(Math.round(c.value),mid.x,mid.y);
            }
        });
    });
  }

  window.toggleLayer = function(name){
    if(selected.has(name)) selected.delete(name); else selected.add(name);
    updateToggleUI(); redrawAll();
  }
  window.toggleIsobars = function(){ showIsobars=!showIsobars; updateToggleUI(); redrawAll(); }
  window.toggleGrid = function(){ showGrid=!showGrid; updateToggleUI(); redrawAll(); }
  window.toggleParticles = function(){ particlesOn=!particlesOn; updateToggleUI(); redrawAll(); }

  function updateToggleUI(){
    document.querySelectorAll('.toggle').forEach(el => {
      const txt = el.innerText.toLowerCase();
      if(txt.includes('vento') && selected.has('wind')) el.classList.add('active');
      else if(txt.includes('temp') && selected.has('temp')) el.classList.add('active');
      else if(txt.includes('pioggia') && selected.has('rain')) el.classList.add('active');
      else if(txt.includes('umidit√†') && selected.has('rh')) el.classList.add('active');
      else if(txt.includes('pressione') && selected.has('press')) el.classList.add('active');
      else if(txt.includes('nuvole') && selected.has('cloud')) el.classList.add('active');
      else if(txt.includes('isobare') && showIsobars) el.classList.add('active');
      else if(txt.includes('reticolo') && showGrid) el.classList.add('active');
      else el.classList.remove('active');
    });
    const btnFlow = document.getElementById('btn-flow');
    if(particlesOn) btnFlow.classList.add('active'); else btnFlow.classList.remove('active');
    document.getElementById('wind-rose').style.display = selected.has('wind') ? 'flex' : 'none';
  }

  function onPick(e){
    if(!currentData) return;
    const m = currentData.meta;
    const y = Math.round((m.la1 - e.latlng.lat)/m.dy);
    const x = Math.round((e.latlng.lng - m.lo1)/m.dx);
    if(x<0||x>=m.nx||y<0||y>=m.ny) return;
    const idx = y*m.nx + x;
    let val = '--', unit = '';
    if(selected.has('rain')) { val = currentData.rain[idx].toFixed(1); unit='mm'; }
    else if(selected.has('temp')) { val = currentData.temp[idx].toFixed(1); unit='¬∞C'; }
    else if(selected.has('wind')) { 
        const u=currentData.wind_u.data[idx], v=currentData.wind_v.data[idx];
        val = (Math.sqrt(u*u+v*v)*3.6).toFixed(1); unit='km/h'; 
        const arrow = document.getElementById('rose-arrow');
        const deg = 90 - (Math.atan2(v, u) * 180 / Math.PI);
        arrow.style.transform = `rotate(${deg}deg)`;
    }
    else if(selected.has('rh')) { val = Math.round(currentData.rh[idx]); unit='%'; }
    else if(selected.has('press')) { val = Math.round(currentData.press[idx]); unit='hPa'; }
    document.getElementById('val-display').innerText = val;
    document.getElementById('unit-display').innerText = unit;
  }

  window.togglePlay = function(){
    if(isPlaying){ isPlaying=false; document.getElementById('play-btn').innerText='‚ñ∫'; return; }
    isPlaying=true; document.getElementById('play-btn').innerText='‚ùö‚ùö';
    const s = document.getElementById('time-slider');
    let i = parseInt(s.value);
    const loop = setInterval(()=>{
        if(!isPlaying || i>=s.max) { clearInterval(loop); isPlaying=false; document.getElementById('play-btn').innerText='‚ñ∫'; return; }
        i++; s.value=i; loadStep(i);
    }, 800);
  }
</script>
</body>
</html>
