<!DOCTYPE html>
<html lang="it">
<head>
  <title>Sicilia MeteoHub - PRO (Relief + MultiLayer + A/B + Wind BG)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Particelle (leaflet-velocity) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <!-- Contours -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin:0; background:#111; font-family: "Segoe UI", system-ui, -apple-system, Arial; color:#fff; overflow:hidden; }
    #map { position:absolute; inset:0; background:#111; }

    #info-box{
      position:absolute; top:16px; left:16px; z-index:2000;
      pointer-events:none;
      text-shadow: 0 2px 12px rgba(0,0,0,0.9);
    }
    #val-display{ font-size: 3.0em; font-weight: 900; line-height: 1; }
    #unit-display{ font-size: 1.1em; opacity:0.85; font-weight: 800; }

    #ui-container{
      position:absolute; top:10px; right:10px; z-index:2500;
      display:flex; flex-direction:column; gap:10px; align-items:flex-end;
    }
    .panel{
      background: rgba(0,0,0,0.78);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(8px);
      border-radius: 14px;
      padding: 10px;
      min-width: 190px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }

    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin:6px 0; }
    .row label{ display:flex; align-items:center; gap:10px; font-weight: 800; font-size: 12px; color:#eaeaea; user-select:none; cursor:pointer;}
    .row input[type="checkbox"]{ transform: scale(1.1); }

    .btn{
      width:100%;
      padding:10px 12px;
      border-radius:10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color:#fff;
      font-weight: 900;
      cursor:pointer;
      transition: 0.15s;
    }
    .btn:hover{ background: rgba(255,255,255,0.12); }
    .btn.active{ background:#1d7cff; border-color:#1d7cff; }

    .small{
      font-size: 11px;
      opacity: 0.8;
      line-height: 1.25;
      margin-top: 6px;
    }

    #bottom-bar{
      position:absolute; left:0; right:0; bottom:0;
      height: 90px;
      z-index: 2600;
      display:flex; align-items:center; gap:14px;
      padding: 0 16px;
      background: linear-gradient(to top, rgba(0,0,0,0.92), rgba(0,0,0,0));
    }
    #play-btn{
      width:56px; height:56px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.08);
      color:#fff;
      font-size: 28px;
      cursor:pointer;
    }
    #time-label{
      min-width: 150px;
      text-align:center;
      font-weight: 900;
      text-shadow: 0 2px 10px rgba(0,0,0,0.8);
    }
    input[type="range"]{ flex:1; height: 6px; accent-color:#1d7cff; }

    .ol-canvas{
      position:absolute;
      left:0; top:0;
      pointer-events:none;
      image-rendering: auto;
    }

    #toast{
      position:absolute; left:16px; bottom:104px; z-index:3000;
      padding:10px 12px;
      border-radius:12px;
      background: rgba(120,0,0,0.55);
      border:1px solid rgba(255,120,120,0.35);
      display:none;
      max-width: 85vw;
      font-weight: 800;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">Caricamento...</div>
  </div>

  <div id="ui-container">
    <div class="panel">
      <button class="btn active" id="btn-base-relief">ESRI RELIEF</button>
      <div class="small">Basemap: Esri World Shaded Relief + nomi citt√† (overlay).</div>
    </div>

    <div class="panel" id="layers-panel">
      <div style="font-weight:900; opacity:.9; margin-bottom:6px;">LIVELLI (multi-selezione)</div>

      <div class="row"><label><input type="checkbox" id="chk-temp"> TEMP üå°Ô∏è</label></div>
      <div class="row"><label><input type="checkbox" id="chk-rain"> PIOGGIA ‚òî</label></div>
      <div class="row"><label><input type="checkbox" id="chk-rh"> UMIDIT√Ä üíß</label></div>
      <div class="row"><label><input type="checkbox" id="chk-press"> PRESSIONE ‚è≤Ô∏è</label></div>
      <div class="row"><label><input type="checkbox" id="chk-cloud"> NUVOLE ‚òÅÔ∏è</label></div>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:10px 0;">

      <button class="btn active" id="btn-wind-arrows">VENTO (FRECCE + SFONDO) üí®</button>
      <button class="btn" id="btn-particles">PARTICELLE (flusso)</button>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:10px 0;">

      <button class="btn" id="btn-isobars">ISOBARE „Ä∞Ô∏è (con A/B)</button>

      <div class="small">Tocca/clicca la mappa per leggere il valore sotto al dito.</div>
    </div>
  </div>

  <div id="bottom-bar">
    <button id="play-btn" title="Play/Pausa">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

  <div id="toast"></div>

<script>
/* =============================
   CONFIG MAP (Sicilia bounds)
============================= */
const SICILY_BOUNDS = L.latLngBounds(
  L.latLng(35.0, 11.0),
  L.latLng(39.5, 16.5)
);

let map;
let baseRelief, labelsOverlay;

let currentData = null, catalog = [];

let isPlaying = false;
let showIsobars = false;
let showWindArrows = true;
let showParticles = false;

let scalarCanvas, isobarCanvas, windBGCanvas, windArrowCanvas;
let velocityLayer = null;

const selected = { temp:false, rain:false, rh:false, press:false, cloud:false };

/* =============================
   RENDER THROTTLE (FPS FIX)
   - Ridisegna max ~30fps
   - Evita redraw multipli durante pan/zoom
============================= */
let _dirty = false;
let _raf = 0;
let _lastDraw = 0;
const TARGET_MS = 33; // ~30 FPS

function requestRedraw(force=false){
  if(force) _lastDraw = 0;
  _dirty = true;
  if(_raf) return;
  _raf = requestAnimationFrame(drawLoop);
}
function drawLoop(ts){
  _raf = 0;
  if(!_dirty) return;

  if(ts - _lastDraw < TARGET_MS){
    _raf = requestAnimationFrame(drawLoop);
    return;
  }

  _dirty = false;
  _lastDraw = ts;
  redrawAll();
}

/* =============================
   UI helpers
============================= */
function toast(msg){
  const t = document.getElementById('toast');
  t.innerText = msg;
  t.style.display = 'block';
  clearTimeout(toast._tm);
  toast._tm = setTimeout(()=> t.style.display='none', 3500);
}
function unitFor(key){
  if(key==='wind') return 'km/h';
  if(key==='temp') return '¬∞C';
  if(key==='rain') return 'mm';
  if(key==='rh') return '%';
  if(key==='press') return 'hPa';
  if(key==='cloud') return '%';
  return '';
}

/* =============================
   Color helpers
============================= */
function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

function hexToRgb(hex){
  const h = hex.replace('#','').trim();
  const n = parseInt(h, 16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}
function rgbToCss(rgb, a=1){
  return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
}
function mixRgb(a,b,t){
  return [
    Math.round(lerp(a[0],b[0],t)),
    Math.round(lerp(a[1],b[1],t)),
    Math.round(lerp(a[2],b[2],t))
  ];
}
function brighten(rgb, factor){
  return [
    Math.round(clamp(rgb[0]*factor, 0, 255)),
    Math.round(clamp(rgb[1]*factor, 0, 255)),
    Math.round(clamp(rgb[2]*factor, 0, 255))
  ];
}

/* =============================
   PALETTES
============================= */
const TEMP_STOPS = [
  { v:-15, c:[ 70,  0, 110] },
  { v:  0, c:[  0, 230, 255] },
  { v: 15, c:[255, 255, 170] },
  { v: 20, c:[255, 235,   0] },
  { v: 25, c:[255, 170,  70] },
  { v: 30, c:[255, 120,   0] },
  { v: 35, c:[255,  40,  40] },
  { v: 45, c:[140,   0,   0] }
];

const RAIN_STOPS = [
  { v:0.0,  c:[0,0,0,0] },
  { v:0.2,  c:[ 80, 200, 255, 0.55] },
  { v:2.0,  c:[  0, 120, 255, 0.70] },
  { v:10.0, c:[  0,  40, 200, 0.82] },
  { v:30.0, c:[150,   0, 200, 0.90] }
];

const RH_STOPS = [
  { v:20,c:[210,160, 60, 0.55] },
  { v:40,c:[220,220,220,0.55] },
  { v:60,c:[ 80,255,130, 0.62] },
  { v:80,c:[ 60,160,255, 0.70] },
  { v:95,c:[  0, 60,220, 0.78] }
];

const PRESS_STOPS = [
  { v:980,  c:[  0, 70, 255, 0.60] },
  { v:995,  c:[  0,170, 255, 0.62] },
  { v:1005, c:[  0,255, 200, 0.64] },
  { v:1013, c:[255,255, 255, 0.64] },
  { v:1022, c:[255,200,   0, 0.66] },
  { v:1035, c:[255, 60,   0, 0.70] }
];

const CLOUD_STOPS = [
  { v:0,   c:[255,255,255,0.00] },
  { v:20,  c:[235,235,235,0.40] },
  { v:40,  c:[210,210,210,0.55] },
  { v:60,  c:[175,175,175,0.68] },
  { v:80,  c:[120,120,120,0.78] },
  { v:100, c:[ 60, 60, 60,0.86] }
];

function colorFromStops(val, stops){
  if(!stops || stops.length<2) return [0,0,0,0];
  if(val <= stops[0].v){
    const c = stops[0].c.slice(); if(c.length===3) c.push(1); return c;
  }
  if(val >= stops[stops.length-1].v){
    const c = stops[stops.length-1].c.slice(); if(c.length===3) c.push(1); return c;
  }
  for(let i=0;i<stops.length-1;i++){
    const a = stops[i], b = stops[i+1];
    if(val >= a.v && val <= b.v){
      const t = (val - a.v) / (b.v - a.v);
      const ca=a.c, cb=b.c;
      const out=[
        Math.round(lerp(ca[0],cb[0],t)),
        Math.round(lerp(ca[1],cb[1],t)),
        Math.round(lerp(ca[2],cb[2],t))
      ];
      const aa=(ca.length===4?ca[3]:1), ab=(cb.length===4?cb[3]:1);
      out.push(lerp(aa,ab,t));
      return out;
    }
  }
  return [0,0,0,0];
}
function tempColor(valC){
  const v = clamp(valC, -15, 45);
  const c = colorFromStops(v, TEMP_STOPS);
  return [c[0],c[1],c[2], clamp((c[3]??1), 0, 1)];
}

/* Wind palette (come i tuoi originali) */
const WIND_COLORS_HEX = ["#000080", "#0044ff", "#00ddff", "#00ff55", "#ffff00", "#ff6600", "#ff0000", "#ff00ff"];
const WIND_COLORS_RGB = WIND_COLORS_HEX.map(hexToRgb);

function windRgb(speedKmh){
  const v = clamp(speedKmh, 0, 100);
  const t = v / 100;
  const f = t * (WIND_COLORS_RGB.length - 1);
  const i = Math.floor(f);
  const j = Math.min(i+1, WIND_COLORS_RGB.length-1);
  const tt = f - i;
  return mixRgb(WIND_COLORS_RGB[i], WIND_COLORS_RGB[j], tt);
}

/* =============================
   Init
============================= */
window.addEventListener('load', async () => {
  map = L.map('map', {
    zoomControl: false,
    minZoom: 6,
    maxZoom: 12,
    maxBounds: SICILY_BOUNDS.pad(0.25),
    maxBoundsViscosity: 0.85
  }).fitBounds(SICILY_BOUNDS);

  baseRelief = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 13, attribution: "Tiles ¬© Esri" }
  ).addTo(map);

  labelsOverlay = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    { maxZoom: 19, opacity: 0.45, attribution: "¬© OpenStreetMap" }
  ).addTo(map);

  createCanvasLayers();
  hookUI();

  await loadCatalogAndFirstFrame();

  map.on('mousemove', updatePickerFromEvent);
  map.on('click', updatePickerFromEvent);

  // Ridisegno SOLO a fine movimento/zoom (non continuo)
  map.on('moveend', ()=> requestRedraw(true));
  map.on('zoomend', ()=> requestRedraw(true));
  window.addEventListener('resize', ()=> requestRedraw(true));

  document.getElementById('unit-display').innerText = unitFor('wind');
});

/* =============================
   UI
============================= */
function hookUI(){
  const bindChk = (id, key) => {
    document.getElementById(id).addEventListener('change', (e)=>{
      selected[key] = !!e.target.checked;
      requestRedraw();
    });
  };
  bindChk('chk-temp', 'temp');
  bindChk('chk-rain', 'rain');
  bindChk('chk-rh', 'rh');
  bindChk('chk-press', 'press');
  bindChk('chk-cloud', 'cloud');

  const btnWind = document.getElementById('btn-wind-arrows');
  btnWind.addEventListener('click', ()=>{
    showWindArrows = !showWindArrows;
    btnWind.classList.toggle('active', showWindArrows);
    requestRedraw(true);
  });

  const btnPart = document.getElementById('btn-particles');
  btnPart.addEventListener('click', ()=>{
    showParticles = !showParticles;
    btnPart.classList.toggle('active', showParticles);
    updateParticles();
  });

  const btnIso = document.getElementById('btn-isobars');
  btnIso.addEventListener('click', ()=>{
    showIsobars = !showIsobars;
    btnIso.classList.toggle('active', showIsobars);
    requestRedraw(true);
  });

  document.getElementById('play-btn').addEventListener('click', togglePlay);
}

/* =============================
   Data load
============================= */
async function loadCatalogAndFirstFrame(){
  try{
    const r = await fetch('data_weather/catalog.json?t=' + Date.now());
    if(!r.ok) throw new Error('catalog not found');
    catalog = await r.json();
    if(!catalog?.length) throw new Error('empty catalog');

    const slider = document.getElementById('time-slider');
    slider.max = catalog.length - 1;
    slider.value = 0;
    slider.addEventListener('input', (e)=> loadStep(parseInt(e.target.value, 10)));

    await loadStep(0);
    document.getElementById('unit-display').innerText = "Pronto";
  }catch(e){
    document.getElementById('unit-display').innerText = "Errore dati";
    toast("Catalog o dati non trovati in data_weather/. Controlla deploy.");
  }
}

async function loadStep(idx){
  if(!catalog[idx]) return;
  document.getElementById('time-label').innerText = catalog[idx].label;

  try{
    const r = await fetch('data_weather/' + catalog[idx].file + '?t=' + Date.now());
    if(!r.ok) throw new Error('frame not found');
    currentData = await r.json();

    requestRedraw(true);
    updateParticles();
  }catch(e){
    toast("Frame non caricato (file mancante o JSON invalido).");
  }
}

/* =============================
   Canvas layers
============================= */
function createCanvasLayers(){
  const mapEl = document.getElementById('map');

  scalarCanvas = document.createElement('canvas');
  scalarCanvas.className = 'ol-canvas';
  scalarCanvas.style.zIndex = 1200;
  mapEl.appendChild(scalarCanvas);

  windBGCanvas = document.createElement('canvas');
  windBGCanvas.className = 'ol-canvas';
  windBGCanvas.style.zIndex = 1300;
  mapEl.appendChild(windBGCanvas);

  windArrowCanvas = document.createElement('canvas');
  windArrowCanvas.className = 'ol-canvas';
  windArrowCanvas.style.zIndex = 1400;
  mapEl.appendChild(windArrowCanvas);

  isobarCanvas = document.createElement('canvas');
  isobarCanvas.className = 'ol-canvas';
  isobarCanvas.style.zIndex = 1600;
  mapEl.appendChild(isobarCanvas);
}

function fitCanvas(c){
  const s = map.getSize();
  c.width = s.x;
  c.height = s.y;
}

/* =============================
   Redraw
============================= */
function redrawAll(){
  if(!currentData?.meta) return;

  fitCanvas(scalarCanvas);
  fitCanvas(windBGCanvas);
  fitCanvas(windArrowCanvas);
  fitCanvas(isobarCanvas);

  drawScalarComposite();
  drawWindBackground();  // pi√π leggero
  drawWindArrows();      // pi√π evidente e scalato davvero
  drawIsobarsAndAB();
}

/* =============================
   Scalar composite
============================= */
function getFieldArray(key){
  if(!currentData) return null;
  if(key==='temp') return currentData.temp;
  if(key==='rain') return currentData.rain;
  if(key==='rh') return currentData.rh;
  if(key==='press') return currentData.press;
  if(key==='cloud') return currentData.cloud ?? currentData.clouds ?? currentData.tcc ?? null;
  return null;
}

function drawScalarComposite(){
  const ctx = scalarCanvas.getContext('2d');
  ctx.clearRect(0,0,scalarCanvas.width, scalarCanvas.height);

  const m = currentData.meta;
  const bounds = map.getBounds();

  const keys = Object.keys(selected).filter(k => selected[k]);
  if(keys.length === 0) return;

  const baseAlpha = (keys.length === 1) ? 0.78 : (keys.length === 2 ? 0.60 : 0.48);
  const order = ['press','temp','rh','rain','cloud'].filter(k => keys.includes(k));

  // Densit√† adattiva (scalar): evita loop enormi a zoom bassi
  const z = map.getZoom();
  const step = (z<=7) ? 3 : (z===8 ? 2 : 1);

  for(const key of order){
    const arr = getFieldArray(key);
    if(!arr || !arr.length) continue;

    for(let y=0; y<m.ny; y+=step){
      const lat = m.la1 - (y*m.dy);
      if(lat < bounds.getSouth()-0.18 || lat > bounds.getNorth()+0.18) continue;

      for(let x=0; x<m.nx; x+=step){
        const lon = m.lo1 + (x*m.dx);
        if(lon < bounds.getWest()-0.18 || lon > bounds.getEast()+0.18) continue;

        const idx = y*m.nx + x;
        let v = arr[idx];

        let col;
        if(key==='temp') col = tempColor(v);
        else if(key==='rain') col = colorFromStops(v, RAIN_STOPS);
        else if(key==='rh') col = colorFromStops(v, RH_STOPS);
        else if(key==='press') col = colorFromStops(v, PRESS_STOPS);
        else if(key==='cloud') col = colorFromStops(v, CLOUD_STOPS);

        if(!col || (col[3] ?? 0) <= 0) continue;

        const a = clamp((col[3] ?? 1) * baseAlpha, 0, 1);

        const p1 = map.latLngToContainerPoint([lat, lon]);
        const p2 = map.latLngToContainerPoint([lat - m.dy*step, lon + m.dx*step]);

        const w = Math.ceil(p2.x - p1.x) + 2;
        const h = Math.ceil(p2.y - p1.y) + 2;

        ctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]},${a})`;
        ctx.fillRect(Math.floor(p1.x)-1, Math.floor(p1.y)-1, w, h);
      }
    }
  }
}

/* =============================
   WIND BACKGROUND (FPS FIX)
   - step pi√π grande (molto meno loop)
   - alpha pi√π bassa (meno invadente)
============================= */
function drawWindBackground(){
  const ctx = windBGCanvas.getContext('2d');
  ctx.clearRect(0,0,windBGCanvas.width, windBGCanvas.height);

  if(!showWindArrows || !currentData?.wind_u?.data || !currentData?.wind_v?.data) return;

  const m = currentData.meta;
  const u = currentData.wind_u.data;
  const v = currentData.wind_v.data;
  const bounds = map.getBounds();

  const z = map.getZoom();

  // sfondo molto pi√π leggero:
  const step = (z<=7) ? 9 : (z===8 ? 8 : (z===9 ? 7 : 6));
  const bgAlphaBase = 0.20;

  for(let yy=0; yy<m.ny; yy+=step){
    const lat = m.la1 - (yy*m.dy);
    if(lat < bounds.getSouth()-0.25 || lat > bounds.getNorth()+0.25) continue;

    for(let xx=0; xx<m.nx; xx+=step){
      const lon = m.lo1 + (xx*m.dx);
      if(lon < bounds.getWest()-0.25 || lon > bounds.getEast()+0.25) continue;

      const idx = yy*m.nx + xx;
      const uu = u[idx], vv = v[idx];
      if(!isFinite(uu) || !isFinite(vv)) continue;

      const spKmh = Math.sqrt(uu*uu + vv*vv) * 3.6;
      const rgb = windRgb(spKmh);

      // alpha cresce un po' con intensit√†
      const a = clamp(bgAlphaBase + (spKmh/80)*0.16, 0.12, 0.42);

      const p1 = map.latLngToContainerPoint([lat, lon]);
      const p2 = map.latLngToContainerPoint([lat - m.dy*step, lon + m.dx*step]);

      const w = Math.ceil(p2.x - p1.x) + 2;
      const h = Math.ceil(p2.y - p1.y) + 2;

      ctx.fillStyle = rgbToCss(rgb, a);
      ctx.fillRect(Math.floor(p1.x)-1, Math.floor(p1.y)-1, w, h);
    }
  }
}

/* =============================
   WIND ARROWS (FIX: grandi + scalati davvero)
   - densit√† maggiore ma controllata
   - size ~ speedKmh con curva pi√π aggressiva
============================= */
function drawWindArrows(){
  const ctx = windArrowCanvas.getContext('2d');
  ctx.clearRect(0,0,windArrowCanvas.width, windArrowCanvas.height);

  if(!showWindArrows || !currentData?.wind_u?.data || !currentData?.wind_v?.data) return;

  const m = currentData.meta;
  const u = currentData.wind_u.data;
  const v = currentData.wind_v.data;
  const bounds = map.getBounds();
  const z = map.getZoom();

  // PI√ô FRECCE ma non assassine per FPS:
  // (a zoom alto puoi andare pi√π denso)
  const step = (z<=7) ? 7 : (z===8 ? 6 : (z===9 ? 5 : 4));

  ctx.lineCap = 'round';
  ctx.globalAlpha = 1.0;

  for(let yy=0; yy<m.ny; yy+=step){
    const lat = m.la1 - (yy*m.dy);
    if(lat < bounds.getSouth()-0.25 || lat > bounds.getNorth()+0.25) continue;

    for(let xx=0; xx<m.nx; xx+=step){
      const lon = m.lo1 + (xx*m.dx);
      if(lon < bounds.getWest()-0.25 || lon > bounds.getEast()+0.25) continue;

      const idx = yy*m.nx + xx;
      const uu = u[idx], vv = v[idx];
      if(!isFinite(uu) || !isFinite(vv)) continue;

      // km/h
      const spKmh = Math.sqrt(uu*uu + vv*vv) * 3.6;

      // direzione su schermo: dx=+u, dy=-v
      let dx = uu, dy = -vv;
      const len = Math.sqrt(dx*dx + dy*dy) || 1;
      dx /= len; dy /= len;

      const p = map.latLngToContainerPoint([lat, lon]);

      // --- SCALATURA AGGRESSIVA (cos√¨ "si vede") ---
      // L cresce parecchio gi√† dai 10-30 km/h
      const L    = clamp(10 + spKmh * 0.75, 12, 85);
      const head = clamp(5  + spKmh * 0.12, 6, 18);
      const lw   = clamp(1.1 + spKmh * 0.035, 1.2, 4.0);

      const x2 = p.x + dx * L;
      const y2 = p.y + dy * L;

      // stesso colore scala vento, ma pi√π acceso
      const baseRgb = windRgb(spKmh);
      const brightRgb = brighten(baseRgb, 1.25);

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.40)";
      ctx.shadowBlur = 3;

      // bordo nero per evidenza
      ctx.lineWidth = lw + 2.0;
      ctx.strokeStyle = "rgba(0,0,0,0.85)";
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      // linea colorata
      ctx.lineWidth = lw;
      ctx.strokeStyle = rgbToCss(brightRgb, 0.98);
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      // punta
      const ang = Math.atan2(y2 - p.y, x2 - p.x);
      const a1 = ang - Math.PI/7;
      const a2 = ang + Math.PI/7;

      // bordo punta nero
      ctx.lineWidth = lw + 2.0;
      ctx.strokeStyle = "rgba(0,0,0,0.85)";
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - head * Math.cos(a1), y2 - head * Math.sin(a1));
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - head * Math.cos(a2), y2 - head * Math.sin(a2));
      ctx.stroke();

      // punta colorata
      ctx.lineWidth = lw;
      ctx.strokeStyle = rgbToCss(brightRgb, 0.98);
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - head * Math.cos(a1), y2 - head * Math.sin(a1));
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - head * Math.cos(a2), y2 - head * Math.sin(a2));
      ctx.stroke();

      ctx.restore();
    }
  }
}

/* =============================
   Particelle (flusso)
============================= */
function updateParticles(){
  if(velocityLayer && !showParticles){
    try{ map.removeLayer(velocityLayer); }catch(e){}
    velocityLayer = null;
    return;
  }
  if(!showParticles) return;
  if(!currentData?.wind_u || !currentData?.wind_v) return;

  if(velocityLayer){
    try{ map.removeLayer(velocityLayer); }catch(e){}
    velocityLayer = null;
  }

  const isMobile = Math.min(window.innerWidth, window.innerHeight) < 900;
  const dpr = window.devicePixelRatio || 1;

  let particleMult = isMobile ? (1/260) : (1/220);
  if(dpr >= 2) particleMult = isMobile ? (1/340) : (1/300);

  try{
    velocityLayer = L.velocityLayer({
      displayValues: false,
      data: [ currentData.wind_u, currentData.wind_v ],

      maxVelocity: 18.0,
      velocityScale: 0.006,
      particleMultiplier: particleMult,
      lineWidth: 1.0,
      particleAge: 120,
      frameRate: 50,
      opacity: 0.85,

      colorScale: ["rgba(255,255,255,0.9)","rgba(255,255,255,0.9)"]
    });
    velocityLayer.addTo(map);
  }catch(e){
    toast("Particelle non avviate (errore leaflet-velocity).");
  }
}

/* =============================
   ISOBARE + A/B (invariato)
============================= */
function gaussianBlur2D(arr, nx, ny) {
  const out = new Array(arr.length).fill(0);
  const k = [1,2,1,2,4,2,1,2,1];
  for (let y=0;y<ny;y++){
    for(let x=0;x<nx;x++){
      let s=0,w=0;
      for(let j=-1;j<=1;j++){
        for(let i=-1;i<=1;i++){
          const xx=x+i, yy=y+j;
          if(xx<0||xx>=nx||yy<0||yy>=ny) continue;
          const kk=k[(j+1)*3+(i+1)];
          const v=arr[yy*nx+xx];
          if(!isFinite(v)) continue;
          s += v*kk; w += kk;
        }
      }
      out[y*nx+x] = (w>0 ? s/w : arr[y*nx+x]);
    }
  }
  return out;
}
function findExtremaCandidates(field, nx, ny){
  const highs=[], lows=[];
  for(let y=1;y<ny-1;y++){
    for(let x=1;x<nx-1;x++){
      const idx=y*nx+x;
      const v=field[idx];
      if(!isFinite(v)) continue;
      let isH=true,isL=true;
      let nMax=-Infinity,nMin=Infinity;

      for(let j=-1;j<=1;j++){
        for(let i=-1;i<=1;i++){
          if(i===0&&j===0) continue;
          const vv=field[(y+j)*nx+(x+i)];
          if(!isFinite(vv)) continue;
          if(vv>v) isH=false;
          if(vv<v) isL=false;
          if(vv>nMax) nMax=vv;
          if(vv<nMin) nMin=vv;
        }
      }
      if(isH) highs.push({x,y,v,score:v-nMin});
      if(isL) lows.push({x,y,v,score:nMax-v});
    }
  }
  return {highs,lows};
}
function suppressNearby(points, minDistCells, keepN){
  const kept=[];
  for(const p of points){
    let ok=true;
    for(const q of kept){
      const dx=p.x-q.x, dy=p.y-q.y;
      if((dx*dx+dy*dy) < (minDistCells*minDistCells)){ ok=false; break; }
    }
    if(ok) kept.push(p);
    if(kept.length>=keepN) break;
  }
  return kept;
}

function drawIsobarsAndAB(){
  const ctx = isobarCanvas.getContext('2d');
  ctx.clearRect(0,0,isobarCanvas.width, isobarCanvas.height);

  if(!showIsobars || !currentData?.press || !currentData?.meta) return;

  const m = currentData.meta;
  const values = currentData.press;

  let minP=Infinity, maxP=-Infinity;
  for(let i=0;i<values.length;i++){
    const v=values[i];
    if(!isFinite(v)) continue;
    if(v<minP) minP=v;
    if(v>maxP) maxP=v;
  }
  if(!isFinite(minP)||!isFinite(maxP)) return;

  const start = Math.floor(minP/2)*2;
  const end   = Math.ceil(maxP/2)*2 + 2;

  const contours = d3.contours()
    .size([m.nx, m.ny])
    .thresholds(d3.range(start, end, 2))(values);

  ctx.save();
  ctx.lineWidth = 1.6;
  ctx.strokeStyle = "rgba(0,0,0,0.70)";
  ctx.font = "900 12px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  contours.forEach(c=>{
    ctx.beginPath();
    const labelCandidates=[];

    c.coordinates.forEach(ring=>{
      ring.forEach(pts=>{
        let first=true;
        const linePts=[];
        pts.forEach(coord=>{
          const lat = m.la1 - (coord[1]*m.dy);
          const lon = m.lo1 + (coord[0]*m.dx);
          const p = map.latLngToContainerPoint([lat, lon]);
          linePts.push(p);
          if(first){ ctx.moveTo(p.x,p.y); first=false; }
          else ctx.lineTo(p.x,p.y);
        });
        if(linePts.length>90) labelCandidates.push(linePts);
      });
    });

    ctx.stroke();

    labelCandidates.forEach(pts=>{
      const mid = pts[Math.floor(pts.length/2)];
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.fillRect(mid.x-20, mid.y-9, 40, 18);
      ctx.fillStyle = "rgba(0,0,0,0.92)";
      ctx.fillText(Math.round(c.value), mid.x, mid.y);
    });
  });

  const smooth = gaussianBlur2D(values, m.nx, m.ny);
  const { highs, lows } = findExtremaCandidates(smooth, m.nx, m.ny);
  highs.sort((a,b)=>b.score-a.score);
  lows.sort((a,b)=>b.score-a.score);

  const z = map.getZoom();
  const minDistCells = (z<=7)? 14 : (z<=8? 12 : (z<=9? 10 : 8));
  const keepN = (z<=7)? 3 : 4;

  const topH = suppressNearby(highs, minDistCells, keepN);
  const topL = suppressNearby(lows,  minDistCells, keepN);

  function drawLetter(letter, p, color){
    const lat = m.la1 - (p.y*m.dy);
    const lon = m.lo1 + (p.x*m.dx);
    const pt = map.latLngToContainerPoint([lat, lon]);

    ctx.save();
    ctx.font = "900 28px Arial";
    ctx.lineWidth = 4.5;
    ctx.strokeStyle = "rgba(0,0,0,0.75)";
    ctx.strokeText(letter, pt.x, pt.y);
    ctx.fillStyle = color;
    ctx.fillText(letter, pt.x, pt.y);

    ctx.font = "900 12px Arial";
    ctx.lineWidth = 3.2;
    ctx.strokeStyle = "rgba(0,0,0,0.65)";
    ctx.strokeText(Math.round(p.v) + " hPa", pt.x, pt.y + 18);
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.fillText(Math.round(p.v) + " hPa", pt.x, pt.y + 18);
    ctx.restore();
  }

  topH.forEach(p => drawLetter("A", p, "rgba(255,40,40,0.96)"));
  topL.forEach(p => drawLetter("B", p, "rgba(60,140,255,0.96)"));

  ctx.restore();
}

/* =============================
   Picker
============================= */
function valueAtLatLng(latlng, key){
  if(!currentData?.meta) return null;
  const m = currentData.meta;

  const y = Math.round((m.la1 - latlng.lat) / m.dy);
  const x = Math.round((latlng.lng - m.lo1) / m.dx);
  if(x<0||x>=m.nx||y<0||y>=m.ny) return null;

  const idx = y*m.nx + x;

  if(key==='wind'){
    const uu = currentData.wind_u?.data?.[idx];
    const vv = currentData.wind_v?.data?.[idx];
    if(!isFinite(uu)||!isFinite(vv)) return null;
    return Math.sqrt(uu*uu+vv*vv)*3.6;
  }
  const arr = getFieldArray(key);
  if(!arr) return null;
  const val = arr[idx];
  if(!isFinite(val)) return null;
  return val;
}

function updatePickerFromEvent(e){
  if(!currentData) return;

  const keys = ['temp','rain','rh','press','cloud'].filter(k => selected[k]);
  const key = keys.length ? keys[keys.length-1] : 'wind';

  const val = valueAtLatLng(e.latlng, key);
  if(val===null || val===undefined) return;

  let out='--';
  if(key==='temp') out = (+val).toFixed(1);
  else if(key==='rain') out = (+val).toFixed(1);
  else if(key==='rh') out = Math.round(val).toString();
  else if(key==='press') out = Math.round(val).toString();
  else if(key==='cloud') out = Math.round(val).toString();
  else out = (+val).toFixed(1);

  document.getElementById('val-display').innerText = out;
  document.getElementById('unit-display').innerText = unitFor(key);
}

/* =============================
   Play
============================= */
function togglePlay(){
  const btn = document.getElementById('play-btn');
  if(isPlaying){
    isPlaying = false;
    btn.innerText = "‚ñ∫";
    return;
  }
  isPlaying = true;
  btn.innerText = "‚ùö‚ùö";

  const s = document.getElementById('time-slider');
  let i = parseInt(s.value,10);
  const max = parseInt(s.max,10);

  const interval = setInterval(()=>{
    if(!isPlaying){
      clearInterval(interval);
      btn.innerText = "‚ñ∫";
      return;
    }
    if(i>=max){
      clearInterval(interval);
      isPlaying=false;
      btn.innerText="‚ñ∫";
      return;
    }
    i++;
    s.value=i;
    loadStep(i);
  }, 800);
}
</script>
</body>
</html>