<!DOCTYPE html>
<html lang="it">
<head>
  <title>Sicilia MeteoHub - PRO (Relief + MultiLayer + A/B)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Particelle (leaflet-velocity) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <!-- Contours -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin:0; background:#111; font-family: "Segoe UI", system-ui, -apple-system, Arial; color:#fff; overflow:hidden; }
    #map { position:absolute; inset:0; background:#111; }

    #info-box{
      position:absolute; top:16px; left:16px; z-index:2000;
      pointer-events:none;
      text-shadow: 0 2px 12px rgba(0,0,0,0.9);
    }
    #val-display{ font-size: 3.0em; font-weight: 900; line-height: 1; }
    #unit-display{ font-size: 1.1em; opacity:0.85; font-weight: 800; }

    #ui-container{
      position:absolute; top:10px; right:10px; z-index:2500;
      display:flex; flex-direction:column; gap:10px; align-items:flex-end;
    }
    .panel{
      background: rgba(0,0,0,0.78);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(8px);
      border-radius: 14px;
      padding: 10px;
      min-width: 180px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }

    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin:6px 0; }
    .row label{ display:flex; align-items:center; gap:10px; font-weight: 800; font-size: 12px; color:#eaeaea; user-select:none; cursor:pointer;}
    .row input[type="checkbox"]{ transform: scale(1.1); }

    .btn{
      width:100%;
      padding:10px 12px;
      border-radius:10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color:#fff;
      font-weight: 900;
      cursor:pointer;
      transition: 0.15s;
    }
    .btn:hover{ background: rgba(255,255,255,0.12); }
    .btn.active{ background:#1d7cff; border-color:#1d7cff; }

    .small{
      font-size: 11px;
      opacity: 0.8;
      line-height: 1.25;
      margin-top: 6px;
    }

    #bottom-bar{
      position:absolute; left:0; right:0; bottom:0;
      height: 90px;
      z-index: 2600;
      display:flex; align-items:center; gap:14px;
      padding: 0 16px;
      background: linear-gradient(to top, rgba(0,0,0,0.92), rgba(0,0,0,0));
    }
    #play-btn{
      width:56px; height:56px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.08);
      color:#fff;
      font-size: 28px;
      cursor:pointer;
    }
    #time-label{
      min-width: 150px;
      text-align:center;
      font-weight: 900;
      text-shadow: 0 2px 10px rgba(0,0,0,0.8);
    }
    input[type="range"]{ flex:1; height: 6px; accent-color:#1d7cff; }

    /* canvases overlay */
    .ol-canvas{
      position:absolute;
      left:0; top:0;
      pointer-events:none;
      image-rendering: auto;
    }

    /* toast error */
    #toast{
      position:absolute; left:16px; bottom:104px; z-index:3000;
      padding:10px 12px;
      border-radius:12px;
      background: rgba(120,0,0,0.55);
      border:1px solid rgba(255,120,120,0.35);
      display:none;
      max-width: 85vw;
      font-weight: 800;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">Caricamento...</div>
  </div>

  <div id="ui-container">
    <div class="panel">
      <button class="btn active" id="btn-base-relief">ESRI RELIEF</button>
      <div class="small">Basemap: Esri World Shaded Relief + nomi citt√† (overlay).</div>
    </div>

    <div class="panel" id="layers-panel">
      <div style="font-weight:900; opacity:.9; margin-bottom:6px;">LIVELLI (multi-selezione)</div>

      <div class="row">
        <label><input type="checkbox" id="chk-temp"> TEMP üå°Ô∏è</label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="chk-rain"> PIOGGIA ‚òî</label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="chk-rh"> UMIDIT√Ä üíß</label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="chk-press"> PRESSIONE ‚è≤Ô∏è</label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="chk-cloud"> NUVOLE ‚òÅÔ∏è</label>
      </div>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:10px 0;">

      <button class="btn active" id="btn-wind-arrows">VENTO (FRECCE) üí®</button>
      <button class="btn" id="btn-particles">PARTICELLE (flusso)</button>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:10px 0;">

      <button class="btn" id="btn-isobars">ISOBARE „Ä∞Ô∏è (con A/B)</button>

      <div class="small">
        Tocca/clicca la mappa per leggere il valore sotto al dito.
      </div>
    </div>
  </div>

  <div id="bottom-bar">
    <button id="play-btn" title="Play/Pausa">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

  <div id="toast"></div>

<script>
/* =============================
   CONFIG MAP (Sicilia bounds)
============================= */
const SICILY_BOUNDS = L.latLngBounds(
  L.latLng(35.0, 11.0),   // SW
  L.latLng(39.5, 16.5)    // NE
);

let map;
let baseRelief, labelsOverlay;
let currentData = null, catalog = [];

let isPlaying = false;
let showIsobars = false;
let showWindArrows = true;
let showParticles = false;

/* canvases */
let scalarCanvas, isobarCanvas, windArrowCanvas;
/* leaflet-velocity layer for particles */
let velocityLayer = null;

/* selected scalar layers (multi) */
const selected = {
  temp:false, rain:false, rh:false, press:false, cloud:false
};

/* =============================
   UI helpers
============================= */
function toast(msg){
  const t = document.getElementById('toast');
  t.innerText = msg;
  t.style.display = 'block';
  clearTimeout(toast._tm);
  toast._tm = setTimeout(()=> t.style.display='none', 3500);
}

function unitFor(key){
  if(key==='wind') return 'km/h';
  if(key==='temp') return '¬∞C';
  if(key==='rain') return 'mm';
  if(key==='rh') return '%';
  if(key==='press') return 'hPa';
  if(key==='cloud') return '%';
  return '';
}

/* =============================
   PALETTES
   - Temp: richiesto dall'utente (stop precisi)
============================= */
function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

const TEMP_STOPS = [
  { v:-15, c:[ 70,  0, 110] },   // viola scuro
  { v:  0, c:[  0, 230, 255] },  // ciano
  { v: 15, c:[255, 255, 170] },  // giallo chiaro
  { v: 20, c:[255, 235,   0] },  // giallo
  { v: 25, c:[255, 170,  70] },  // arancione chiaro
  { v: 30, c:[255, 120,   0] },  // arancione
  { v: 35, c:[255,  40,  40] },  // rosso
  { v: 45, c:[140,   0,   0] }   // rosso scuro
];

// Per gli altri layer: gradiente ‚Äúnetto‚Äù ma leggibile
const RAIN_STOPS = [
  { v:0.0,  c:[0,0,0,0] },
  { v:0.2,  c:[ 80, 200, 255, 0.45] },
  { v:2.0,  c:[  0, 120, 255, 0.60] },
  { v:10.0, c:[  0,  40, 200, 0.72] },
  { v:30.0, c:[150,   0, 200, 0.80] }
];

const RH_STOPS = [
  { v:20, c:[210,160, 60, 0.45] },
  { v:40, c:[220,220,220,0.45] },
  { v:60, c:[ 80,255,130,0.55] },
  { v:80, c:[ 60,160,255,0.62] },
  { v:95, c:[  0, 60,220,0.70] }
];

// (pressione: NON la cambio ‚Äî la mantengo ‚Äúclassica‚Äù)
const PRESS_STOPS = [
  { v:980,  c:[  0, 70, 255, 0.48] },
  { v:995,  c:[  0,170, 255, 0.50] },
  { v:1005, c:[  0,255, 200, 0.52] },
  { v:1013, c:[255,255, 255, 0.52] },
  { v:1022, c:[255,200,   0, 0.55] },
  { v:1035, c:[255, 60,   0, 0.60] }
];

// nuvole: grigio con graduazione, pi√π opache e distinguibili
const CLOUD_STOPS = [
  { v:0,   c:[255,255,255,0.00] },
  { v:20,  c:[235,235,235,0.28] },
  { v:40,  c:[210,210,210,0.38] },
  { v:60,  c:[175,175,175,0.52] },
  { v:80,  c:[120,120,120,0.64] },
  { v:100, c:[ 60, 60, 60,0.74] }
];

function colorFromStops(val, stops){
  if(!stops || stops.length<2) return [0,0,0,0];
  if(val <= stops[0].v){
    const c = stops[0].c.slice(); if(c.length===3) c.push(1);
    return c;
  }
  if(val >= stops[stops.length-1].v){
    const c = stops[stops.length-1].c.slice(); if(c.length===3) c.push(1);
    return c;
  }
  for(let i=0;i<stops.length-1;i++){
    const a = stops[i], b = stops[i+1];
    if(val >= a.v && val <= b.v){
      const t = (val - a.v) / (b.v - a.v);
      const ca = a.c, cb = b.c;
      const out = [
        Math.round(lerp(ca[0], cb[0], t)),
        Math.round(lerp(ca[1], cb[1], t)),
        Math.round(lerp(ca[2], cb[2], t))
      ];
      const aa = (ca.length===4?ca[3]:1), ab = (cb.length===4?cb[3]:1);
      out.push(lerp(aa, ab, t));
      return out;
    }
  }
  return [0,0,0,0];
}

// temperatura: ‚Äú1 grado = 1 colore‚Äù (ma continuo), con stops richiesti e clamp
function tempColor(valC){
  const v = clamp(valC, -15, 45);
  const c = colorFromStops(v, TEMP_STOPS);
  // opacit√† un filo pi√π alta (come richiesto)
  c[3] = clamp(c[3] ?? 1, 0, 1);
  return c;
}

/* =============================
   Wind color scale (come particelle/frecce)
   (colori accesi + opacit√† un po' pi√π alta)
============================= */
const WIND_COLORS = [
  "#001a66", "#0044ff", "#00ddff", "#00ff55", "#ffff00", "#ff6600", "#ff0000", "#ff00ff"
];

function windColor(speedKmh){
  // mappa 0..100 km/h
  const v = clamp(speedKmh, 0, 100);
  const t = v / 100;
  const idx = Math.floor(t * (WIND_COLORS.length-1));
  return WIND_COLORS[idx];
}

/* =============================
   Init
============================= */
window.addEventListener('load', async () => {
  map = L.map('map', {
    zoomControl: false,
    minZoom: 6,
    maxZoom: 12,
    maxBounds: SICILY_BOUNDS.pad(0.25),
    maxBoundsViscosity: 0.85
  }).fitBounds(SICILY_BOUNDS);

  // ESRI World Shaded Relief (quella che hai chiesto)
  baseRelief = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 13, attribution: "Tiles ¬© Esri" }
  ).addTo(map);

  // overlay nomi citt√† (stabile): OSM standard sopra
  labelsOverlay = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    { maxZoom: 19, opacity: 0.45, attribution: "¬© OpenStreetMap" }
  ).addTo(map);

  createCanvasLayers();
  hookUI();

  await loadCatalogAndFirstFrame();

  map.on('mousemove', updatePickerFromEvent);
  map.on('click', updatePickerFromEvent);
  map.on('moveend resize zoomend', () => redrawAll(true));
});

/* =============================
   UI
============================= */
function hookUI(){
  // scalar checkboxes
  const bindChk = (id, key) => {
    document.getElementById(id).addEventListener('change', (e)=>{
      selected[key] = !!e.target.checked;
      redrawAll();
    });
  };
  bindChk('chk-temp', 'temp');
  bindChk('chk-rain', 'rain');
  bindChk('chk-rh', 'rh');
  bindChk('chk-press', 'press');
  bindChk('chk-cloud', 'cloud');

  // wind arrows toggle
  const btnWind = document.getElementById('btn-wind-arrows');
  btnWind.addEventListener('click', ()=>{
    showWindArrows = !showWindArrows;
    btnWind.classList.toggle('active', showWindArrows);
    redrawAll();
  });

  // particles toggle (sempre indipendenti dagli altri layer)
  const btnPart = document.getElementById('btn-particles');
  btnPart.addEventListener('click', ()=>{
    showParticles = !showParticles;
    btnPart.classList.toggle('active', showParticles);
    updateParticles(); // NON dipende dai layer
  });

  // isobars toggle
  const btnIso = document.getElementById('btn-isobars');
  btnIso.addEventListener('click', ()=>{
    showIsobars = !showIsobars;
    btnIso.classList.toggle('active', showIsobars);
    redrawAll();
  });

  // play
  document.getElementById('play-btn').addEventListener('click', togglePlay);
}

/* =============================
   Data load
============================= */
async function loadCatalogAndFirstFrame(){
  try{
    const r = await fetch('data_weather/catalog.json?t=' + Date.now());
    if(!r.ok) throw new Error('catalog not found');
    catalog = await r.json();
    if(!catalog?.length) throw new Error('empty catalog');

    const slider = document.getElementById('time-slider');
    slider.max = catalog.length - 1;
    slider.value = 0;
    slider.addEventListener('input', (e)=> loadStep(parseInt(e.target.value, 10)));

    await loadStep(0);
    document.getElementById('unit-display').innerText = "Pronto";
  }catch(e){
    document.getElementById('unit-display').innerText = "Errore dati";
    toast("Catalog o dati non trovati in data_weather/. Controlla deploy.");
  }
}

async function loadStep(idx){
  if(!catalog[idx]) return;
  document.getElementById('time-label').innerText = catalog[idx].label;

  try{
    const r = await fetch('data_weather/' + catalog[idx].file + '?t=' + Date.now());
    if(!r.ok) throw new Error('frame not found');
    currentData = await r.json();

    redrawAll(true);
    // particelle: devono restare attive anche quando cambi step/layer
    updateParticles();

  }catch(e){
    toast("Frame non caricato (file mancante o JSON invalido).");
  }
}

/* =============================
   Canvas layers
============================= */
function createCanvasLayers(){
  const mapEl = document.getElementById('map');

  scalarCanvas = document.createElement('canvas');
  scalarCanvas.className = 'ol-canvas';
  scalarCanvas.style.zIndex = 1200;
  mapEl.appendChild(scalarCanvas);

  windArrowCanvas = document.createElement('canvas');
  windArrowCanvas.className = 'ol-canvas';
  windArrowCanvas.style.zIndex = 1400;
  mapEl.appendChild(windArrowCanvas);

  isobarCanvas = document.createElement('canvas');
  isobarCanvas.className = 'ol-canvas';
  isobarCanvas.style.zIndex = 1600;
  mapEl.appendChild(isobarCanvas);
}

function fitCanvas(c){
  const s = map.getSize();
  c.width = s.x;
  c.height = s.y;
}

/* =============================
   Redraw
============================= */
function redrawAll(fromMove=false){
  if(!currentData?.meta) return;

  fitCanvas(scalarCanvas);
  fitCanvas(windArrowCanvas);
  fitCanvas(isobarCanvas);

  drawScalarComposite();
  drawWindArrows();
  drawIsobarsAndAB();

  // NOTA: particelle sono gestite separatamente (toggle)
}

/* =============================
   Scalar composite (multi-layer)
   - niente "griglia", niente quadretti evidenti
   - alpha ‚Äúintelligente‚Äù: se attivi molti layer, abbassa un filo per evitare caos
============================= */
function getFieldArray(key){
  if(!currentData) return null;
  if(key==='temp') return currentData.temp;
  if(key==='rain') return currentData.rain;
  if(key==='rh') return currentData.rh;
  if(key==='press') return currentData.press;
  if(key==='cloud') return currentData.cloud ?? currentData.clouds ?? currentData.tcc ?? null;
  return null;
}

function drawScalarComposite(){
  const ctx = scalarCanvas.getContext('2d');
  ctx.clearRect(0,0,scalarCanvas.width, scalarCanvas.height);

  const m = currentData.meta;
  const bounds = map.getBounds();

  const keys = Object.keys(selected).filter(k => selected[k]);
  if(keys.length === 0) return;

  // alpha base per layer: pi√π layer => meno opacit√† per non ‚Äúimpastare‚Äù
  const baseAlpha = (keys.length === 1) ? 0.70 : (keys.length === 2 ? 0.55 : 0.42);

  // ordine consigliato (sotto->sopra): press, temp, rh, rain, cloud
  const order = ['press','temp','rh','rain','cloud'].filter(k => keys.includes(k));

  // anti-quadretti: disegno su griglia ma con leggero overlap, e NO stroke
  for(const key of order){
    const arr = getFieldArray(key);
    if(!arr || !arr.length) continue;

    ctx.globalAlpha = 1.0;

    for(let y=0; y<m.ny; y++){
      const lat = m.la1 - (y*m.dy);
      if(lat < bounds.getSouth()-0.15 || lat > bounds.getNorth()+0.15) continue;

      for(let x=0; x<m.nx; x++){
        const lon = m.lo1 + (x*m.dx);
        if(lon < bounds.getWest()-0.15 || lon > bounds.getEast()+0.15) continue;

        const idx = y*m.nx + x;
        let v = arr[idx];

        let col;
        if(key==='temp') col = tempColor(v);
        else if(key==='rain') col = colorFromStops(v, RAIN_STOPS);
        else if(key==='rh') col = colorFromStops(v, RH_STOPS);
        else if(key==='press') col = colorFromStops(v, PRESS_STOPS);
        else if(key==='cloud') col = colorFromStops(v, CLOUD_STOPS);

        if(!col || (col[3] ?? 0) <= 0) continue;

        // opacit√† finale: baseAlpha * alpha palette
        const a = clamp((col[3] ?? 1) * baseAlpha, 0, 1);

        const p1 = map.latLngToContainerPoint([lat, lon]);
        const p2 = map.latLngToContainerPoint([lat - m.dy, lon + m.dx]);

        // overlap lieve per evitare "fessure"
        const w = Math.ceil(p2.x - p1.x) + 2;
        const h = Math.ceil(p2.y - p1.y) + 2;

        ctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]},${a})`;
        ctx.fillRect(Math.floor(p1.x)-1, Math.floor(p1.y)-1, w, h);
      }
    }
  }

  ctx.globalAlpha = 1.0;
}

/* =============================
   Wind arrows (frecce)
   - pi√π sottili, pi√π numerose, colori pi√π accesi (stessi colori)
   - direzione: usa u/v correttamente
============================= */
function drawWindArrows(){
  const ctx = windArrowCanvas.getContext('2d');
  ctx.clearRect(0,0,windArrowCanvas.width, windArrowCanvas.height);

  if(!showWindArrows || !currentData?.wind_u?.data || !currentData?.wind_v?.data) return;

  const m = currentData.meta;
  const u = currentData.wind_u.data;
  const v = currentData.wind_v.data;
  const bounds = map.getBounds();
  const z = map.getZoom();

  // densit√†: pi√π zoom => pi√π frecce
  const step = (z <= 7) ? 8 : (z === 8 ? 7 : (z === 9 ? 6 : 5));

  // stile frecce: sottili ma evidenti
  ctx.lineWidth = 1.15;
  ctx.lineCap = 'round';
  ctx.globalAlpha = 0.95;   // opacit√† un po' pi√π alta (come richiesto)

  for(let yy=0; yy<m.ny; yy+=step){
    const lat = m.la1 - (yy*m.dy);
    if(lat < bounds.getSouth()-0.2 || lat > bounds.getNorth()+0.2) continue;

    for(let xx=0; xx<m.nx; xx+=step){
      const lon = m.lo1 + (xx*m.dx);
      if(lon < bounds.getWest()-0.2 || lon > bounds.getEast()+0.2) continue;

      const idx = yy*m.nx + xx;
      const uu = u[idx];
      const vv = v[idx];
      if(!isFinite(uu) || !isFinite(vv)) continue;

      // intensit√† (m/s) -> km/h
      const spKmh = Math.sqrt(uu*uu + vv*vv) * 3.6;

      // punto su schermo
      const p = map.latLngToContainerPoint([lat, lon]);

      // direzione: vettore (u verso est, v verso nord). Sul canvas y cresce verso il basso:
      // quindi dy schermo = -vv, dx schermo = uu
      let dx = uu, dy = -vv;

      // normalizza
      const len = Math.sqrt(dx*dx + dy*dy) || 1;
      dx /= len; dy /= len;

      // lunghezza freccia proporzionale alla velocit√† (limite)
      const L = clamp(6 + spKmh * 0.18, 8, 26);

      const x2 = p.x + dx * L;
      const y2 = p.y + dy * L;

      // colore dalla scala vento (come particelle)
      ctx.strokeStyle = windColor(spKmh);

      // ombra per leggibilit√† sul relief
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 2.5;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // corpo
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      // punta
      const head = 4.5;
      const ang = Math.atan2(y2 - p.y, x2 - p.x);
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - head * Math.cos(ang - Math.PI/6), y2 - head * Math.sin(ang - Math.PI/6));
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - head * Math.cos(ang + Math.PI/6), y2 - head * Math.sin(ang + Math.PI/6));
      ctx.stroke();

      ctx.restore();
    }
  }

  ctx.globalAlpha = 1.0;
}

/* =============================
   Particelle (flusso) - SEMPRE indipendenti dai layer
   - bianche, visibili, ma non ‚Äúpesanti‚Äù
============================= */
function updateParticles(){
  // se layer esiste ma toggle off -> rimuovi
  if(velocityLayer && !showParticles){
    try{ map.removeLayer(velocityLayer); }catch(e){}
    velocityLayer = null;
    return;
  }

  if(!showParticles) return;
  if(!currentData?.wind_u || !currentData?.wind_v) return;

  // se gi√† attive, ricrea solo quando cambia step (qui ricreiamo sempre: semplice e stabile)
  if(velocityLayer){
    try{ map.removeLayer(velocityLayer); }catch(e){}
    velocityLayer = null;
  }

  const isMobile = Math.min(window.innerWidth, window.innerHeight) < 900;
  const dpr = window.devicePixelRatio || 1;

  // FPS: particelle ridotte (stabili)
  let particleMult = isMobile ? (1/220) : (1/180);
  if(dpr >= 2) particleMult = isMobile ? (1/280) : (1/240);

  try{
    velocityLayer = L.velocityLayer({
      displayValues: false,
      data: [ currentData.wind_u, currentData.wind_v ],

      maxVelocity: 18.0,
      velocityScale: 0.006,
      particleMultiplier: particleMult,
      lineWidth: 1.0,
      particleAge: 120,
      frameRate: 50,
      opacity: 0.85,

      // particelle bianche (visibili). ‚Äúcolore unico‚Äù per restare pulito sopra altri layer
      colorScale: ["rgba(255,255,255,0.9)","rgba(255,255,255,0.9)"]
    });

    velocityLayer.addTo(map);
  }catch(e){
    toast("Particelle non avviate (errore leaflet-velocity).");
  }
}

/* =============================
   ISOBARE + Etichette + A/B
============================= */
function gaussianBlur2D(arr, nx, ny) {
  const out = new Array(arr.length).fill(0);
  const k = [1,2,1,2,4,2,1,2,1];
  for (let y=0;y<ny;y++){
    for(let x=0;x<nx;x++){
      let s=0,w=0;
      for(let j=-1;j<=1;j++){
        for(let i=-1;i<=1;i++){
          const xx=x+i, yy=y+j;
          if(xx<0||xx>=nx||yy<0||yy>=ny) continue;
          const kk=k[(j+1)*3+(i+1)];
          const v=arr[yy*nx+xx];
          if(!isFinite(v)) continue;
          s += v*kk; w += kk;
        }
      }
      out[y*nx+x] = (w>0 ? s/w : arr[y*nx+x]);
    }
  }
  return out;
}
function findExtremaCandidates(field, nx, ny){
  const highs=[], lows=[];
  for(let y=1;y<ny-1;y++){
    for(let x=1;x<nx-1;x++){
      const idx=y*nx+x;
      const v=field[idx];
      if(!isFinite(v)) continue;
      let isH=true,isL=true;
      let nMax=-Infinity,nMin=Infinity;

      for(let j=-1;j<=1;j++){
        for(let i=-1;i<=1;i++){
          if(i===0&&j===0) continue;
          const vv=field[(y+j)*nx+(x+i)];
          if(!isFinite(vv)) continue;
          if(vv>v) isH=false;
          if(vv<v) isL=false;
          if(vv>nMax) nMax=vv;
          if(vv<nMin) nMin=vv;
        }
      }
      if(isH) highs.push({x,y,v,score:v-nMin});
      if(isL) lows.push({x,y,v,score:nMax-v});
    }
  }
  return {highs,lows};
}
function suppressNearby(points, minDistCells, keepN){
  const kept=[];
  for(const p of points){
    let ok=true;
    for(const q of kept){
      const dx=p.x-q.x, dy=p.y-q.y;
      if((dx*dx+dy*dy) < (minDistCells*minDistCells)){ ok=false; break; }
    }
    if(ok) kept.push(p);
    if(kept.length>=keepN) break;
  }
  return kept;
}

function drawIsobarsAndAB(){
  const ctx = isobarCanvas.getContext('2d');
  ctx.clearRect(0,0,isobarCanvas.width, isobarCanvas.height);

  if(!showIsobars || !currentData?.press || !currentData?.meta) return;

  const m = currentData.meta;
  const values = currentData.press;

  // min/max dinamico
  let minP=Infinity, maxP=-Infinity;
  for(let i=0;i<values.length;i++){
    const v=values[i];
    if(!isFinite(v)) continue;
    if(v<minP) minP=v;
    if(v>maxP) maxP=v;
  }
  if(!isFinite(minP)||!isFinite(maxP)) return;

  const start = Math.floor(minP/2)*2;
  const end   = Math.ceil(maxP/2)*2 + 2;

  const contours = d3.contours()
    .size([m.nx, m.ny])
    .thresholds(d3.range(start, end, 2))(values);

  // linee + etichette valori
  ctx.save();
  ctx.lineWidth = 1.6;
  ctx.strokeStyle = "rgba(0,0,0,0.70)";
  ctx.font = "900 12px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  contours.forEach(c=>{
    ctx.beginPath();
    const labelCandidates=[];

    c.coordinates.forEach(ring=>{
      ring.forEach(pts=>{
        let first=true;
        const linePts=[];
        pts.forEach(coord=>{
          const lat = m.la1 - (coord[1]*m.dy);
          const lon = m.lo1 + (coord[0]*m.dx);
          const p = map.latLngToContainerPoint([lat, lon]);
          linePts.push(p);
          if(first){ ctx.moveTo(p.x,p.y); first=false; }
          else ctx.lineTo(p.x,p.y);
        });
        if(linePts.length>90) labelCandidates.push(linePts);
      });
    });

    ctx.stroke();

    // etichetta pressione per quella linea
    labelCandidates.forEach(pts=>{
      const mid = pts[Math.floor(pts.length/2)];
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.fillRect(mid.x-20, mid.y-9, 40, 18);
      ctx.fillStyle = "rgba(0,0,0,0.92)";
      ctx.fillText(Math.round(c.value), mid.x, mid.y);
    });
  });

  // A/B su massimi/minimi
  const smooth = gaussianBlur2D(values, m.nx, m.ny);
  const { highs, lows } = findExtremaCandidates(smooth, m.nx, m.ny);
  highs.sort((a,b)=>b.score-a.score);
  lows.sort((a,b)=>b.score-a.score);

  const z = map.getZoom();
  const minDistCells = (z<=7)? 14 : (z<=8? 12 : (z<=9? 10 : 8));
  const keepN = (z<=7)? 3 : 4;

  const topH = suppressNearby(highs, minDistCells, keepN);
  const topL = suppressNearby(lows,  minDistCells, keepN);

  function drawLetter(letter, p, color){
    const lat = m.la1 - (p.y*m.dy);
    const lon = m.lo1 + (p.x*m.dx);
    const pt = map.latLngToContainerPoint([lat, lon]);

    ctx.save();
    ctx.font = "900 28px Arial";
    ctx.lineWidth = 4.5;
    ctx.strokeStyle = "rgba(0,0,0,0.75)";
    ctx.strokeText(letter, pt.x, pt.y);
    ctx.fillStyle = color;
    ctx.fillText(letter, pt.x, pt.y);

    ctx.font = "900 12px Arial";
    ctx.lineWidth = 3.2;
    ctx.strokeStyle = "rgba(0,0,0,0.65)";
    ctx.strokeText(Math.round(p.v) + " hPa", pt.x, pt.y + 18);
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.fillText(Math.round(p.v) + " hPa", pt.x, pt.y + 18);
    ctx.restore();
  }

  // A rosso, B blu
  topH.forEach(p => drawLetter("A", p, "rgba(255,40,40,0.96)"));
  topL.forEach(p => drawLetter("B", p, "rgba(60,140,255,0.96)"));

  ctx.restore();
}

/* =============================
   Picker valore su mappa
   - mostra l'ultimo layer "attivo" (priorit√†: temp/rain/rh/press/cloud, altrimenti vento)
============================= */
function valueAtLatLng(latlng, key){
  if(!currentData?.meta) return null;
  const m = currentData.meta;

  const y = Math.round((m.la1 - latlng.lat) / m.dy);
  const x = Math.round((latlng.lng - m.lo1) / m.dx);
  if(x<0||x>=m.nx||y<0||y>=m.ny) return null;

  const idx = y*m.nx + x;

  if(key==='wind'){
    const u = currentData.wind_u?.data?.[idx];
    const v = currentData.wind_v?.data?.[idx];
    if(!isFinite(u)||!isFinite(v)) return null;
    return Math.sqrt(u*u+v*v)*3.6;
  }
  const arr = getFieldArray(key);
  if(!arr) return null;
  const val = arr[idx];
  if(!isFinite(val)) return null;
  return val;
}

function updatePickerFromEvent(e){
  if(!currentData) return;

  // priorit√†: se hai selezionato pi√π layer, prendi l'ultimo nell'ordine ‚Äúvisuale‚Äù
  const keys = ['temp','rain','rh','press','cloud'].filter(k => selected[k]);
  let key = keys.length ? keys[keys.length-1] : 'wind';

  const val = valueAtLatLng(e.latlng, key);
  if(val===null || val===undefined) return;

  let out='--';
  if(key==='temp') out = (+val).toFixed(1);
  else if(key==='rain') out = (+val).toFixed(1);
  else if(key==='rh') out = Math.round(val).toString();
  else if(key==='press') out = Math.round(val).toString();
  else if(key==='cloud') out = Math.round(val).toString();
  else out = (+val).toFixed(1);

  document.getElementById('val-display').innerText = out;
  document.getElementById('unit-display').innerText = unitFor(key);
}

/* =============================
   Play
============================= */
function togglePlay(){
  const btn = document.getElementById('play-btn');
  if(isPlaying){
    isPlaying = false;
    btn.innerText = "‚ñ∫";
    return;
  }
  isPlaying = true;
  btn.innerText = "‚ùö‚ùö";

  const s = document.getElementById('time-slider');
  let i = parseInt(s.value,10);
  const max = parseInt(s.max,10);

  const interval = setInterval(()=>{
    if(!isPlaying){
      clearInterval(interval);
      btn.innerText = "‚ñ∫";
      return;
    }
    if(i>=max){
      clearInterval(interval);
      isPlaying=false;
      btn.innerText="‚ñ∫";
      return;
    }
    i++;
    s.value=i;
    loadStep(i);
  }, 800);
}
</script>
</body>
</html>
```Ó®Å0Ó®Ç