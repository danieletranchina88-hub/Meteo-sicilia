<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - PRO (HD MultiLayer)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin: 0; background: #111; font-family: 'Segoe UI', sans-serif; color: white; overflow: hidden; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #111; }

    /* UI */
    #ui-container { position: absolute; top: 10px; right: 10px; z-index: 1000; display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
    .panel { background: rgba(0,0,0,0.82); backdrop-filter: blur(8px); padding: 10px; border-radius: 14px; border: 1px solid rgba(255,255,255,0.15); box-shadow: 0 10px 25px rgba(0,0,0,0.45); }

    .layer-btn{
      display:block; width: 150px; padding: 10px 12px; margin-bottom: 6px;
      background: transparent; color: #d0d0d0; border: none; text-align: right;
      cursor:pointer; font-size: 13px; font-weight: 800; border-radius: 10px;
      transition: all .15s;
    }
    .layer-btn:hover{ background: rgba(255,255,255,0.08); color: #fff; }
    .layer-btn.active{ background: linear-gradient(90deg, #007bff, #0040aa); color:#fff; border:1px solid rgba(120,180,255,0.45); box-shadow: 0 0 16px rgba(0,120,255,0.35); }

    .layer-btn.small { font-weight: 800; opacity: 0.9; }
    .layer-btn.toggle { color:#bdbdbd; }
    .layer-btn.toggle.active{ background: rgba(255,255,255,0.16); border:1px solid rgba(255,255,255,0.22); box-shadow:none; }

    .map-toggle{
      padding: 8px 12px; background: rgba(255,255,255,0.08); color:#fff;
      border: 1px solid rgba(255,255,255,0.22); border-radius: 10px;
      cursor:pointer; font-size: 12px; font-weight: 900; transition: all .15s;
    }
    .map-toggle:hover{ background: rgba(255,255,255,0.14); }
    .map-toggle.active{ background:#eee; color:#000; }

    /* Info */
    #info-box{ position:absolute; top: 16px; left: 16px; z-index:1000; pointer-events:none; text-shadow: 0 2px 10px rgba(0,0,0,0.95); }
    #val-display{ font-size: 3.2em; font-weight: 1000; line-height: 0.95; }
    #unit-display{ font-size: 1.05em; color:#cfcfcf; font-weight: 900; }

    /* Bottom bar */
    #bottom-bar{
      position:absolute; bottom:0; left:0; right:0; height: 92px;
      background: linear-gradient(to top, rgba(0,0,0,0.92), transparent);
      display:flex; align-items:center; padding: 0 18px; z-index:2000;
    }
    #play-btn{ font-size: 2.4em; background:none; border:none; color:#fff; cursor:pointer; margin-right: 14px; }
    #time-label{ font-size: 1.25em; font-weight: 1000; margin-left: 12px; min-width: 140px; text-align:center; text-shadow: 0 2px 10px rgba(0,0,0,0.95); }
    input[type=range]{ flex-grow:1; height: 5px; cursor:pointer; accent-color:#0088ff; }

    /* Hillshade blend: diverso per dark/sat */
    .hillshade-tiles { opacity: 0.70; }
    body.mode-dark .hillshade-tiles { mix-blend-mode: multiply; filter: contrast(1.6) brightness(0.9); }
    body.mode-sat  .hillshade-tiles { mix-blend-mode: overlay;   filter: contrast(1.35) brightness(1.05); }

    /* Canvas smoothing (HD) */
    canvas.leaflet-layer { image-rendering: auto; }
  </style>
</head>

<body class="mode-dark">
  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">Caricamento...</div>
  </div>

  <div id="ui-container">
    <div class="panel" style="display:flex; gap:6px;">
      <button class="map-toggle active" onclick="setBase('dark')">DARK</button>
      <button class="map-toggle" onclick="setBase('sat')">SAT</button>
    </div>

    <div class="panel">
      <!-- Multi-layer: questi sono toggle -->
      <button class="layer-btn active" onclick="toggleLayer('wind')">VENTO üí®</button>
      <button class="layer-btn" onclick="toggleLayer('temp')">TEMP üå°Ô∏è</button>
      <button class="layer-btn" onclick="toggleLayer('rain')">PIOGGIA ‚òî</button>
      <button class="layer-btn" onclick="toggleLayer('rh')">UMIDIT√Ä üíß</button>
      <button class="layer-btn" onclick="toggleLayer('press')">PRESSIONE ‚è≤Ô∏è</button>
      <button class="layer-btn" onclick="toggleLayer('clouds')">NUVOLE ‚òÅÔ∏è</button>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:8px 0;">
      <button class="layer-btn toggle" id="btn-iso" onclick="toggleIso()">ISOBARE „Ä∞Ô∏è</button>
      <button class="layer-btn toggle" id="btn-grid" onclick="toggleGrid()">GRIGLIA #</button>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  // =========================
  // GLOBALS
  // =========================
  let map, velocityLayer;
  let isoCanvas, gridCanvas;

  // uno ‚Äúscalar canvas‚Äù per ogni layer: temp/rain/rh/press/clouds (per gestire opacit√† separata)
  const scalarCanvases = {};
  const scalarOffscreen = {}; // cache per frame: {layer:{c,ctx,imgData,lastKey}}
  let currentData = null, catalog = [];

  let showIso = false, showGrid = false, isPlaying = false;

  let baseLayers = {}, labelsLayers = {}, hillshadeLayer = null;
  let baseMode = 'dark'; // 'dark' | 'sat'

  // Multi-layer state
  const enabled = {
    wind: true,
    temp: false,
    rain: false,
    rh: false,
    press: false,
    clouds: false
  };

  // =========================
  // PALETTES (continuous)
  // =========================

  // Temperature: -15..45 (stops ‚Äútipo app‚Äù: viola‚Üíblu‚Üíciano‚Üíverde‚Üígiallo‚Üíarancio‚Üírosso‚Üírosso scuro)
  const TEMP_STOPS = [
    {v:-15, c:[120,  0,255]}, // viola
    {v:-10, c:[ 70,  0,255]},
    {v: -5, c:[  0, 80,255]}, // blu
    {v:  0, c:[  0,170,255]}, // azzurro
    {v:  5, c:[  0,255,255]}, // ciano
    {v: 10, c:[  0,255,140]}, // verde acqua
    {v: 15, c:[  0,220,  0]}, // verde
    {v: 20, c:[170,255,  0]}, // giallo-verde
    {v: 25, c:[255,255,  0]}, // giallo
    {v: 30, c:[255,170,  0]}, // arancio
    {v: 35, c:[255, 80,  0]}, // rosso-arancio
    {v: 40, c:[255,  0,  0]}, // rosso
    {v: 45, c:[150,  0,  0]}  // rosso scuro
  ];

  // Pressione (hPa): 980..1040 (bassa blu/viola ‚Üí alta arancio/rosso)
  const PRESS_STOPS = [
    {v: 980, c:[ 90,  0,180]},
    {v: 990, c:[  0, 70,255]},
    {v:1000, c:[  0,170,255]},
    {v:1010, c:[  0,255,200]},
    {v:1013, c:[255,255,255]}, // neutro
    {v:1020, c:[255,220,  0]},
    {v:1030, c:[255,120,  0]},
    {v:1040, c:[220,  0,  0]}
  ];

  // RH (%): secco‚Üíumido (marrone‚Üígrigio‚Üíverde‚Üíblu)
  const RH_STOPS = [
    {v:  0, c:[200,140, 40]},
    {v: 30, c:[200,200,200]},
    {v: 60, c:[ 80,255, 80]},
    {v: 80, c:[ 80,170,255]},
    {v:100, c:[  0, 60,200]}
  ];

  // Pioggia (mm): leggero‚Üíforte (ciano‚Üíblu‚Üíviola)
  const RAIN_STOPS = [
    {v: 0.0, c:[  0,  0,  0]}, // trasparente gestita a parte
    {v: 0.2, c:[  0,200,255]},
    {v: 2.0, c:[  0, 80,255]},
    {v:10.0, c:[140,  0,200]},
    {v:30.0, c:[255,  0,255]}
  ];

  // Nuvole (0..100): bianco -> grigio scuro (come volevi)
  const CLOUD_STOPS = [
    {v:  0, c:[255,255,255]},
    {v: 60, c:[150,150,150]},
    {v:100, c:[ 60, 60, 60]}
  ];

  function lerp(a,b,t){ return a + (b-a)*t; }

  function colorFromStops(val, stops){
    if(val <= stops[0].v) return stops[0].c;
    if(val >= stops[stops.length-1].v) return stops[stops.length-1].c;

    for(let i=0;i<stops.length-1;i++){
      const a = stops[i], b = stops[i+1];
      if(val >= a.v && val <= b.v){
        const t = (val-a.v)/(b.v-a.v);
        return [
          Math.round(lerp(a.c[0], b.c[0], t)),
          Math.round(lerp(a.c[1], b.c[1], t)),
          Math.round(lerp(a.c[2], b.c[2], t))
        ];
      }
    }
    return stops[stops.length-1].c;
  }

  function unitFor(layer){
    if(layer==='wind') return 'km/h';
    if(layer==='temp') return '¬∞C';
    if(layer==='rain') return 'mm';
    if(layer==='rh') return '%';
    if(layer==='press') return 'hPa';
    if(layer==='clouds') return '%';
    return '';
  }

  // =========================
  // INIT MAP
  // =========================
  window.addEventListener('load', async () => {
    map = L.map('map', { zoomControl:false }).setView([37.5, 14.2], 8);

    // DARK
    baseLayers.dark = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, attribution:'¬©OpenStreetMap, ¬©CARTO' }
    ).addTo(map);

    // SATELLITE
    baseLayers.sat = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution:'Tiles ¬© Esri' }
    );

    // Labels: dark + light labels (per satellite)
    labelsLayers.dark = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, opacity: 0.95, attribution:'¬©CARTO' }
    ).addTo(map);

    labelsLayers.sat = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, opacity: 0.90, attribution:'¬©CARTO' }
    );

    // Hillshade overlay (rilievi)
    hillshadeLayer = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, className: 'hillshade-tiles', attribution:'Hillshade ¬© Esri' }
    ).addTo(map);

    createCanvasLayers();
    await loadCatalog();

    // Picker: mousemove + click
    map.on('mousemove', updatePickerFromEvent);
    map.on('click', updatePickerFromEvent);

    document.getElementById('unit-display').innerText = "Pronto";
  });

  function createCanvasLayers(){
    const mkCanvas = (z) => {
      const c = L.DomUtil.create('canvas', 'leaflet-layer');
      c.style.pointerEvents = 'none';
      c.style.zIndex = z;
      map.getPanes().overlayPane.appendChild(c);
      return c;
    };

    // canvas scalari separati (cos√¨ gestisci alpha e overlay in modo pulito)
    scalarCanvases.temp   = mkCanvas(300);
    scalarCanvases.rain   = mkCanvas(310);
    scalarCanvases.rh     = mkCanvas(320);
    scalarCanvases.press  = mkCanvas(330);
    scalarCanvases.clouds = mkCanvas(340);

    isoCanvas  = mkCanvas(420);
    gridCanvas = mkCanvas(450);

    map.on('moveend resize', redrawAll);
  }

  // =========================
  // BASE SWITCH
  // =========================
  window.setBase = function(type){
    document.querySelectorAll('.map-toggle').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');

    baseMode = type;
    document.body.classList.toggle('mode-dark', type==='dark');
    document.body.classList.toggle('mode-sat', type==='sat');

    // swap base
    if(type==='dark'){
      map.removeLayer(baseLayers.sat);
      baseLayers.dark.addTo(map);

      map.removeLayer(labelsLayers.sat);
      labelsLayers.dark.addTo(map);

      if(hillshadeLayer) hillshadeLayer.addTo(map);
    } else {
      map.removeLayer(baseLayers.dark);
      baseLayers.sat.addTo(map);

      map.removeLayer(labelsLayers.dark);
      labelsLayers.sat.addTo(map);

      if(hillshadeLayer) hillshadeLayer.addTo(map);
    }

    redrawAll();
    updateWind(); // perch√© cambiano colori/contrasto
  }

  // =========================
  // DATA LOADING
  // =========================
  async function loadCatalog(){
    try{
      const r = await fetch('data_weather/catalog.json?t=' + Date.now());
      if(!r.ok) throw new Error('catalog missing');
      catalog = await r.json();
      if(!catalog || !catalog.length) throw new Error('empty catalog');

      const s = document.getElementById('time-slider');
      s.max = catalog.length-1;
      s.value = 0;
      s.addEventListener('input', e => loadStep(parseInt(e.target.value,10)));

      await loadStep(0);
    } catch(e){
      document.getElementById('unit-display').innerText = "Errore dati";
    }
  }

  async function loadStep(idx){
    if(!catalog[idx]) return;
    document.getElementById('time-label').innerText = catalog[idx].label;

    try{
      const r = await fetch('data_weather/' + catalog[idx].file + '?t=' + Date.now());
      if(!r.ok) throw new Error('frame missing');
      currentData = await r.json();

      // reset cache offscreen per frame
      for(const k of Object.keys(scalarOffscreen)) delete scalarOffscreen[k];

      redrawAll();
    }catch(e){}
  }

  // =========================
  // MULTI-LAYER TOGGLE
  // =========================
  window.toggleLayer = function(layer){
    enabled[layer] = !enabled[layer];
    event.target.classList.toggle('active', enabled[layer]);

    // unit display: se clicchi un layer, mostra la sua unit√† per picker
    document.getElementById('unit-display').innerText = unitFor(layer);
    document.getElementById('val-display').innerText = '--';

    redrawAll();
  }

  window.toggleIso = function(){
    showIso = !showIso;
    document.getElementById('btn-iso').classList.toggle('active', showIso);
    redrawAll();
  }

  window.toggleGrid = function(){
    showGrid = !showGrid;
    document.getElementById('btn-grid').classList.toggle('active', showGrid);
    redrawAll();
  }

  // =========================
  // SMART OPACITY
  // =========================
  function computeAlphas(){
    const scalars = ['temp','press','rain','rh','clouds'].filter(k => enabled[k]);
    const n = scalars.length;

    // Base alpha (pi√π trasparente su sat perch√© gi√† ‚Äúricca‚Äù)
    const base = (baseMode==='sat') ? 0.55 : 0.50;

    // Se pi√π layer, abbasso un po' ognuno per leggibilit√†
    const each = n ? Math.min(0.72, base + 0.10) / Math.sqrt(n) : 0;

    const out = {};
    for(const k of scalars){
      out[k] = each;
    }

    // Nuvole sempre pi√π leggere (se attive), per non ‚Äúuccidere‚Äù tutto
    if(out.clouds !== undefined){
      out.clouds = Math.min(out.clouds, 0.33);
    }

    // Pioggia un filo pi√π ‚Äúdecisa‚Äù
    if(out.rain !== undefined){
      out.rain = Math.min(0.55, out.rain + 0.10);
    }

    // Temperatura leggermente pi√π presente (come mi hai chiesto)
    if(out.temp !== undefined){
      out.temp = Math.min(0.62, out.temp + 0.10);
    }

    return out;
  }

  // =========================
  // RENDER: SCALARS (HD smooth)
  // =========================
  function redrawAll(){
    if(!currentData || !currentData.meta) return;

    drawScalarsHD();
    drawIsobars();
    drawGrid();
    updateWind();
  }

  function drawScalarsHD(){
    const m = currentData.meta;
    const bounds = dataBounds(m);

    const nw = map.latLngToContainerPoint(bounds.nw);
    const se = map.latLngToContainerPoint(bounds.se);

    const w = se.x - nw.x;
    const h = se.y - nw.y;

    const alphas = computeAlphas();

    // per ogni layer scalare
    for(const layer of ['temp','press','rain','rh','clouds']){
      const canvas = scalarCanvases[layer];
      const ctx = canvas.getContext('2d');

      const size = map.getSize();
      canvas.width = size.x; canvas.height = size.y;
      L.DomUtil.setPosition(canvas, map.containerPointToLayerPoint([0,0]));
      ctx.clearRect(0,0,size.x,size.y);

      if(!enabled[layer]) continue;

      // genera offscreen (nx x ny) una volta per frame
      const off = getOrBuildOffscreen(layer, m);
      if(!off) continue;

      ctx.save();
      ctx.globalAlpha = alphas[layer] ?? 0.5;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(off.c, nw.x, nw.y, w, h);
      ctx.restore();
    }
  }

  function dataBounds(meta){
    // la1 (north), lo1 (west), la2 (south), lo2 (east) gi√† in meta
    return {
      nw: L.latLng(meta.la1, meta.lo1),
      se: L.latLng(meta.la2, meta.lo2)
    };
  }

  function getOrBuildOffscreen(layer, meta){
    if(!currentData) return null;

    // chiave cache: layer + refTime (se presente)
    const key = layer + '|' + (meta.refTime || '');

    if(scalarOffscreen[layer] && scalarOffscreen[layer].key === key){
      return scalarOffscreen[layer];
    }

    const nx = meta.nx, ny = meta.ny;

    // crea canvas offscreen nx√óny
    const c = document.createElement('canvas');
    c.width = nx; c.height = ny;
    const ctx = c.getContext('2d', { willReadFrequently: false });

    const img = ctx.createImageData(nx, ny);
    const data = img.data; // Uint8ClampedArray

    // prendi array
    let arr = null;

    if(layer === 'temp') arr = currentData.temp;
    else if(layer === 'press') arr = currentData.press;
    else if(layer === 'rain') arr = currentData.rain;
    else if(layer === 'rh') arr = currentData.rh;
    else if(layer === 'clouds'){
      // >>> QUI: se il tuo JSON usa un nome diverso, cambia solo questa riga <<<
      arr = currentData.clouds; // 0..100
      if(!arr) arr = currentData.cloud; // fallback
    }

    if(!arr || arr.length !== nx*ny){
      // se manca, non disegnare
      scalarOffscreen[layer] = { c, ctx, img, key, missing:true };
      return null;
    }

    // palette e gestione trasparenza per layer
    for(let i=0;i<nx*ny;i++){
      let v = arr[i];
      let rgb = [0,0,0];
      let a = 255;

      if(layer === 'temp'){
        // clamp -15..45
        if(v < -15) v = -15;
        if(v > 45)  v = 45;
        rgb = colorFromStops(v, TEMP_STOPS);
        a = 255;
      }
      else if(layer === 'press'){
        rgb = colorFromStops(v, PRESS_STOPS);
        a = 255;
      }
      else if(layer === 'rh'){
        // clamp 0..100
        if(v < 0) v = 0;
        if(v > 100) v = 100;
        rgb = colorFromStops(v, RH_STOPS);
        a = 255;
      }
      else if(layer === 'rain'){
        // sotto 0.1 quasi trasparente
        if(v < 0.1){
          a = 0;
          rgb = [0,0,0];
        } else {
          rgb = colorFromStops(v, RAIN_STOPS);
          a = 255;
        }
      }
      else if(layer === 'clouds'){
        if(v < 0) v = 0;
        if(v > 100) v = 100;
        rgb = colorFromStops(v, CLOUD_STOPS);
        // nuvole: pi√π ‚Äúleggere‚Äù gi√† qui, poi l‚Äôalpha globale fa il resto
        a = Math.round(lerp(0, 255, v/100));
      }

      const p = i*4;
      data[p]   = rgb[0];
      data[p+1] = rgb[1];
      data[p+2] = rgb[2];
      data[p+3] = a;
    }

    ctx.putImageData(img, 0, 0);

    scalarOffscreen[layer] = { c, ctx, img, key };
    return scalarOffscreen[layer];
  }

  // =========================
  // ISOBARE (bianche su dark)
  // =========================
  function drawIsobars(){
    const ctx = isoCanvas.getContext('2d');
    const size = map.getSize();
    isoCanvas.width = size.x; isoCanvas.height = size.y;
    L.DomUtil.setPosition(isoCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,size.x,size.y);

    if(!showIso || !currentData || !currentData.press) return;

    const m = currentData.meta;
    const values = currentData.press;

    const contours = d3.contours()
      .size([m.nx, m.ny])
      .thresholds(d3.range(960, 1050, 2))(values);

    ctx.lineWidth = 1.35;
    ctx.font = "900 12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // dark: bianche
    // sat: nere/grigie
    const stroke = (baseMode==='dark') ? "rgba(255,255,255,0.70)" : "rgba(0,0,0,0.60)";
    const labelBg = (baseMode==='dark') ? "rgba(0,0,0,0.65)" : "rgba(255,255,255,0.80)";
    const labelFg = (baseMode==='dark') ? "#fff" : "#000";

    contours.forEach(c => {
      ctx.strokeStyle = stroke;
      ctx.beginPath();
      const labelCandidates = [];

      c.coordinates.forEach(ring => {
        ring.forEach(pts => {
          let first = true;
          const linePts = [];
          pts.forEach(coord => {
            const lat = m.la1 - (coord[1] * m.dy);
            const lon = m.lo1 + (coord[0] * m.dx);
            const p = map.latLngToContainerPoint([lat, lon]);
            linePts.push(p);
            if(first){ ctx.moveTo(p.x,p.y); first=false; }
            else ctx.lineTo(p.x,p.y);
          });
          if(linePts.length > 70) labelCandidates.push(linePts);
        });
      });

      ctx.stroke();

      // etichetta ogni tanto
      labelCandidates.slice(0, 2).forEach(pts => {
        const mid = pts[Math.floor(pts.length/2)];
        ctx.fillStyle = labelBg;
        ctx.fillRect(mid.x-17, mid.y-9, 34, 18);
        ctx.fillStyle = labelFg;
        ctx.fillText(Math.round(c.value), mid.x, mid.y);
      });
    });
  }

  // =========================
  // GRID (solo linee)
  // =========================
  function drawGrid(){
    const ctx = gridCanvas.getContext('2d');
    const size = map.getSize();
    gridCanvas.width = size.x; gridCanvas.height = size.y;
    L.DomUtil.setPosition(gridCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,size.x,size.y);

    if(!showGrid) return;

    const b = map.getBounds();
    const step = map.getZoom() > 9 ? 0.1 : 0.5;

    ctx.strokeStyle = (baseMode==='dark') ? "rgba(255,255,255,0.18)" : "rgba(0,0,0,0.18)";
    ctx.lineWidth = 1;

    for(let lon=Math.floor(b.getWest()); lon<=Math.ceil(b.getEast()); lon+=step){
      const x = map.latLngToContainerPoint([b.getSouth(), lon]).x;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,size.y); ctx.stroke();
    }
    for(let lat=Math.floor(b.getSouth()); lat<=Math.ceil(b.getNorth()); lat+=step){
      const y = map.latLngToContainerPoint([lat, b.getWest()]).y;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(size.x,y); ctx.stroke();
    }
  }

  // =========================
  // WIND (contrasto adattivo)
  // =========================
  function updateWind(){
    if(velocityLayer) { map.removeLayer(velocityLayer); velocityLayer = null; }
    if(!enabled.wind || !currentData) return;

    // densit√† particelle adattiva (FPS)
    const isMobile = Math.min(window.innerWidth, window.innerHeight) < 900;
    const dpr = window.devicePixelRatio || 1;
    let particleMult = isMobile ? (1/200) : (1/140);
    if(dpr >= 2) particleMult = isMobile ? (1/260) : (1/200);

    // palette vento: su sat serve pi√π contrasto (colori pi√π ‚Äúscuri‚Äù/decisi)
    const windColorsDark = ["#000080", "#0044ff", "#00ddff", "#00ff55", "#ffff00", "#ff6600", "#ff0000", "#ff00ff"];
    const windColorsSat  = ["#001040", "#0030cc", "#00a0ff", "#00ff80", "#ffff00", "#ff7a00", "#ff0000", "#b000ff"];

    try{
      velocityLayer = L.velocityLayer({
        displayValues: false,
        data: [ currentData.wind_u, currentData.wind_v ],
        maxVelocity: 18.0,
        velocityScale: 0.006,
        particleMultiplier: particleMult,
        lineWidth: (baseMode==='sat') ? 1.1 : 0.9,
        particleAge: 140,
        frameRate: 60,
        opacity: (baseMode==='sat') ? 1.0 : 0.95,
        colorScale: (baseMode==='sat') ? windColorsSat : windColorsDark
      });
      velocityLayer.addTo(map);
    }catch(e){}
  }

  // =========================
  // PICKER (valore sotto mouse/click)
  // =========================
  function valueAtLatLng(latlng){
    if(!currentData || !currentData.meta) return null;
    const m = currentData.meta;

    const y = Math.round((m.la1 - latlng.lat) / m.dy);
    const x = Math.round((latlng.lng - m.lo1) / m.dx);
    if(x < 0 || x >= m.nx || y < 0 || y >= m.ny) return null;
    const idx = y*m.nx + x;

    // priorit√†: se pi√π layer attivi, mostra il primo attivo in lista (puoi cambiare ordine)
    const order = ['temp','press','rain','rh','clouds','wind'];
    for(const k of order){
      if(!enabled[k]) continue;

      if(k==='wind'){
        const u = currentData.wind_u.data[idx];
        const v = currentData.wind_v.data[idx];
        return { layer:'wind', value: Math.sqrt(u*u+v*v)*3.6 };
      }
      if(k==='temp')   return { layer:'temp', value: currentData.temp[idx] };
      if(k==='press')  return { layer:'press', value: currentData.press[idx] };
      if(k==='rain')   return { layer:'rain', value: currentData.rain[idx] };
      if(k==='rh')     return { layer:'rh', value: currentData.rh[idx] };
      if(k==='clouds'){
        const arr = currentData.clouds || currentData.cloud;
        if(!arr) continue;
        return { layer:'clouds', value: arr[idx] };
      }
    }
    return null;
  }

  function updatePickerFromEvent(e){
    const out = valueAtLatLng(e.latlng);
    if(!out) return;

    const v = out.value;
    let txt = '--';

    if(out.layer==='wind') txt = v.toFixed(1);
    else if(out.layer==='temp') txt = v.toFixed(1);
    else if(out.layer==='rain') txt = v.toFixed(1);
    else if(out.layer==='press') txt = Math.round(v).toString();
    else if(out.layer==='rh') txt = Math.round(v).toString();
    else if(out.layer==='clouds') txt = Math.round(v).toString();

    document.getElementById('val-display').innerText = txt;
    document.getElementById('unit-display').innerText = unitFor(out.layer);
  }

  // =========================
  // PLAY
  // =========================
  window.togglePlay = function(){
    if(isPlaying){
      isPlaying = false;
      document.getElementById('play-btn').innerText = "‚ñ∫";
      return;
    }
    isPlaying = true;

    const s = document.getElementById('time-slider');
    const btn = document.getElementById('play-btn');
    btn.innerText = "‚ùö‚ùö";

    let i = parseInt(s.value, 10);
    const max = parseInt(s.max, 10);

    const interval = setInterval(() => {
      if(!isPlaying){ clearInterval(interval); btn.innerText="‚ñ∫"; return; }
      if(i >= max){ clearInterval(interval); isPlaying=false; btn.innerText="‚ñ∫"; return; }
      i++;
      s.value = i;
      loadStep(i);
    }, 800);
  }
</script>
</body>
</html>