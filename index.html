<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Sicilia MeteoHub - PRO (Synoptic Wind + Multi-Layer)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css"/>
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    :root{
      --ui-bg: rgba(0,0,0,0.72);
      --ui-br: rgba(255,255,255,0.18);
      --ui-tx: #eaeaea;
      --ui-tx-dim:#bdbdbd;
      --accent:#2f7dff;
    }
    html, body { height:100%; margin:0; background:#0b0b0b; font-family: "Segoe UI", Roboto, system-ui, sans-serif; color:var(--ui-tx); overflow:hidden;}
    #map { position:absolute; inset:0; background:#0b0b0b; }

    /* UI */
    #ui { position:absolute; top:12px; right:12px; z-index:2000; display:flex; flex-direction:column; gap:10px; align-items:flex-end; }
    .panel{
      background: var(--ui-bg);
      border: 1px solid var(--ui-br);
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      overflow:hidden;
    }
    .row { display:flex; gap:6px; padding:8px; }
    .segbtn{
      padding:8px 12px;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.08);
      color:#fff;
      font-weight:800;
      font-size:12px;
      cursor:pointer;
      transition: all .15s;
    }
    .segbtn:hover{ background: rgba(255,255,255,0.14); }
    .segbtn.active{
      background: var(--accent);
      border-color: rgba(120,180,255,0.65);
      box-shadow: 0 0 16px rgba(47,125,255,0.35);
    }

    .menu { padding:10px; }
    .btn{
      width:170px;
      display:flex;
      justify-content:flex-end;
      align-items:center;
      gap:8px;
      padding:10px 10px;
      margin:6px 0;
      border:1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      background: rgba(255,255,255,0.04);
      color: var(--ui-tx-dim);
      font-weight:800;
      font-size:13px;
      cursor:pointer;
      transition: all .15s;
      user-select:none;
    }
    .btn:hover{ background: rgba(255,255,255,0.10); color:#fff; }
    .btn.on{
      background: linear-gradient(90deg, rgba(47,125,255,0.95), rgba(18,70,170,0.95));
      color:#fff;
      border-color: rgba(120,180,255,0.55);
      box-shadow: 0 0 14px rgba(47,125,255,0.28);
    }
    .btn.dim{ color:#cfcfcf; }
    .sub{
      width:170px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:8px 10px;
      margin:6px 0 0 0;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03);
      font-weight:800;
      font-size:12px;
      color:#ddd;
      cursor:pointer;
    }
    .sub .tag{
      font-size:11px;
      font-weight:900;
      padding:4px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.14);
    }
    .divider{ height:1px; background: rgba(255,255,255,0.12); margin:10px 0; }

    /* Picker */
    #picker{
      position:absolute; top:16px; left:16px; z-index:2000;
      pointer-events:none;
      text-shadow: 0 2px 12px rgba(0,0,0,0.9);
    }
    #pv { font-size: 44px; font-weight: 950; letter-spacing: -0.5px; line-height: 1; }
    #pu { font-size: 14px; font-weight: 900; color: rgba(255,255,255,0.85); margin-top: 2px; }
    #pt { font-size: 12px; font-weight: 900; color: rgba(255,255,255,0.62); margin-top: 6px; }

    /* Timeline */
    #bottom{
      position:absolute; left:0; right:0; bottom:0; height:96px;
      z-index:2500;
      display:flex; align-items:center;
      padding: 0 16px 16px 16px;
      background: linear-gradient(to top, rgba(0,0,0,0.92), rgba(0,0,0,0.55), transparent);
      gap: 12px;
    }
    #play{
      width:54px; height:54px; border-radius: 18px;
      display:grid; place-items:center;
      background: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.14);
      color:#fff;
      font-size:26px;
      cursor:pointer;
      user-select:none;
      transition: all .12s;
    }
    #play:active{ transform: scale(0.95); }
    #slider{ flex:1; accent-color: var(--accent); height:6px; }
    #tlabel{
      min-width:160px;
      text-align:right;
      font-weight:950;
      font-size:18px;
      font-variant-numeric: tabular-nums;
      text-shadow: 0 2px 12px rgba(0,0,0,0.85);
    }

    /* Toast */
    #toast{
      position:absolute; left:16px; bottom:110px; z-index:2600;
      background: rgba(35,0,0,0.82);
      border: 1px solid rgba(255,90,90,0.35);
      color: #ffd7d7;
      padding:10px 12px;
      border-radius: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size:12px;
      display:none;
      max-width: 78vw;
    }

    /* Canvas tuning */
    canvas.leaflet-layer { image-rendering: auto; }
  </style>
</head>

<body>
  <div id="map"></div>

  <div id="picker">
    <div id="pv">--</div>
    <div id="pu">--</div>
    <div id="pt">--</div>
  </div>

  <div id="toast"></div>

  <div id="ui">
    <div class="panel">
      <div class="row">
        <button class="segbtn active" id="btn-base-relief">RELIEF</button>
        <button class="segbtn" id="btn-base-sat">SAT</button>
      </div>
    </div>

    <div class="panel">
      <div class="menu">
        <div class="btn on" id="btn-wind">VENTO üí®</div>
        <div class="sub" id="btn-windmode">
          <span>Modalit√† vento</span><span class="tag" id="windmode-tag">SINOTTICA</span>
        </div>

        <div class="btn" id="btn-temp">TEMP üå°Ô∏è</div>
        <div class="btn" id="btn-rain">PIOGGIA ‚òî</div>
        <div class="btn" id="btn-rh">UMIDIT√Ä üíß</div>
        <div class="btn" id="btn-press">PRESSIONE ‚è≤Ô∏è</div>
        <div class="btn" id="btn-cloud">NUVOLE ‚òÅÔ∏è</div>

        <div class="divider"></div>

        <div class="btn" id="btn-iso">ISOBARE „Ä∞Ô∏è</div>
        <!-- griglia rimossa volutamente -->
      </div>
    </div>
  </div>

  <div id="bottom">
    <div id="play">‚ñ∫</div>
    <input id="slider" type="range" min="0" max="0" step="1" value="0"/>
    <div id="tlabel">--/-- --:--</div>
  </div>

<script>
/* ==========================
   CONFIG / STATE
========================== */
const SICILY_BOUNDS = L.latLngBounds(
  L.latLng(35.0, 11.0),
  L.latLng(39.5, 16.5)
);

let map;
let baseRelief, baseSat, labelsRelief, labelsSat;

let velocityLayer = null;      // particles layer (leaflet-velocity)
let canvScalar = null;         // scalar fields (temp/rain/rh/press/clouds/windBG)
let canvIso = null;            // isobars overlay
let ctxScalar, ctxIso;

let catalog = [];
let currentData = null;

let selected = new Set(["wind"]);  // multi-select layers
let showIso = false;

let primary = "wind";              // layer shown in picker
let windMode = "synoptic";         // "synoptic" | "particles"

let isPlaying = false;
let playTimer = null;
let isSat = false;

/* ==========================
   HELPERS
========================== */
function toast(msg){
  const el = document.getElementById("toast");
  el.textContent = msg;
  el.style.display = "block";
  clearTimeout(el._t);
  el._t = setTimeout(()=>{ el.style.display="none"; }, 4500);
}

function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

function setBtnOn(id, on){
  const el = document.getElementById(id);
  if(!el) return;
  el.classList.toggle("on", !!on);
}

function unitFor(layer){
  if(layer==="wind") return "km/h";
  if(layer==="temp") return "¬∞C";
  if(layer==="rain") return "mm";
  if(layer==="rh") return "%";
  if(layer==="press") return "hPa";
  if(layer==="cloud") return "%";
  return "--";
}

function labelFor(layer){
  if(layer==="wind") return (windMode==="synoptic") ? "Vento (sinottico)" : "Vento (particelle)";
  if(layer==="temp") return "Temperatura";
  if(layer==="rain") return "Precipitazione";
  if(layer==="rh") return "Umidit√† relativa";
  if(layer==="press") return "Pressione";
  if(layer==="cloud") return "Copertura nuvolosa";
  return "--";
}

/* ==========================
   PALETTES (scientific-friendly)
   Temp: -15..45 with anchors you gave.
========================== */
const TEMP_ANCHORS = [
  {v:-15, rgb:[60,  0, 110]},   // viola scuro
  {v:  0, rgb:[ 0, 210, 255]},  // ciano
  {v: 15, rgb:[255, 250, 160]}, // giallo chiaro
  {v: 20, rgb:[255, 220,   0]}, // giallo
  {v: 25, rgb:[255, 170,  70]}, // arancione chiaro
  {v: 30, rgb:[255, 120,   0]}, // arancione
  {v: 35, rgb:[255,  40,  40]}, // rosso
  {v: 45, rgb:[130,   0,   0]}  // rosso scuro
];

function lerp(a,b,t){ return a + (b-a)*t; }
function lerpRGB(c1,c2,t){
  return [
    Math.round(lerp(c1[0],c2[0],t)),
    Math.round(lerp(c1[1],c2[1],t)),
    Math.round(lerp(c1[2],c2[2],t))
  ];
}

function buildTempLUT(){
  // LUT per ogni grado intero, con "contrast boost" lieve per distinguere meglio
  const lut = new Map();
  for(let T=-15; T<=45; T++){
    // trova segmento
    let a = TEMP_ANCHORS[0], b = TEMP_ANCHORS[TEMP_ANCHORS.length-1];
    for(let i=0;i<TEMP_ANCHORS.length-1;i++){
      if(T>=TEMP_ANCHORS[i].v && T<=TEMP_ANCHORS[i+1].v){
        a = TEMP_ANCHORS[i]; b = TEMP_ANCHORS[i+1];
        break;
      }
    }
    const t = (T - a.v) / (b.v - a.v);
    let rgb = lerpRGB(a.rgb, b.rgb, t);

    // boost saturazione/contrasto semplice (senza HSL per restare leggero)
    // spinge lontano dal grigio: rgb' = mean + (rgb-mean)*k
    const mean = (rgb[0]+rgb[1]+rgb[2])/3;
    const k = 1.18;
    rgb = [
      Math.round(clamp(mean + (rgb[0]-mean)*k, 0, 255)),
      Math.round(clamp(mean + (rgb[1]-mean)*k, 0, 255)),
      Math.round(clamp(mean + (rgb[2]-mean)*k, 0, 255))
    ];
    lut.set(T, rgb);
  }
  return lut;
}
const TEMP_LUT = buildTempLUT();

function tempColorC(tempC){
  // clamp e quantizza a 1¬∞C per "ogni grado un colore"
  const T = Math.round(clamp(tempC, -15, 45));
  const rgb = TEMP_LUT.get(T) || [255,255,255];
  return rgb;
}

// Rain palette (pi√π netta, non ‚Äúpastello‚Äù)
function rainColor(mm){
  // mm accumulo: 0..50+
  const v = Math.max(0, mm);
  if(v < 0.1) return {rgb:[0,0,0], a:0};
  if(v < 2)   return {rgb:[ 40, 180, 255], a:0.55};
  if(v < 10)  return {rgb:[  0,  90, 255], a:0.65};
  if(v < 25)  return {rgb:[255,  70, 255], a:0.72};
  return      {rgb:[170,   0, 200], a:0.78};
}

// RH palette
function rhColor(rh){
  const v = clamp(rh, 0, 100);
  if(v < 30) return {rgb:[210,160, 60], a:0.52};
  if(v < 50) return {rgb:[200,200,200], a:0.50};
  if(v < 70) return {rgb:[ 90,255,120], a:0.55};
  if(v < 85) return {rgb:[ 60,170,255], a:0.62};
  return     {rgb:[  0, 70,200], a:0.70};
}

// Press palette (sinottica: bassa blu -> alta rosso)
function pressColor(hpa){
  const v = clamp(hpa, 960, 1050);
  if(v < 990)  return {rgb:[  0, 80,255], a:0.52};
  if(v < 1005) return {rgb:[  0,200,255], a:0.54};
  if(v < 1013) return {rgb:[  0,255,180], a:0.56};
  if(v < 1022) return {rgb:[255,255,255], a:0.52};
  if(v < 1030) return {rgb:[255,200,  0], a:0.58};
  return       {rgb:[255, 60,  0], a:0.64};
}

// Clouds: bianco -> grigio scuro, pi√π opache e distinguibili
function cloudColor(pct){
  const v = clamp(pct, 0, 100) / 100;
  // gamma per staccare meglio le differenze
  const g = Math.pow(v, 0.75);
  const c = Math.round(lerp(255, 40, g)); // 255->40
  const a = lerp(0.10, 0.72, g);          // pi√π opaco
  return {rgb:[c,c,c], a:a};
}

// Wind background (km/h) ‚Äì per modalit√† sinottica (sfondo intensit√†)
function windBgColor(kmh){
  // scala pi√π leggibile 0..120 km/h
  const v = clamp(kmh, 0, 120);

  // palette sinottica: grigio -> azzurri -> verdi -> gialli -> arancioni -> rossi/viola
  if(v < 5)   return {rgb:[245,245,245], a:0.30};
  if(v < 10)  return {rgb:[210,230,255], a:0.38};
  if(v < 20)  return {rgb:[140,190,255], a:0.48};
  if(v < 30)  return {rgb:[ 60,150,255], a:0.56};
  if(v < 40)  return {rgb:[  0,210,220], a:0.62};
  if(v < 55)  return {rgb:[  0,220,120], a:0.66};
  if(v < 70)  return {rgb:[190,230,  0], a:0.70};
  if(v < 85)  return {rgb:[255,190,  0], a:0.74};
  if(v < 100) return {rgb:[255,110,  0], a:0.78};
  if(v < 115) return {rgb:[230,  0,  0], a:0.82};
  return           {rgb:[170,  0,170], a:0.86};
}

// Particle colorScale: stessa scala, ma pi√π scura per mappa chiara
const WIND_PARTICLE_COLORS_DARKER = [
  "#00005a", "#0033c9", "#0099c9", "#00b83b",
  "#d6c700", "#d65100", "#b00000", "#7a00a8"
];

/* ==========================
   INIT MAP
========================== */
window.addEventListener("load", async () => {
  map = L.map("map", {
    zoomControl: false,
    maxBounds: SICILY_BOUNDS.pad(0.35),
    maxBoundsViscosity: 1.0,
    zoomSnap: 0.25
  }).setView([37.5, 14.2], 7.8);

  // Base: "mappa grigia con rilievi" (stile screenshot) ‚Äì Esri World Shaded Relief
  baseRelief = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 13, attribution: "Tiles ¬© Esri" }
  ).addTo(map);

  // Label sopra (per vedere citt√†)
  labelsRelief = L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png",
    { maxZoom: 19, attribution: "¬©Carto", opacity: 0.95 }
  ).addTo(map);

  // Satellitare
  baseSat = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 19, attribution: "Tiles ¬© Esri" }
  );

  // Labels anche su satellite
  labelsSat = L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png",
    { maxZoom: 19, attribution: "¬©Carto", opacity: 0.98 }
  );

  // Tile error (utile se una sorgente blocca)
  baseRelief.on("tileerror", ()=>toast("Tile basemap non caricate (server/URL bloccato). Prova a cambiare base o rete."));
  baseSat.on("tileerror", ()=>toast("Tile satellitari non caricate (server/URL bloccato). Prova a cambiare base o rete."));

  createCanvases();

  // UI base
  document.getElementById("btn-base-relief").addEventListener("click", ()=>setBase("relief"));
  document.getElementById("btn-base-sat").addEventListener("click", ()=>setBase("sat"));

  // UI layer toggles
  hookToggle("btn-wind", "wind");
  hookToggle("btn-temp", "temp");
  hookToggle("btn-rain", "rain");
  hookToggle("btn-rh", "rh");
  hookToggle("btn-press", "press");
  hookToggle("btn-cloud", "cloud");

  document.getElementById("btn-iso").addEventListener("click", ()=>{
    showIso = !showIso;
    setBtnOn("btn-iso", showIso);
    redrawAll();
  });

  // wind mode button
  document.getElementById("btn-windmode").addEventListener("click", ()=>{
    windMode = (windMode === "synoptic") ? "particles" : "synoptic";
    document.getElementById("windmode-tag").textContent = (windMode === "synoptic") ? "SINOTTICA" : "PARTICELLE";
    redrawAll();
  });

  // timeline controls
  document.getElementById("play").addEventListener("click", togglePlay);
  document.getElementById("slider").addEventListener("input", (e)=>loadStep(parseInt(e.target.value,10)));

  // picker (hover + click)
  map.on("mousemove", (e)=>updatePicker(e.latlng, false));
  map.on("click", (e)=>updatePicker(e.latlng, true));

  await loadCatalog();
});

/* ==========================
   BASE SWITCH
========================== */
function setBase(type){
  const bRel = document.getElementById("btn-base-relief");
  const bSat = document.getElementById("btn-base-sat");
  bRel.classList.toggle("active", type==="relief");
  bSat.classList.toggle("active", type==="sat");

  if(type==="sat"){
    isSat = true;
    if(map.hasLayer(baseRelief)) map.removeLayer(baseRelief);
    if(map.hasLayer(labelsRelief)) map.removeLayer(labelsRelief);

    baseSat.addTo(map);
    labelsSat.addTo(map);
  }else{
    isSat = false;
    if(map.hasLayer(baseSat)) map.removeLayer(baseSat);
    if(map.hasLayer(labelsSat)) map.removeLayer(labelsSat);

    baseRelief.addTo(map);
    labelsRelief.addTo(map);
  }

  redrawAll();
}

/* ==========================
   UI LAYER TOGGLES (multi-select)
========================== */
function hookToggle(btnId, layerKey){
  const el = document.getElementById(btnId);
  el.addEventListener("click", ()=>{
    const on = selected.has(layerKey);
    if(on) selected.delete(layerKey);
    else selected.add(layerKey);

    // Mantieni almeno uno layer attivo: se svuota tutto, riattiva vento
    if(selected.size === 0){
      selected.add("wind");
    }

    // se accendi un layer, diventa "primary" per il picker
    if(selected.has(layerKey)) primary = layerKey;
    if(primary === layerKey && !selected.has(layerKey)){
      // fallback: scegli un altro attivo
      primary = Array.from(selected)[0];
    }

    refreshButtons();
    redrawAll();
  });
  refreshButtons();
}

function refreshButtons(){
  setBtnOn("btn-wind", selected.has("wind"));
  setBtnOn("btn-temp", selected.has("temp"));
  setBtnOn("btn-rain", selected.has("rain"));
  setBtnOn("btn-rh", selected.has("rh"));
  setBtnOn("btn-press", selected.has("press"));
  setBtnOn("btn-cloud", selected.has("cloud"));
  setBtnOn("btn-iso", showIso);

  // se vento non selezionato, nascondi modalit√†
  const wm = document.getElementById("btn-windmode");
  wm.style.display = selected.has("wind") ? "flex" : "none";
}

/* ==========================
   CANVAS LAYERS
========================== */
function createCanvases(){
  function mkCanvas(zIndex){
    const c = L.DomUtil.create("canvas", "leaflet-layer");
    c.style.position = "absolute";
    c.style.left = "0";
    c.style.top = "0";
    c.style.pointerEvents = "none";
    c.style.zIndex = zIndex;
    map.getPanes().overlayPane.appendChild(c);
    return c;
  }
  canvScalar = mkCanvas(300);
  canvIso    = mkCanvas(420);

  ctxScalar = canvScalar.getContext("2d");
  ctxIso    = canvIso.getContext("2d");

  map.on("moveend zoomend resize", redrawAll);
}

/* ==========================
   DATA LOAD
========================== */
async function loadCatalog(){
  try{
    const r = await fetch("data_weather/catalog.json?t=" + Date.now());
    if(!r.ok) throw new Error("catalog missing");
    catalog = await r.json();
    if(!catalog || catalog.length===0) throw new Error("empty catalog");

    const s = document.getElementById("slider");
    s.max = catalog.length - 1;
    s.value = 0;

    await loadStep(0);
  }catch(e){
    toast("Catalog non trovato. Controlla data_weather/catalog.json");
  }
}

async function loadStep(idx){
  if(!catalog[idx]) return;
  document.getElementById("tlabel").textContent = catalog[idx].label;

  try{
    const r = await fetch("data_weather/" + catalog[idx].file + "?t=" + Date.now());
    if(!r.ok) throw new Error("frame missing");
    currentData = await r.json();
    redrawAll();
  }catch(e){
    toast("Errore caricamento frame: " + catalog[idx].file);
  }
}

/* ==========================
   DRAW PIPELINE
========================== */
function redrawAll(){
  if(!currentData || !currentData.meta) return;

  resizeCanvasToMap(canvScalar, ctxScalar);
  resizeCanvasToMap(canvIso, ctxIso);

  // 1) scalari (temp/rain/rh/press/cloud/cloud + wind bg se sinottico)
  drawScalarFields();

  // 2) isobare (con etichette)
  drawIsobars();

  // 3) vento: particles solo in modalit√† particelle
  updateWindParticles();
}

function resizeCanvasToMap(canvas, ctx){
  const s = map.getSize();
  canvas.width = Math.round(s.x * (window.devicePixelRatio||1));
  canvas.height= Math.round(s.y * (window.devicePixelRatio||1));
  canvas.style.width = s.x + "px";
  canvas.style.height= s.y + "px";
  L.DomUtil.setPosition(canvas, map.containerPointToLayerPoint([0,0]));
  ctx.setTransform((window.devicePixelRatio||1),0,0,(window.devicePixelRatio||1),0,0);
  ctx.clearRect(0,0,s.x,s.y);
}

/* ==========================
   SCALARS (HD-ish)
   -> niente ‚Äúquadrati evidenti‚Äù: usiamo un draw pi√π fitto + smoothing
========================== */
function getSelectedScalarLayers(){
  const layers = [];
  // Se vento sinottico ed √® selezionato, aggiungi sfondo vento
  if(selected.has("wind") && windMode==="synoptic") layers.push("windbg");
  if(selected.has("temp")) layers.push("temp");
  if(selected.has("rain")) layers.push("rain");
  if(selected.has("rh")) layers.push("rh");
  if(selected.has("press")) layers.push("press");
  if(selected.has("cloud")) layers.push("cloud");
  return layers;
}

function drawScalarFields(){
  const m = currentData.meta;
  const layers = getSelectedScalarLayers();

  // se nessuno scalare attivo, pulisci e basta
  if(layers.length === 0) return;

  // trasparenza ‚Äúintelligente‚Äù: pi√π layer = ogni layer un po‚Äô meno opaco
  // ma NON troppo trasparente: manteniamo leggibilit√†
  const n = layers.length;
  const alphaScale = clamp(1 / Math.sqrt(n), 0.55, 1.0);

  // se vento in modalit√† particelle + altri layer, riduci leggermente la copertura per non ‚Äúuccidere‚Äù le particelle
  const particleActive = selected.has("wind") && windMode==="particles";
  const particleShield = particleActive ? 0.85 : 1.0;

  const bounds = map.getBounds();
  // step ‚Äúsub-grid‚Äù: per dare impressione pi√π HD senza inventare dati,
  // disegniamo comunque ogni cella, ma con blur leggero (via shadow) sarebbe pesante.
  // qui facciamo fillRect normale ma con overlap e canvas smoothing (browser).
  for(let L of layers){
    for(let y=0; y<m.ny; y++){
      const lat = m.la1 - (y*m.dy);
      if(lat < bounds.getSouth()-0.2 || lat > bounds.getNorth()+0.2) continue;

      for(let x=0; x<m.nx; x++){
        const lon = m.lo1 + (x*m.dx);
        if(lon < bounds.getWest()-0.2 || lon > bounds.getEast()+0.2) continue;

        const idx = y*m.nx + x;

        const p1 = map.latLngToContainerPoint([lat, lon]);
        const p2 = map.latLngToContainerPoint([lat - m.dy, lon + m.dx]);

        const w = Math.ceil(p2.x - p1.x) + 2; // overlap per evitare ‚Äúgriglia‚Äù
        const h = Math.ceil(p2.y - p1.y) + 2;

        let rgb = [0,0,0], a = 0;

        if(L==="temp"){
          const v = currentData.temp[idx];
          rgb = tempColorC(v);
          a = 0.55 * alphaScale * particleShield; // mantieni trasparenza ‚Äúbella‚Äù
        }else if(L==="rain"){
          const v = currentData.rain[idx];
          const c = rainColor(v);
          rgb = c.rgb; a = c.a * alphaScale * particleShield;
        }else if(L==="rh"){
          const v = currentData.rh[idx];
          const c = rhColor(v);
          rgb = c.rgb; a = c.a * alphaScale * particleShield;
        }else if(L==="press"){
          const v = currentData.press[idx];
          const c = pressColor(v);
          rgb = c.rgb; a = c.a * alphaScale * particleShield;
        }else if(L==="cloud"){
          // se nel JSON non c'√® cloud, non disegnare (ma la UI resta)
          if(!currentData.cloud) continue;
          const v = currentData.cloud[idx];
          const c = cloudColor(v);
          rgb = c.rgb; a = c.a * alphaScale * particleShield;
        }else if(L==="windbg"){
          // sfondo intensit√† vento (sinottico)
          const u = currentData.wind_u.data[idx];
          const v = currentData.wind_v.data[idx];
          const kmh = Math.sqrt(u*u + v*v) * 3.6;
          const c = windBgColor(kmh);
          rgb = c.rgb; a = c.a * alphaScale * 1.0;
        }

        if(a <= 0) continue;
        ctxScalar.fillStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
        ctxScalar.fillRect(Math.floor(p1.x), Math.floor(p1.y), w, h);
      }
    }
  }

  // Se vento sinottico: sopra lo sfondo disegniamo anche le frecce
  if(selected.has("wind") && windMode==="synoptic"){
    drawWindArrows();
  }
}

/* ==========================
   WIND ARROWS (synoptic)
========================== */
function drawWindArrows(){
  const m = currentData.meta;
  const z = map.getZoom();

  // PI√ô FRECCE: step pi√π basso
  // (zoom alto -> pi√π fitto)
  const step = (z >= 10.0) ? 2 : (z >= 9.0 ? 3 : (z >= 8.0 ? 4 : 5));

  // stile: contorno bianco + corpo scuro (si vede su relief e su sat)
  ctxScalar.lineCap = "round";
  ctxScalar.lineJoin = "round";

  const bounds = map.getBounds();

  for(let y=0; y<m.ny; y+=step){
    const lat = m.la1 - (y*m.dy);
    if(lat < bounds.getSouth()-0.2 || lat > bounds.getNorth()+0.2) continue;

    for(let x=0; x<m.nx; x+=step){
      const lon = m.lo1 + (x*m.dx);
      if(lon < bounds.getWest()-0.2 || lon > bounds.getEast()+0.2) continue;

      const idx = y*m.nx + x;

      const u = currentData.wind_u.data[idx]; // eastward +
      const v = currentData.wind_v.data[idx]; // northward +
      if(!isFinite(u) || !isFinite(v)) continue;

      const sp = Math.sqrt(u*u + v*v);
      if(sp < 0.5) continue; // evita micro frecce inutili

      const p = map.latLngToContainerPoint([lat, lon]);

      // LUNGHEZZA pi√π evidente
      // (sp √® in m/s; scalatura pi√π aggressiva)
      const len = clamp(sp * 3.4, 10, 34);

      // *** FIX DIREZIONE ***
      // Canvas: y cresce verso il basso. v>0 √® verso Nord (su), quindi usa -v.
      // Cos√¨ le frecce coincidono con la direzione delle particelle (flusso "verso").
      const ang = Math.atan2(-v, u);

      // Testa freccia pi√π grande
      const head = clamp(len * 0.33, 6, 14);
      const wing = head * 0.65;

      ctxScalar.save();
      ctxScalar.translate(p.x, p.y);
      ctxScalar.rotate(ang);

      // Contorno chiaro (si vede sempre)
      ctxScalar.strokeStyle = "rgba(255,255,255,0.80)";
      ctxScalar.lineWidth = 3.4;

      ctxScalar.beginPath();
      ctxScalar.moveTo(-len, 0);
      ctxScalar.lineTo(0, 0);
      ctxScalar.moveTo(0, 0);
      ctxScalar.lineTo(-head, -wing);
      ctxScalar.moveTo(0, 0);
      ctxScalar.lineTo(-head,  wing);
      ctxScalar.stroke();

      // Corpo scuro sopra (contrasto)
      ctxScalar.strokeStyle = isSat ? "rgba(0,0,0,0.92)" : "rgba(0,0,0,0.85)";
      ctxScalar.lineWidth = 2.0;

      ctxScalar.beginPath();
      ctxScalar.moveTo(-len, 0);
      ctxScalar.lineTo(0, 0);
      ctxScalar.moveTo(0, 0);
      ctxScalar.lineTo(-head, -wing);
      ctxScalar.moveTo(0, 0);
      ctxScalar.lineTo(-head,  wing);
      ctxScalar.stroke();

      ctxScalar.restore();
    }
  }
}

/* ==========================
   ISOBARS (white + labeled)
========================== */
function drawIsobars(){
  if(!showIso || !currentData || !currentData.press) return;

  const m = currentData.meta;
  const values = currentData.press;

  // step 2 hPa, range coerente
  const contours = d3.contours()
    .size([m.nx, m.ny])
    .thresholds(d3.range(960, 1052, 2))(values);

  ctxIso.lineWidth = 1.25;
  ctxIso.strokeStyle = "rgba(255,255,255,0.92)"; // bianche su tutto
  ctxIso.font = "900 12px Segoe UI, Arial";
  ctxIso.textAlign = "center";
  ctxIso.textBaseline = "middle";

  contours.forEach(c=>{
    ctxIso.beginPath();

    // raccogli un punto "buono" per etichetta (una o pi√π)
    const labelPts = [];

    c.coordinates.forEach(ring=>{
      ring.forEach(pts=>{
        let first = true;
        const line = [];
        pts.forEach(coord=>{
          const lat = m.la1 - (coord[1] * m.dy);
          const lon = m.lo1 + (coord[0] * m.dx);
          const p = map.latLngToContainerPoint([lat, lon]);
          line.push(p);
          if(first){ ctxIso.moveTo(p.x, p.y); first=false; }
          else ctxIso.lineTo(p.x, p.y);
        });
        if(line.length > 80) labelPts.push(line[Math.floor(line.length/2)]);
      });
    });

    ctxIso.stroke();

    // etichette: rettangolo scuro + testo bianco
    labelPts.slice(0,2).forEach(p=>{
      const txt = String(Math.round(c.value));
      ctxIso.fillStyle = "rgba(0,0,0,0.55)";
      ctxIso.fillRect(p.x-18, p.y-9, 36, 18);
      ctxIso.fillStyle = "rgba(255,255,255,0.95)";
      ctxIso.fillText(txt, p.x, p.y);
    });
  });
}

/* ==========================
   WIND PARTICLES (toggle mode)
========================== */
function updateWindParticles(){
  // rimuovi sempre prima
  if(velocityLayer){
    try{ map.removeLayer(velocityLayer); }catch(e){}
    velocityLayer = null;
  }

  if(!selected.has("wind")) return;
  if(windMode !== "particles") return;

  // meno particelle = FPS migliore
  const isMobile = Math.min(window.innerWidth, window.innerHeight) < 900;
  const dpr = window.devicePixelRatio || 1;

  let particleMult = isMobile ? (1/190) : (1/140);
  if(dpr >= 2) particleMult = isMobile ? (1/260) : (1/200);

  // su base chiara (relief/sat) serve contrasto: colorScale pi√π scura
  const colorScale = WIND_PARTICLE_COLORS_DARKER;

  try{
    velocityLayer = L.velocityLayer({
      displayValues: false,
      data: [currentData.wind_u, currentData.wind_v],

      maxVelocity: 18.0,
      velocityScale: 0.006,
      particleMultiplier: particleMult,
      lineWidth: 0.9,
      particleAge: 120,
      frameRate: 55,
      opacity: 0.95,
      colorScale: colorScale
    });
    velocityLayer.addTo(map);
  }catch(e){
    toast("Errore layer particelle vento.");
  }
}

/* ==========================
   PICKER (primary layer)
========================== */
function valueAt(latlng, layer){
  if(!currentData || !currentData.meta) return null;
  const m = currentData.meta;

  const y = Math.round((m.la1 - latlng.lat) / m.dy);
  const x = Math.round((latlng.lng - m.lo1) / m.dx);
  if(x<0 || x>=m.nx || y<0 || y>=m.ny) return null;

  const idx = y*m.nx + x;

  if(layer==="wind"){
    const u = currentData.wind_u.data[idx];
    const v = currentData.wind_v.data[idx];
    return Math.sqrt(u*u + v*v) * 3.6;
  }
  if(layer==="temp") return currentData.temp[idx];
  if(layer==="rain") return currentData.rain[idx];
  if(layer==="rh") return currentData.rh[idx];
  if(layer==="press") return currentData.press[idx];
  if(layer==="cloud"){
    if(!currentData.cloud) return null;
    return currentData.cloud[idx];
  }
  return null;
}

function updatePicker(latlng, force){
  if(!currentData) return;

  // se primary non √® selezionato (pu√≤ succedere), correggi
  if(!selected.has(primary)){
    primary = Array.from(selected)[0] || "wind";
  }

  const val = valueAt(latlng, primary);
  if(val === null || val === undefined) return;

  let out = "--";
  if(primary==="wind") out = val.toFixed(1);
  else if(primary==="temp") out = val.toFixed(1);
  else if(primary==="rain") out = val.toFixed(2);
  else if(primary==="rh") out = Math.round(val).toString();
  else if(primary==="press") out = Math.round(val).toString();
  else if(primary==="cloud") out = Math.round(val).toString();

  document.getElementById("pv").textContent = out;
  document.getElementById("pu").textContent = unitFor(primary);
  document.getElementById("pt").textContent = labelFor(primary);
}

/* ==========================
   PLAY
========================== */
function togglePlay(){
  const btn = document.getElementById("play");
  const s = document.getElementById("slider");

  if(isPlaying){
    isPlaying = false;
    btn.textContent = "‚ñ∫";
    if(playTimer) clearInterval(playTimer);
    playTimer = null;
    return;
  }

  isPlaying = true;
  btn.textContent = "‚ùö‚ùö";

  let i = parseInt(s.value,10);
  const max = parseInt(s.max,10);

  playTimer = setInterval(async ()=>{
    if(!isPlaying){
      clearInterval(playTimer);
      playTimer = null;
      return;
    }
    if(i >= max){
      isPlaying = false;
      btn.textContent = "‚ñ∫";
      clearInterval(playTimer);
      playTimer = null;
      return;
    }
    i++;
    s.value = i;
    await loadStep(i);
  }, 850);
}
</script>
</body>
</html>
```Ó®Å0Ó®Ç