<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - FINAL COMPLETE (DISCRETE TEMP + ISOTERME 1¬∞C)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin: 0; background: #1a1a1a; font-family: 'Segoe UI', sans-serif; color: #ddd; overflow: hidden; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #1a1a1a; }

    #ui-container {
      position: absolute; top: 10px; right: 10px; z-index: 2000;
      display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
    }
    .panel {
      background: rgba(30,30,30,0.9);
      backdrop-filter: blur(12px);
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 12px 30px rgba(0,0,0,0.6);
      color: #eee;
    }
    .toggle {
      width: 175px;
      display:flex; align-items:center; justify-content:space-between;
      padding: 10px 12px; margin: 6px 0;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #ccc;
      border-radius: 10px;
      cursor: pointer;
      user-select:none;
      font-weight: 700;
      transition: all 0.15s;
    }
    .toggle:hover { background: rgba(255,255,255,0.1); color:#fff; }
    .toggle.active {
      background: linear-gradient(90deg, #0077ff, #0044cc);
      border-color: rgba(0,100,200,0.5);
      color: #fff;
      box-shadow: 0 4px 12px rgba(0,136,255,0.3);
    }

    .mini {
      width: 175px; padding: 9px 12px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05);
      color:#ccc; cursor:pointer; font-weight:800;
    }
    .mini:hover { background: rgba(255,255,255,0.1); color:#fff; }
    .mini.active { background: #eee; color:#111; border-color: #fff; }

    #info-box {
        position: absolute; top: 18px; left: 18px; z-index: 2000;
        pointer-events: none;
        display: flex; align-items: center; gap: 15px;
    }
    #val-group { display: flex; flex-direction: column; }
    #val-display { font-size: 3.6em; font-weight: 950; line-height: 0.9; color: #fff; text-shadow: 0 2px 5px rgba(0,0,0,0.8); }
    #unit-display { font-size: 1.15em; color: #aaa; font-weight: 850; margin-top: 4px; text-shadow: 0 1px 3px rgba(0,0,0,0.9); }

    #wind-rose {
        width: 50px; height: 50px;
        background: rgba(255,255,255,0.9);
        border: 2px solid rgba(255,255,255,0.5);
        border-radius: 50%;
        display: none;
        align-items: center; justify-content: center;
        position: relative;
        box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }
    .cardinal { position: absolute; font-size: 9px; font-weight: 900; color: #111; }
    .c-n { top: 2px; left: 50%; transform: translateX(-50%); }
    .c-s { bottom: 2px; left: 50%; transform: translateX(-50%); }
    .c-e { right: 3px; top: 50%; transform: translateY(-50%); }
    .c-w { left: 3px; top: 50%; transform: translateY(-50%); }
    #rose-arrow { width: 26px; height: 26px; fill: #000; transition: transform 0.1s; }

    #bottom-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: 92px;
      background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
      display: flex; align-items: center; padding: 0 18px; z-index: 2000;
    }
    #play-btn { font-size: 2.6em; background: none; border: none; color: #fff; cursor: pointer; margin-right: 14px; }
    #time-label { font-size: 1.45em; font-weight: 950; margin-left: 14px; min-width: 150px; text-align: center; color: #fff; }
    input[type=range] { flex-grow: 1; height: 6px; cursor: pointer; accent-color: #0077ff; background: rgba(255,255,255,0.2); }

    .dark-relief-tiles {
        filter: invert(100%) hue-rotate(180deg) brightness(0.8) contrast(1.2) grayscale(20%);
    }

    canvas.leaflet-layer.scalar-layer { image-rendering: auto; mix-blend-mode: screen; opacity: 0.92; }
    canvas.leaflet-layer.velocity-canvas { mix-blend-mode: normal; opacity: 1.0; }
  </style>
</head>

<body>
  <div id="info-box">
    <div id="val-group">
        <div id="val-display">--</div>
        <div id="unit-display">Caricamento...</div>
    </div>
    <div id="wind-rose">
        <span class="cardinal c-n">N</span>
        <span class="cardinal c-s">S</span>
        <span class="cardinal c-e">E</span>
        <span class="cardinal c-w">W</span>
        <svg id="rose-arrow" viewBox="0 0 24 24"><path d="M12 2L4.5 20.29L5.21 21L12 18L18.79 21L19.5 20.29L12 2Z" /></svg>
    </div>
  </div>

  <div id="ui-container">
    <div class="panel">
      <button id="btn-flow" class="mini active" onclick="toggleParticles()">FLUSSO üå¨Ô∏è (ON)</button>
    </div>

    <div class="panel">
      <div style="font-weight:950; opacity:0.8; margin-bottom:6px; color:#aaa;">LIVELLI</div>

      <div class="toggle active" onclick="toggleLayer('wind')"><span>VENTO (frecce) üß≠</span><span>‚óè</span></div>
      <div class="toggle" onclick="toggleLayer('temp')"><span>TEMP üå°Ô∏è</span><span>‚óè</span></div>
      <div class="toggle" onclick="toggleLayer('rain')"><span>PIOGGIA ‚òî</span><span>‚óè</span></div>
      <div class="toggle" onclick="toggleLayer('rh')"><span>UMIDIT√Ä üíß</span><span>‚óè</span></div>
      <div class="toggle" onclick="toggleLayer('press')"><span>PRESSIONE ‚è≤Ô∏è</span><span>‚óè</span></div>
      <div class="toggle" onclick="toggleLayer('cloud')"><span>NUVOLE ‚òÅÔ∏è</span><span>‚óè</span></div>

      <div style="height:1px; background: rgba(255,255,255,0.1); margin:10px 0;"></div>

      <div class="toggle" id="btn-iso" onclick="toggleIsobars()"><span>ISOBARE „Ä∞Ô∏è</span><span> </span></div>
      <div class="toggle" id="btn-therm" onclick="toggleIsotherms()"><span>ISOTERME üå°Ô∏è„Ä∞Ô∏è</span><span> </span></div>
      <div class="toggle" id="btn-grid" onclick="toggleGrid()"><span>RETICOLO #</span><span> </span></div>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  const SICILY_BOUNDS = L.latLngBounds(L.latLng(35.0, 11.0), L.latLng(39.5, 16.5));
  const WIND_COLOR_SCALE = ["#000080", "#0044ff", "#00ddff", "#00ff55", "#ffff00", "#ff6600", "#ff0000", "#ff00ff"];

  // ======== DISCRETE TEMPERATURE: 1 grado = 1 colore (NETTO) ========
  const T_MIN = -15;
  const T_MAX = 45;

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function lerp(a,b,t){ return a+(b-a)*t; }

  // HSL -> RGB
  function hslToRgb(h, s, l) {
    h = ((h % 360) + 360) % 360;
    s = clamp(s, 0, 1);
    l = clamp(l, 0, 1);
    const c = (1 - Math.abs(2*l - 1)) * s;
    const hp = h / 60;
    const x = c * (1 - Math.abs((hp % 2) - 1));
    let r1=0,g1=0,b1=0;
    if(hp>=0 && hp<1){ r1=c; g1=x; b1=0; }
    else if(hp<2){ r1=x; g1=c; b1=0; }
    else if(hp<3){ r1=0; g1=c; b1=x; }
    else if(hp<4){ r1=0; g1=x; b1=c; }
    else if(hp<5){ r1=x; g1=0; b1=c; }
    else { r1=c; g1=0; b1=x; }
    const m = l - c/2;
    return {
      r: Math.round((r1+m)*255),
      g: Math.round((g1+m)*255),
      b: Math.round((b1+m)*255)
    };
  }

  // Palette ‚Äúmeteorologica‚Äù discreta:
  // - Hue da viola (freddo) -> rosso (caldo)
  // - Saturazione alta
  // - Luminosit√† alternata (pari/dispari) per distinguere bene gradi vicini
  function tempColorInt(T) {
    const t = clamp((T - T_MIN) / (T_MAX - T_MIN), 0, 1);

    // Hue: 270¬∞ (viola) -> 0¬∞ (rosso)
    const hue = lerp(270, 0, t);

    // Saturazione alta
    const sat = 0.95;

    // Luminosit√† alternata per differenziare ogni grado
    // (mantiene la scala coerente, ma rende i gradi vicini pi√π ‚Äúleggibili‚Äù)
    const baseL = lerp(0.48, 0.52, t);        // leggera variazione
    const alt = (Math.round(T) % 2 === 0) ? 0.06 : -0.06;
    const lum = clamp(baseL + alt, 0.30, 0.70);

    return hslToRgb(hue, sat, lum);
  }

  // ======== ALTRI LAYER ========
  const RAIN_STOPS = [
    {v:0.0, c:[0,0,0], a:0.0},
    {v:0.6, c:[100,200,255], a:0.65},
    {v:1.0, c:[0,150,255], a:0.75},
    {v:5.0, c:[0,0,255], a:0.85},
    {v:10,  c:[255,255,0], a:0.85},
    {v:30,  c:[255,150,0], a:0.88},
    {v:50,  c:[255,0,0], a:0.92}
  ];

  const RH_STOPS = [
    {v:0, c:[173,85,56]}, {v:20, c:[173,101,56]}, {v:40, c:[173,146,56]},
    {v:60, c:[56,173,121]}, {v:80, c:[56,157,173]}, {v:100, c:[56,70,114]}
  ];

  const PRESS_STOPS = [
    {v: 900, c: [8,16,48]}, {v: 976, c: [0,52,146]}, {v: 995, c: [0,117,146]},
    {v: 1013.25, c: [182,182,182]}, {v: 1024, c: [163,116,67]},
    {v: 1038, c: [142,47,57]}, {v: 1080, c: [48,8,24]}
  ];

  const CLOUD_STOPS = [
    {v:0,   c:[255,255,255], a:0.0},
    {v:50,  c:[200,200,200], a:0.55},
    {v:100, c:[90,90,90],    a:0.80}
  ];

  function interpStops(val, stops){
    if(!stops || stops.length<2) return {r:0,g:0,b:0,a:0};
    if(val <= stops[0].v){
      const s=stops[0];
      return {r:s.c[0],g:s.c[1],b:s.c[2],a:('a' in s)?s.a:0.85};
    }
    for(let i=0;i<stops.length-1;i++){
      if(val >= stops[i].v && val < stops[i+1].v){
        const s1=stops[i], s2=stops[i+1];
        const t=(val-s1.v)/(s2.v-s1.v);
        const a1=('a' in s1)?s1.a:0.85;
        const a2=('a' in s2)?s2.a:0.85;
        return {
          r:Math.round(lerp(s1.c[0],s2.c[0],t)),
          g:Math.round(lerp(s1.c[1],s2.c[1],t)),
          b:Math.round(lerp(s1.c[2],s2.c[2],t)),
          a:lerp(a1,a2,t)
        };
      }
    }
    const s=stops[stops.length-1];
    return {r:s.c[0],g:s.c[1],b:s.c[2],a:('a' in s)?s.a:0.85};
  }

  function vividWindColor(speedMs){
    const maxV=20.0;
    const t=clamp(speedMs/maxV, 0, 0.9999);
    const n=WIND_COLOR_SCALE.length;
    const pos=t*(n-1);
    const i=Math.floor(pos), f=pos-i;
    const h1=WIND_COLOR_SCALE[i], h2=WIND_COLOR_SCALE[Math.min(i+1,n-1)];
    const r1=parseInt(h1.slice(1,3),16), g1=parseInt(h1.slice(3,5),16), b1=parseInt(h1.slice(5,7),16);
    const r2=parseInt(h2.slice(1,3),16), g2=parseInt(h2.slice(3,5),16), b2=parseInt(h2.slice(5,7),16);
    return {r:Math.round(lerp(r1,r2,f)), g:Math.round(lerp(g1,g2,f)), b:Math.round(lerp(b1,b2,f))};
  }

  function getCloudArray(){
    return currentData?.cloud ?? currentData?.cld ?? currentData?.tcc ?? currentData?.cloudcover ?? null;
  }

  let map, currentData=null, catalog=[];
  const selected = new Set(['wind']);
  let showIsobars=false, showIsotherms=false, showGrid=false, particlesOn=true;

  let velocityLayer=null;
  let scalarCanvases={}, arrowCanvas, thermCanvas, isoCanvas, gridCanvas;
  let isPlaying=false;

  window.addEventListener('load', async () => {
    map = L.map('map', {
      zoomControl:false,
      maxBounds: SICILY_BOUNDS.pad(0.5),
      maxBoundsViscosity: 0.8
    }).fitBounds(SICILY_BOUNDS);

    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 13, attribution: 'Esri', className:'dark-relief-tiles'
    }).addTo(map);

    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 19, opacity: 0.40, className:'dark-relief-tiles'
    }).addTo(map);

    map.createPane('labelsPane');
    map.getPane('labelsPane').style.zIndex = 600;
    map.getPane('labelsPane').style.pointerEvents = 'none';
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
      pane:'labelsPane', opacity:0.90
    }).addTo(map);

    map.createPane('particlePane');
    map.getPane('particlePane').style.zIndex = 800;
    map.getPane('particlePane').style.pointerEvents = 'none';

    createCanvasLayers();
    await loadCatalog();

    map.on('mousemove', onPick);
    map.on('click', onPick);
    map.on('moveend zoomend resize', redrawAll);

    updateToggleUI();
    document.getElementById('unit-display').innerText = '';
  });

  function createCanvasLayers(){
    const mk = (z, cls) => {
      const c = L.DomUtil.create('canvas', 'leaflet-layer ' + (cls||''));
      c.style.pointerEvents='none';
      c.style.zIndex=z;
      c.style.imageRendering='auto';
      map.getPanes().overlayPane.appendChild(c);
      return c;
    };
    scalarCanvases.wind  = mk(290,'scalar-layer');
    scalarCanvases.temp  = mk(300,'scalar-layer');
    scalarCanvases.rain  = mk(310,'scalar-layer');
    scalarCanvases.rh    = mk(320,'scalar-layer');
    scalarCanvases.press = mk(330,'scalar-layer');
    scalarCanvases.cloud = mk(340,'scalar-layer');

    arrowCanvas = mk(380);
    thermCanvas = mk(405);
    isoCanvas   = mk(420);
    gridCanvas  = mk(450);
  }

  async function loadCatalog(){
    try{
      const r=await fetch('data_weather/catalog.json?t='+Date.now());
      if(!r.ok) throw new Error();
      catalog=await r.json();
      const s=document.getElementById('time-slider');
      s.max=catalog.length-1;
      s.addEventListener('input', e=>loadStep(parseInt(e.target.value,10)));
      await loadStep(0);
    }catch(e){}
  }

  async function loadStep(i){
    if(!catalog[i]) return;
    document.getElementById('time-label').innerText = catalog[i].label;
    try{
      const r=await fetch('data_weather/'+catalog[i].file+'?t='+Date.now());
      if(!r.ok) return;
      currentData=await r.json();
      redrawAll();
    }catch(e){}
  }

  function redrawAll(){
    if(!currentData?.meta) return;
    drawScalars();
    drawWindArrows();
    drawIsotherms();
    drawIsobars();
    drawGrid();
    updateParticles();
  }

  function drawScalars(){
    const layers=['wind','temp','rain','rh','press','cloud'];
    for(const layer of layers){
      const canvas = scalarCanvases[layer];
      const ctx = canvas.getContext('2d');
      const sz = map.getSize();
      canvas.width=sz.x; canvas.height=sz.y;
      L.DomUtil.setPosition(canvas, map.containerPointToLayerPoint([0,0]));
      ctx.clearRect(0,0,sz.x,sz.y);

      if(!selected.has(layer)) continue;

      const m=currentData.meta;
      const off=document.createElement('canvas');
      off.width=m.nx; off.height=m.ny;
      const octx=off.getContext('2d');
      const img=octx.createImageData(m.nx,m.ny);
      const d=img.data;
      const n=m.nx*m.ny;

      for(let i=0;i<n;i++){
        let col={r:0,g:0,b:0,a:0};

        if(layer==='wind'){
          const u=currentData.wind_u.data[i], v=currentData.wind_v.data[i];
          const sp=Math.sqrt(u*u+v*v);
          if(sp<0.8){ d[i*4+3]=0; continue; }
          col=vividWindColor(sp); col.a=0.35;
        }
        else if(layer==='temp'){
          const val=currentData.temp[i];
          if(!isFinite(val)){ d[i*4+3]=0; continue; }
          const T = Math.round(clamp(val, T_MIN, T_MAX));
          const rgb = tempColorInt(T);
          col = {r:rgb.r, g:rgb.g, b:rgb.b, a:0.96};   // NETTO + pi√π evidente
        }
        else if(layer==='rain'){
          const val=currentData.rain[i] ?? 0;
          if(val<0.6){ d[i*4+3]=0; continue; }
          col=interpStops(val, RAIN_STOPS);
        }
        else if(layer==='rh'){
          const val=currentData.rh[i] ?? 0;
          col=interpStops(val, RH_STOPS); col.a=0.90;
        }
        else if(layer==='press'){
          const val=currentData.press[i] ?? 1013;
          col=interpStops(val, PRESS_STOPS); col.a=0.90;
        }
        else if(layer==='cloud'){
          const arr=getCloudArray();
          if(!arr){ d[i*4+3]=0; continue; }
          const val=arr[i] ?? 0;
          if(val<10){ d[i*4+3]=0; continue; }
          col=interpStops(val, CLOUD_STOPS);
        }

        const p=i*4;
        d[p]=col.r; d[p+1]=col.g; d[p+2]=col.b; d[p+3]=Math.round(clamp(col.a,0,1)*255);
      }

      octx.putImageData(img,0,0);

      const tl = map.latLngToContainerPoint([m.la1, m.lo1]);
      const br = map.latLngToContainerPoint([m.la2, m.lo2]);

      ctx.save();
      ctx.imageSmoothingEnabled=true;
      ctx.drawImage(off, tl.x, tl.y, br.x-tl.x, br.y-tl.y);
      ctx.restore();
    }
  }

  function drawWindArrows(){
    const ctx=arrowCanvas.getContext('2d');
    const sz=map.getSize();
    arrowCanvas.width=sz.x; arrowCanvas.height=sz.y;
    L.DomUtil.setPosition(arrowCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,sz.x,sz.y);

    if(!selected.has('wind') || !currentData?.meta) return;

    const m=currentData.meta;
    const zoom=map.getZoom();
    const stride = zoom>=10 ? 3 : (zoom>=9 ? 4 : 5);
    const baseLen = zoom>=10 ? 28 : 22;
    const baseW = 2.5;

    ctx.lineCap='round';
    ctx.lineJoin='round';

    for(let y=0;y<m.ny;y+=stride){
      const lat=m.la1 - y*m.dy;
      for(let x=0;x<m.nx;x+=stride){
        const idx=y*m.nx+x;
        const u=currentData.wind_u.data[idx], v=currentData.wind_v.data[idx];
        const sp=Math.sqrt(u*u+v*v);
        if(sp<1) continue;

        const lon=m.lo1 + x*m.dx;
        const p=map.latLngToContainerPoint([lat,lon]);

        const col=vividWindColor(sp);
        const fill=`rgb(${col.r},${col.g},${col.b})`;

        const s=clamp(sp/9.0,0.65,2.5);
        const len=baseLen*s;
        const w=baseW*s;
        const head=len*0.4;
        const headW=head*0.75;

        const ang=Math.atan2(-v,u);

        const shaftX=p.x + (len-head)*Math.cos(ang);
        const shaftY=p.y + (len-head)*Math.sin(ang);

        ctx.beginPath();
        ctx.moveTo(p.x,p.y);
        ctx.lineTo(shaftX,shaftY);
        ctx.strokeStyle="#000";
        ctx.lineWidth=w+2.5;
        ctx.stroke();

        ctx.strokeStyle=fill;
        ctx.lineWidth=w;
        ctx.stroke();

        const tipX=p.x + len*Math.cos(ang);
        const tipY=p.y + len*Math.sin(ang);

        const wing1X=shaftX - headW*Math.cos(ang - Math.PI/2);
        const wing1Y=shaftY - headW*Math.sin(ang - Math.PI/2);
        const wing2X=shaftX - headW*Math.cos(ang + Math.PI/2);
        const wing2Y=shaftY - headW*Math.sin(ang + Math.PI/2);

        ctx.beginPath();
        ctx.moveTo(tipX,tipY);
        ctx.lineTo(wing1X,wing1Y);
        ctx.lineTo(wing2X,wing2Y);
        ctx.closePath();
        ctx.fillStyle="#000";
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(tipX,tipY);
        ctx.lineTo(wing1X,wing1Y);
        ctx.lineTo(wing2X,wing2Y);
        ctx.closePath();
        ctx.fillStyle=fill;
        ctx.fill();
      }
    }
  }

  function updateParticles(){
    if(velocityLayer){ map.removeLayer(velocityLayer); velocityLayer=null; }
    if(!particlesOn || !currentData) return;

    velocityLayer = L.velocityLayer({
      pane:'particlePane',
      displayValues:false,
      data:[currentData.wind_u, currentData.wind_v],
      maxVelocity:20.0,
      velocityScale:0.008,
      particleMultiplier: 1/180,
      lineWidth:2.0,
      particleAge:100,
      frameRate:40,
      opacity:1.0,
      colorScale:WIND_COLOR_SCALE
    });

    velocityLayer.onAdd = function(map){
      L.VelocityLayer.prototype.onAdd.call(this,map);
      this._canvas.classList.add('velocity-canvas');
    };
    velocityLayer.addTo(map);
  }

  function drawIsotherms(){
    const ctx=thermCanvas.getContext('2d');
    const sz=map.getSize();
    thermCanvas.width=sz.x; thermCanvas.height=sz.y;
    L.DomUtil.setPosition(thermCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,sz.x,sz.y);

    if(!showIsotherms || !currentData?.temp || !currentData?.meta) return;
    const m=currentData.meta;
    const temp=currentData.temp;

    // Isoterme 1¬∞C, senza smoothing (coerenti con colori netti)
    const contours=d3.contours()
      .size([m.nx,m.ny])
      .thresholds(d3.range(T_MIN, T_MAX+1, 1))(temp);

    ctx.save();
    ctx.lineJoin="round";
    ctx.lineCap="round";
    ctx.textAlign="center";
    ctx.textBaseline="middle";

    contours.forEach(c=>{
      const T = Math.round(c.value);
      const major = (T % 5 === 0);
      const rgb = tempColorInt(T);
      const colored = `rgba(${rgb.r},${rgb.g},${rgb.b},${major?0.98:0.85})`;

      c.coordinates.forEach(poly=>{
        poly.forEach(ring=>{
          if(!ring || ring.length<2) return;

          // stroke bordo scuro
          ctx.beginPath();
          for(let i=0;i<ring.length;i++){
            const coord=ring[i];
            const lat=m.la1 - coord[1]*m.dy;
            const lon=m.lo1 + coord[0]*m.dx;
            const p=map.latLngToContainerPoint([lat,lon]);
            if(i===0) ctx.moveTo(p.x,p.y);
            else ctx.lineTo(p.x,p.y);
          }
          ctx.strokeStyle="rgba(0,0,0,0.65)";
          ctx.lineWidth=major?3.6:2.6;
          ctx.stroke();

          // stroke colorato netto
          ctx.strokeStyle=colored;
          ctx.lineWidth=major?2.2:1.3;
          ctx.stroke();

          // label solo sulle major (ogni 5¬∞C)
          if(major && ring.length>140){
            const mid=ring[Math.floor(ring.length/2)];
            const lat=m.la1 - mid[1]*m.dy;
            const lon=m.lo1 + mid[0]*m.dx;
            const p=map.latLngToContainerPoint([lat,lon]);
            const txt=T+"¬∞";
            ctx.font="950 14px Arial";
            ctx.lineWidth=6;
            ctx.strokeStyle="rgba(0,0,0,0.80)";
            ctx.strokeText(txt,p.x,p.y);
            ctx.fillStyle="rgba(255,255,255,0.96)";
            ctx.fillText(txt,p.x,p.y);
          }
        });
      });
    });

    ctx.restore();
  }

  function drawIsobars(){
    const ctx=isoCanvas.getContext('2d');
    const sz=map.getSize();
    isoCanvas.width=sz.x; isoCanvas.height=sz.y;
    L.DomUtil.setPosition(isoCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,sz.x,sz.y);

    if(!showIsobars || !currentData?.press || !currentData?.meta) return;
    const m=currentData.meta;

    const clean = new Float32Array(currentData.press.length);
    for(let i=0;i<clean.length;i++){
      const v=currentData.press[i];
      clean[i] = (!isFinite(v) || v<850 || v>1100) ? 1013 : v;
    }

    const contours=d3.contours().size([m.nx,m.ny]).thresholds(d3.range(960,1050,2))(clean);

    ctx.save();
    ctx.lineJoin="round";
    ctx.lineCap="round";
    ctx.font="900 12px Arial";
    ctx.textAlign="center";
    ctx.textBaseline="middle";

    const labelEvery=4;

    contours.forEach(c=>{
      const P=Math.round(c.value);
      const major = (P % labelEvery === 0);

      ctx.strokeStyle = major ? "rgba(255,255,255,0.80)" : "rgba(255,255,255,0.55)";
      ctx.lineWidth = major ? 2.0 : 1.2;

      c.coordinates.forEach(poly=>{
        poly.forEach(ring=>{
          if(!ring || ring.length<2) return;

          ctx.beginPath();
          for(let i=0;i<ring.length;i++){
            const coord=ring[i];
            const lat=m.la1 - coord[1]*m.dy;
            const lon=m.lo1 + coord[0]*m.dx;
            const p=map.latLngToContainerPoint([lat,lon]);
            if(i===0) ctx.moveTo(p.x,p.y);
            else ctx.lineTo(p.x,p.y);
          }
          ctx.stroke();

          if(major && ring.length>180){
            const mid=ring[Math.floor(ring.length/2)];
            const lat=m.la1 - mid[1]*m.dy;
            const lon=m.lo1 + mid[0]*m.dx;
            const p=map.latLngToContainerPoint([lat,lon]);
            ctx.fillStyle="rgba(0,0,0,0.62)";
            ctx.fillRect(p.x-16,p.y-8,32,16);
            ctx.fillStyle="rgba(255,255,255,0.95)";
            ctx.fillText(P,p.x,p.y);
          }
        });
      });
    });

    ctx.restore();
  }

  function drawGrid(){
    const ctx=gridCanvas.getContext('2d');
    const sz=map.getSize();
    gridCanvas.width=sz.x; gridCanvas.height=sz.y;
    L.DomUtil.setPosition(gridCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,sz.x,sz.y);
    if(!showGrid) return;

    const b=map.getBounds();
    const z=map.getZoom();
    let step=1.0; if(z>=9) step=0.5; if(z>=11) step=0.2;

    ctx.lineWidth=1;
    ctx.strokeStyle="rgba(255,255,255,0.18)";
    ctx.setLineDash([5,5]);

    const startLon=Math.ceil(b.getWest()/step)*step;
    for(let lon=startLon; lon<=b.getEast(); lon+=step){
      const x=map.latLngToContainerPoint([b.getSouth(),lon]).x;
      if(x<0||x>sz.x) continue;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,sz.y); ctx.stroke();
    }

    const startLat=Math.ceil(b.getSouth()/step)*step;
    for(let lat=startLat; lat<=b.getNorth(); lat+=step){
      const y=map.latLngToContainerPoint([lat,b.getWest()]).y;
      if(y<0||y>sz.y) continue;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(sz.x,y); ctx.stroke();
    }

    ctx.setLineDash([]);
  }

  window.toggleLayer = function(name){
    if(selected.has(name)) selected.delete(name); else selected.add(name);
    updateToggleUI(); redrawAll();
  }
  window.toggleIsobars = function(){ showIsobars=!showIsobars; updateToggleUI(); redrawAll(); }
  window.toggleIsotherms = function(){ showIsotherms=!showIsotherms; updateToggleUI(); redrawAll(); }
  window.toggleGrid = function(){ showGrid=!showGrid; updateToggleUI(); redrawAll(); }
  window.toggleParticles = function(){ particlesOn=!particlesOn; updateToggleUI(); redrawAll(); }

  function updateToggleUI(){
    document.querySelectorAll('.toggle').forEach(el=>{
      const t=el.innerText.toLowerCase();
      const on =
        (t.includes('vento') && selected.has('wind')) ||
        (t.includes('temp') && selected.has('temp')) ||
        (t.includes('pioggia') && selected.has('rain')) ||
        (t.includes('umidit√†') && selected.has('rh')) ||
        (t.includes('pressione') && selected.has('press')) ||
        (t.includes('nuvole') && selected.has('cloud')) ||
        (t.includes('isobare') && showIsobars) ||
        (t.includes('isoterme') && showIsotherms) ||
        (t.includes('reticolo') && showGrid);

      if(on) el.classList.add('active'); else el.classList.remove('active');
    });

    const btnFlow=document.getElementById('btn-flow');
    if(particlesOn) btnFlow.classList.add('active'); else btnFlow.classList.remove('active');

    document.getElementById('wind-rose').style.display = selected.has('wind') ? 'flex' : 'none';
  }

  function onPick(e){
    if(!currentData?.meta) return;
    const m=currentData.meta;
    const y=Math.round((m.la1 - e.latlng.lat)/m.dy);
    const x=Math.round((e.latlng.lng - m.lo1)/m.dx);
    if(x<0||x>=m.nx||y<0||y>=m.ny) return;
    const idx=y*m.nx+x;

    let val='--', unit='';
    if(selected.has('rain')) { val=(currentData.rain[idx]??0).toFixed(1); unit='mm'; }
    else if(selected.has('temp')) { val=(currentData.temp[idx]??0).toFixed(1); unit='¬∞C'; }
    else if(selected.has('wind')) {
      const u=currentData.wind_u.data[idx], v=currentData.wind_v.data[idx];
      val=(Math.sqrt(u*u+v*v)*3.6).toFixed(1); unit='km/h';
      const deg = 90 - (Math.atan2(v,u)*180/Math.PI);
      document.getElementById('rose-arrow').style.transform=`rotate(${deg}deg)`;
    }
    else if(selected.has('rh')) { val=Math.round(currentData.rh[idx]??0); unit='%'; }
    else if(selected.has('press')) { val=Math.round(currentData.press[idx]??0); unit='hPa'; }
    else if(selected.has('cloud')) { val=Math.round((getCloudArray()?.[idx]??0)); unit='%'; }

    document.getElementById('val-display').innerText=val;
    document.getElementById('unit-display').innerText=unit;
  }

  window.togglePlay = function(){
    if(isPlaying){ isPlaying=false; document.getElementById('play-btn').innerText='‚ñ∫'; return; }
    isPlaying=true; document.getElementById('play-btn').innerText='‚ùö‚ùö';
    const s=document.getElementById('time-slider');
    let i=parseInt(s.value,10);
    const loop=setInterval(()=>{
      const max=parseInt(s.max,10);
      if(!isPlaying || i>=max){
        clearInterval(loop);
        isPlaying=false;
        document.getElementById('play-btn').innerText='‚ñ∫';
        return;
      }
      i++; s.value=i; loadStep(i);
    },800);
  }
</script>
</body>
</html>