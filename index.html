<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - PRO (MULTI-LAYER SMART)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin: 0; background: #050505; font-family: 'Segoe UI', Roboto, sans-serif; color: white; overflow: hidden; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #050505; }

    /* INFO */
    #info-box {
      position: absolute; top: 20px; left: 20px; z-index: 1300;
      pointer-events: none; text-shadow: 2px 2px 0 #000;
    }
    #val-display { font-size: 3.8em; font-weight: 900; line-height: 0.95; }
    #unit-display { font-size: 1.2em; color: #aaa; font-weight: 800; }

    /* UI */
    #ui-container {
      position: absolute; top: 10px; right: 10px; z-index: 1300;
      display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
    }
    .panel {
      background: rgba(0,0,0,0.82);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: 0 10px 30px rgba(0,0,0,0.55);
    }

    /* Basemap selector (DARK / SAT) */
    #basemap-selector { display:flex; gap:6px; justify-content:flex-end; }
    .base-btn {
      background: rgba(255,255,255,0.06);
      color: #cfcfcf;
      border: 1px solid rgba(255,255,255,0.14);
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 900;
      transition: all .15s;
      user-select: none;
    }
    .base-btn:hover { background: rgba(255,255,255,0.12); color:#fff; }
    .base-btn.active {
      background: #0088ff;
      border-color: rgba(0,136,255,0.45);
      color: #fff;
      box-shadow: 0 0 18px rgba(0,136,255,0.25);
    }

    .layer-btn {
      display: block; width: 170px;
      padding: 10px 12px; margin-bottom: 6px;
      background: transparent; color: #cfcfcf; border: none; text-align: right;
      cursor: pointer; font-size: 13px; font-weight: 800; border-radius: 10px;
      transition: all 0.15s;
      letter-spacing: 0.2px;
      user-select: none;
    }
    .layer-btn:hover { background: rgba(255,255,255,0.08); color: #fff; }
    .layer-btn.active {
      background: linear-gradient(90deg, #0055ff, #0022aa);
      color: white;
      box-shadow: 0 0 18px rgba(0, 80, 255, 0.35);
      border: 1px solid rgba(120, 200, 255, 0.35);
    }
    .layer-btn.toggle {
      margin-top: 6px;
      border-top: 1px solid rgba(255,255,255,0.10);
      padding-top: 12px;
      color: #aaa;
    }
    .layer-btn.toggle.active {
      background: rgba(255,255,255,0.16);
      color: #fff;
      box-shadow: none;
      border: 1px solid rgba(255,255,255,0.22);
    }

    /* STATUS */
    #status-box {
      position: absolute; bottom: 110px; left: 20px; z-index: 3000;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px; color: #ff6b6b;
      background: rgba(20,0,0,0.88); padding: 10px 12px; border-radius: 8px;
      border: 1px solid rgba(255,80,80,0.28);
      display: none;
      max-width: 92vw;
    }

    /* BOTTOM BAR */
    #bottom-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: 96px;
      background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
      display: flex; align-items: center; padding: 0 18px; z-index: 2000;
    }
    #play-btn {
      font-size: 2.7em; background: none; border: none; color: white;
      cursor: pointer; margin-right: 16px;
      filter: drop-shadow(0 0 6px rgba(255,255,255,0.3));
    }
    #time-label {
      font-size: 1.35em; font-weight: 900; margin-left: 14px;
      min-width: 150px; text-align: center; text-shadow: 0 2px 12px #000;
      font-variant-numeric: tabular-nums;
    }
    input[type=range] {
      flex-grow: 1; height: 6px; cursor: pointer; background: #333; border-radius: 4px;
      -webkit-appearance: none; appearance: none;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%;
      background: #0088ff; border: 2px solid white; margin-top: -7px;
    }

    canvas { image-rendering: auto; }
    .leaflet-control-attribution { opacity: 0.7; }
  </style>
</head>

<body>
  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">Caricamento...</div>
  </div>

  <div id="status-box"></div>

  <div id="ui-container">
    <div class="panel">
      <div id="basemap-selector">
        <button class="base-btn active" onclick="setBaseMap('dark')">DARK</button>
        <button class="base-btn" onclick="setBaseMap('sat')">SATELLITE</button>
      </div>
    </div>

    <div class="panel">
      <button class="layer-btn active" data-layer="wind" onclick="toggleLayer(this)">VENTO üí®</button>
      <button class="layer-btn" data-layer="temp" onclick="toggleLayer(this)">TEMP üå°Ô∏è</button>
      <button class="layer-btn" data-layer="rain" onclick="toggleLayer(this)">PIOGGIA ‚òî</button>
      <button class="layer-btn" data-layer="rh" onclick="toggleLayer(this)">UMIDIT√Ä üíß</button>
      <button class="layer-btn" data-layer="press" onclick="toggleLayer(this)">PRESSIONE üß≠</button>
      <button class="layer-btn" data-layer="cloud" onclick="toggleLayer(this)">NUVOLE ‚òÅÔ∏è</button>

      <button class="layer-btn toggle" id="btn-iso" onclick="toggleIso()">ISOBARE „Ä∞Ô∏è</button>
      <button class="layer-btn toggle" id="btn-grid" onclick="toggleGrid()">GRIGLIA #</button>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  function status(msg) {
    const el = document.getElementById('status-box');
    el.innerText = msg;
    el.style.display = 'block';
  }

  // --- GLOBALS ---
  let map, velocityLayer;
  let heatCanvas, isoCanvas, gridCanvas;
  let currentData = null, catalog = [];
  let showIso = false, showGrid = false, isPlaying = false;

  // Basemap
  let darkBase, satBase, darkLabels;
  let baseMode = 'dark';
  let isLightBasemap = false; // satellite = pi√π chiaro

  // Multi-layer state
  const activeLayers = new Set(['wind']);
  let primaryLayer = 'wind';

  // --- PALETTES ---
  const PALETTES = {
    temp: [
      {v:-10,c:[255,255,255,0.60]},
      {v:0,  c:[200,200,255,0.60]},
      {v:10, c:[0,200,100,0.60]},
      {v:20, c:[255,255,0,0.60]},
      {v:30, c:[255,140,0,0.60]},
      {v:40, c:[200,0,0,0.60]}
    ],
    rain: [
      {v:0,   c:[0,0,0,0]},
      {v:0.05,c:[0,200,255,0.55]},
      {v:2,   c:[0,0,255,0.70]},
      {v:10,  c:[150,0,200,0.82]}
    ],
    rh: [
      {v:20,c:[200,150,50,0.55]},
      {v:40,c:[200,200,200,0.55]},
      {v:60,c:[100,255,100,0.55]},
      {v:80,c:[50,150,255,0.60]},
      {v:95,c:[0,0,200,0.65]}
    ],
    press: [
      {v:980, c:[0,70,255,0.55]},
      {v:995, c:[0,170,255,0.55]},
      {v:1005,c:[0,255,200,0.55]},
      {v:1013,c:[255,255,255,0.55]},
      {v:1022,c:[255,200,0,0.55]},
      {v:1035,c:[255,60,0,0.60]}
    ],
    cloud: [
      {v:0,   c:[255,255,255,0.00]},
      {v:20,  c:[255,255,255,0.20]},
      {v:40,  c:[230,230,230,0.32]},
      {v:60,  c:[190,190,190,0.45]},
      {v:80,  c:[120,120,120,0.60]},
      {v:100, c:[70,70,70,0.72]}
    ]
  };

  const LAYER_WEIGHT = { cloud: 0.55, press: 0.70, rh: 0.75, temp: 0.85, rain: 0.95 };

  // WIND color scales:
  const WIND_COLOR_DARK = ["#000080", "#0044ff", "#00ddff", "#00ff55", "#ffff00", "#ff6600", "#ff0000", "#ff00ff"];

  // SAT: pi√π contrasto e pi√π scuri (si leggono su satellite chiaro)
  const WIND_COLOR_SAT_CONTRAST = [
    "#001022", // blu quasi nero
    "#002a88", // blu scuro
    "#0044ff", // blu
    "#00b7ff", // azzurro pi√π saturo (non pallido)
    "#00cc55", // verde pi√π scuro
    "#ffd000", // giallo acceso
    "#ff5a00", // arancio forte
    "#ff0033", // rosso forte
    "#b000ff"  // viola
  ];

  function lerp(a,b,t){ return a+(b-a)*t; }

  function getColor(val, type) {
    const p = PALETTES[type];
    if(!p) return [0,0,0,0];
    if(type==='rain' && val < 0.05) return [0,0,0,0];

    for(let i=0; i<p.length-1; i++) {
      if(val >= p[i].v && val <= p[i+1].v) {
        const t = (val - p[i].v) / (p[i+1].v - p[i].v);
        const c1 = p[i].c, c2 = p[i+1].c;
        return [
          Math.round(lerp(c1[0], c2[0], t)),
          Math.round(lerp(c1[1], c2[1], t)),
          Math.round(lerp(c1[2], c2[2], t)),
          lerp(c1[3], c2[3], t)
        ];
      }
    }
    const last = p[p.length-1].c;
    return [last[0], last[1], last[2], last[3]];
  }

  function unitFor(type){
    if(type==='wind') return 'km/h';
    if(type==='temp') return '¬∞C';
    if(type==='rain') return 'mm';
    if(type==='rh') return '%';
    if(type==='press') return 'hPa';
    if(type==='cloud') return '%';
    return '';
  }

  // --- INIT ---
  window.addEventListener('load', async function() {
    try {
      map = L.map('map', { zoomControl: false }).setView([37.5, 14.2], 8);

      darkBase = L.tileLayer(
        'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png',
        { maxZoom: 19, attribution: '¬©OpenStreetMap, ¬©CARTO' }
      ).addTo(map);

      satBase = L.tileLayer(
        'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        { maxZoom: 19, attribution: 'Tiles ¬© Esri' }
      );

      darkLabels = L.tileLayer(
        'https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png',
        { maxZoom: 19, attribution: '¬©CARTO' }
      ).addTo(map);

      darkBase.on('tileerror', () => status("Tile DARK non caricate (server/URL)."));
      satBase.on('tileerror', () => status("Tile SATELLITE non caricate (server/URL)."));

      createCanvasLayers();
      await loadCatalogAndFirstFrame();

      map.on('mousemove', updatePickerFromEvent);
      map.on('click', updatePickerFromEvent);

      document.getElementById('unit-display').innerText = unitFor(primaryLayer);
    } catch(e) {
      status("Errore init mappa: " + (e && e.message ? e.message : e));
    }
  });

  // --- BASEMAP TOGGLE ---
  window.setBaseMap = function(mode) {
    document.querySelectorAll('.base-btn').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');

    if(mode === 'dark') {
      baseMode = 'dark';
      isLightBasemap = false;
      map.removeLayer(satBase);
      darkBase.addTo(map);
      if(darkLabels) darkLabels.addTo(map);
    } else {
      baseMode = 'sat';
      isLightBasemap = true;
      map.removeLayer(darkBase);
      satBase.addTo(map);
      if(darkLabels) darkLabels.addTo(map); // labels aiutano orientamento
    }

    redrawAll();
  };

  // --- DATA LOAD ---
  async function loadCatalogAndFirstFrame() {
    try {
      const r = await fetch('data_weather/catalog.json?t=' + Date.now());
      if(!r.ok) throw new Error("catalog.json non trovato");
      catalog = await r.json();
      if(!catalog || catalog.length === 0) throw new Error("catalog vuoto");

      const slider = document.getElementById('time-slider');
      slider.max = catalog.length - 1;
      slider.value = 0;
      slider.addEventListener('input', (e) => loadStep(parseInt(e.target.value,10)));

      await loadStep(0);
      document.getElementById('unit-display').innerText = "Pronto";
    } catch(e) {
      status("Errore dati: " + (e && e.message ? e.message : e));
      document.getElementById('unit-display').innerText = "Errore dati";
    }
  }

  async function loadStep(idx) {
    if(!catalog[idx]) return;
    document.getElementById('time-label').innerText = catalog[idx].label;

    try {
      const r = await fetch('data_weather/' + catalog[idx].file + '?t=' + Date.now());
      if(!r.ok) throw new Error("frame non trovato");
      currentData = await r.json();
      redrawAll();
    } catch(e) {
      status("Errore frame: " + (e && e.message ? e.message : e));
    }
  }

  // --- CANVAS LAYERS ---
  function createCanvasLayers() {
    const mkCanvas = (z) => {
      const c = L.DomUtil.create('canvas', 'leaflet-layer');
      c.style.pointerEvents = 'none';
      c.style.zIndex = z;
      map.getPanes().overlayPane.appendChild(c);
      return c;
    };
    heatCanvas = mkCanvas(300);
    isoCanvas  = mkCanvas(400);
    gridCanvas = mkCanvas(450);

    map.on('moveend resize', redrawAll);
  }

  function redrawAll() {
    if(!currentData) return;
    drawHeatmapMulti();
    drawIsobars();
    drawGrid();
    updateWind();
  }

  // --- SMART OPACITY ---
  function computeAlphaMultipliers() {
    const heatActives = Array.from(activeLayers).filter(l => l !== 'wind');
    const n = heatActives.length;
    if(n === 0) return { multipliers: {}, heatGlobal: 1.0 };

    let sumW = 0;
    heatActives.forEach(l => { sumW += (LAYER_WEIGHT[l] ?? 0.75); });

    const windOn = activeLayers.has('wind');
    let heatGlobal = windOn ? 0.78 : 1.0;

    // Satellite: rendiamo pi√π evidente (tu hai chiesto pi√π opaco),
    // ma senza coprire il vento: aumento moderato + bilanciamento per layer.
    if(isLightBasemap) heatGlobal *= 1.12;

    const multipliers = {};
    heatActives.forEach(l => {
      const w = (LAYER_WEIGHT[l] ?? 0.75);
      let m = (w / sumW);
      m *= 1.55;
      m = Math.max(0.20, Math.min(0.85, m));

      // nuvole sempre pi√π ‚Äúleggere‚Äù
      if(l === 'cloud' && n >= 2) m *= 0.70;
      if(l === 'cloud' && windOn) m *= 0.75;

      // SAT: alziamo un po' TEMP (richiesta), e teniamo cloud pi√π controllata
      if(isLightBasemap && l === 'temp') m *= 1.18;
      if(isLightBasemap && l === 'press') m *= 1.08;
      if(isLightBasemap && l === 'rain') m *= 1.10;
      if(isLightBasemap && (l === 'cloud' || l === 'rh')) m *= 0.85;

      multipliers[l] = Math.max(0.14, Math.min(0.90, m));
    });

    return { multipliers, heatGlobal };
  }

  // --- MULTI-HEATMAP ---
  function drawHeatmapMulti() {
    const ctx = heatCanvas.getContext('2d');
    const s = map.getSize();
    heatCanvas.width = s.x;
    heatCanvas.height = s.y;
    L.DomUtil.setPosition(heatCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    if(!currentData) return;

    const m = currentData.meta;
    const b = map.getBounds();

    const heatActives = Array.from(activeLayers).filter(l => l !== 'wind');
    if(heatActives.length === 0) return;

    const { multipliers, heatGlobal } = computeAlphaMultipliers();
    const ORDER = ['cloud', 'press', 'rh', 'temp', 'rain'];
    const layersToDraw = ORDER.filter(x => heatActives.includes(x));

    for(let y=0; y<m.ny; y++) {
      const lat = m.la1 - (y*m.dy);
      if(lat < b.getSouth()-0.12 || lat > b.getNorth()+0.12) continue;

      for(let x=0; x<m.nx; x++) {
        const lon = m.lo1 + (x*m.dx);
        if(lon < b.getWest()-0.12 || lon > b.getEast()+0.12) continue;

        const idx = y*m.nx + x;

        const p1 = map.latLngToContainerPoint([lat, lon]);
        const p2 = map.latLngToContainerPoint([lat - m.dy, lon + m.dx]);
        const w = Math.ceil(p2.x - p1.x) + 1;
        const h = Math.ceil(p2.y - p1.y) + 1;

        for(const layer of layersToDraw) {
          let val = 0;

          if(layer==='temp') val = currentData.temp?.[idx] ?? 0;
          else if(layer==='rain') val = currentData.rain?.[idx] ?? 0;
          else if(layer==='rh') val = currentData.rh?.[idx] ?? 0;
          else if(layer==='press') val = currentData.press?.[idx] ?? 1013;
          else if(layer==='cloud') {
            const arr = currentData.cloud || currentData.tcc || currentData.cld;
            val = arr?.[idx] ?? 0;
          }

          let c = getColor(val, layer);
          if(c[3] <= 0) continue;

          let a = c[3] * (multipliers[layer] ?? 0.5) * heatGlobal;

          // Se piove forte e rain √® attivo, riduci gli altri un pelo
          if(layer !== 'rain' && (currentData.rain?.[idx] ?? 0) >= 2 && activeLayers.has('rain')) {
            a *= 0.82;
          }

          a = Math.max(0, Math.min(0.92, a));
          if(a <= 0.01) continue;

          ctx.fillStyle = `rgba(${c[0]},${c[1]},${c[2]},${a})`;
          ctx.fillRect(Math.floor(p1.x), Math.floor(p1.y), w, h);
        }
      }
    }
  }

  // --- ISOBARE: dark bianche, satellite nere ---
  function drawIsobars() {
    const ctx = isoCanvas.getContext('2d');
    const s = map.getSize();
    isoCanvas.width = s.x;
    isoCanvas.height = s.y;
    L.DomUtil.setPosition(isoCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    if(!showIso || !currentData || !currentData.press) return;

    const m = currentData.meta;
    const values = currentData.press;

    const contours = d3.contours()
      .size([m.nx, m.ny])
      .thresholds(d3.range(960, 1050, 2))(values);

    ctx.lineWidth = isLightBasemap ? 1.5 : 1.4;
    ctx.font = "900 12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    contours.forEach(c => {
      ctx.strokeStyle = isLightBasemap ? "rgba(0,0,0,0.78)" : "rgba(255,255,255,0.80)";

      ctx.beginPath();
      const labelCandidates = [];

      c.coordinates.forEach(ring => {
        ring.forEach(pts => {
          let first = true;
          const linePts = [];
          pts.forEach(coord => {
            const lat = m.la1 - (coord[1] * m.dy);
            const lon = m.lo1 + (coord[0] * m.dx);
            const p = map.latLngToContainerPoint([lat, lon]);
            linePts.push(p);
            if(first) { ctx.moveTo(p.x, p.y); first=false; }
            else ctx.lineTo(p.x, p.y);
          });
          if(linePts.length > 70) labelCandidates.push(linePts);
        });
      });

      ctx.stroke();

      labelCandidates.forEach(pts => {
        const mid = pts[Math.floor(pts.length/2)];
        const bg = isLightBasemap ? "rgba(255,255,255,0.75)" : "rgba(0,0,0,0.55)";
        const fg = isLightBasemap ? "#000" : "#fff";
        ctx.fillStyle = bg;
        ctx.fillRect(mid.x-16, mid.y-9, 32, 18);
        ctx.fillStyle = fg;
        ctx.fillText(Math.round(c.value), mid.x, mid.y);
      });
    });
  }

  // --- GRIGLIA (solo linee) ---
  function drawGrid() {
    const ctx = gridCanvas.getContext('2d');
    const s = map.getSize();
    gridCanvas.width = s.x;
    gridCanvas.height = s.y;
    L.DomUtil.setPosition(gridCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    if(!showGrid) return;

    const b = map.getBounds();
    const step = map.getZoom() > 9 ? 0.1 : 0.5;

    ctx.strokeStyle = isLightBasemap ? "rgba(0,0,0,0.18)" : "rgba(255,255,255,0.15)";
    ctx.lineWidth = 1;

    for(let lon=Math.floor(b.getWest()); lon<=Math.ceil(b.getEast()); lon+=step) {
      const x = map.latLngToContainerPoint([b.getSouth(), lon]).x;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,s.y); ctx.stroke();
    }
    for(let lat=Math.floor(b.getSouth()); lat<=Math.ceil(b.getNorth()); lat+=step) {
      const y = map.latLngToContainerPoint([lat, b.getWest()]).y;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(s.x,y); ctx.stroke();
    }
  }

  // --- WIND: pi√π contrasto su SAT ---
  function updateWind() {
    if(velocityLayer) map.removeLayer(velocityLayer);
    if(!activeLayers.has('wind') || !currentData) return;

    const isMobile = Math.min(window.innerWidth, window.innerHeight) < 900;
    const dpr = window.devicePixelRatio || 1;

    let particleMult = isMobile ? (1/160) : (1/120);
    if(dpr >= 2) particleMult = isMobile ? (1/220) : (1/180);

    // Su satellite: linee pi√π spesse + pi√π opache per distinguere
    const lw = isLightBasemap ? 1.25 : 0.8;
    const op = isLightBasemap ? 0.995 : 0.95;
    const colors = isLightBasemap ? WIND_COLOR_SAT_CONTRAST : WIND_COLOR_DARK;

    try {
      velocityLayer = L.velocityLayer({
        displayValues: false,
        data: [ currentData.wind_u, currentData.wind_v ],

        // parametri originali
        maxVelocity: 18.0,
        velocityScale: 0.006,
        particleMultiplier: particleMult,
        lineWidth: lw,
        particleAge: 140,
        frameRate: 60,
        opacity: op,
        colorScale: colors
      });

      velocityLayer.addTo(map);
    } catch(e) {
      status("Errore wind layer: " + (e && e.message ? e.message : e));
    }
  }

  // --- PICKER (primaryLayer) ---
  function valueAtLatLng(latlng, whichLayer) {
    if(!currentData || !currentData.meta) return null;
    const m = currentData.meta;

    const y = Math.round((m.la1 - latlng.lat) / m.dy);
    const x = Math.round((latlng.lng - m.lo1) / m.dx);

    if(x < 0 || x >= m.nx || y < 0 || y >= m.ny) return null;
    const idx = y*m.nx + x;

    if(whichLayer === 'wind') {
      const u = currentData.wind_u?.data?.[idx];
      const v = currentData.wind_v?.data?.[idx];
      if(u === undefined || v === undefined) return null;
      return (Math.sqrt(u*u + v*v) * 3.6);
    }
    if(whichLayer === 'temp') return currentData.temp?.[idx];
    if(whichLayer === 'rain') return currentData.rain?.[idx];
    if(whichLayer === 'rh') return currentData.rh?.[idx];
    if(whichLayer === 'press') return currentData.press?.[idx];
    if(whichLayer === 'cloud') {
      const arr = currentData.cloud || currentData.tcc || currentData.cld;
      return arr?.[idx];
    }
    return null;
  }

  function updatePickerFromEvent(e) {
    let pickLayer = primaryLayer;
    if(!activeLayers.has(pickLayer)) {
      pickLayer = activeLayers.has('wind') ? 'wind' : (Array.from(activeLayers)[0] || 'wind');
    }

    const val = valueAtLatLng(e.latlng, pickLayer);
    if(val === null || val === undefined || Number.isNaN(val)) return;

    let out = '--';
    if(pickLayer === 'wind') out = val.toFixed(1);
    else if(pickLayer === 'temp') out = Number(val).toFixed(1);
    else if(pickLayer === 'rain') out = Number(val).toFixed(1);
    else if(pickLayer === 'rh') out = Math.round(Number(val)).toString();
    else if(pickLayer === 'press') out = Math.round(Number(val)).toString();
    else if(pickLayer === 'cloud') out = Math.round(Number(val)).toString();

    document.getElementById('val-display').innerText = out;
    document.getElementById('unit-display').innerText = unitFor(pickLayer);
  }

  // --- UI ACTIONS ---
  window.toggleLayer = function(btn) {
    const layer = btn.getAttribute('data-layer');
    if(!layer) return;

    if(activeLayers.has(layer)) {
      activeLayers.delete(layer);
      btn.classList.remove('active');
    } else {
      activeLayers.add(layer);
      btn.classList.add('active');
    }

    primaryLayer = layer;
    document.getElementById('unit-display').innerText = unitFor(primaryLayer);
    document.getElementById('val-display').innerText = '--';

    redrawAll();
  };

  window.toggleIso = function() {
    showIso = !showIso;
    document.getElementById('btn-iso').classList.toggle('active');
    redrawAll();
  };

  window.toggleGrid = function() {
    showGrid = !showGrid;
    document.getElementById('btn-grid').classList.toggle('active');
    redrawAll();
  };

  window.togglePlay = function() {
    if(isPlaying) { isPlaying = false; document.getElementById('play-btn').innerText = "‚ñ∫"; return; }
    isPlaying = true;

    const s = document.getElementById('time-slider');
    const btn = document.getElementById('play-btn');
    btn.innerText = "‚ùö‚ùö";

    let i = parseInt(s.value, 10);
    const max = parseInt(s.max, 10);

    const interval = setInterval(() => {
      if(!isPlaying) { clearInterval(interval); btn.innerText = "‚ñ∫"; return; }
      if(i >= max) { clearInterval(interval); isPlaying=false; btn.innerText="‚ñ∫"; return; }
      i++;
      s.value = i;
      loadStep(i);
    }, 800);
  };
</script>

</body>
</html>
```Ó®Å0Ó®Ç