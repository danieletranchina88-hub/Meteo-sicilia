<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - PRO (Continuous Gradients)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin:0; background:#111; font-family:'Segoe UI', sans-serif; color:#fff; overflow:hidden; }
    #map { position:absolute; inset:0; background:#111; }

    #ui-container { position:absolute; top:10px; right:10px; z-index:1000; display:flex; flex-direction:column; gap:10px; align-items:flex-end; }
    .panel { background:rgba(0,0,0,0.86); backdrop-filter:blur(6px); padding:8px; border-radius:14px; border:1px solid #444; }

    .layer-btn{
      display:block; width:165px; padding:10px 12px; margin-bottom:6px;
      background:transparent; color:#d0d0d0; border:none; text-align:right;
      cursor:pointer; font-size:13px; font-weight:900; border-radius:8px;
      transition:all 0.15s; user-select:none;
    }
    .layer-btn:hover { background:rgba(255,255,255,0.08); color:#fff; }
    .layer-btn.active { background:#007bff; color:#fff; }
    .layer-btn.small { width:165px; font-weight:850; opacity:0.95; }

    .map-toggle{
      padding:8px 12px; background:rgba(255,255,255,0.06); color:#fff;
      border:1px solid rgba(255,255,255,0.2); border-radius:10px;
      cursor:pointer; font-size:12px; font-weight:900;
      transition:all 0.15s; user-select:none;
    }
    .map-toggle:hover { background:rgba(255,255,255,0.12); }
    .map-toggle.active { background:#eee; color:#000; }

    #info-box { position:absolute; top:18px; left:18px; z-index:1000; pointer-events:none; text-shadow:2px 2px 0 #000; }
    #val-display { font-size:3.5em; font-weight:900; line-height:1; }
    #unit-display { font-size:1.15em; color:#bbb; font-weight:900; }

    #bottom-bar{
      position:absolute; bottom:0; left:0; right:0; height:90px;
      background:linear-gradient(to top, rgba(0,0,0,0.95), transparent);
      display:flex; align-items:center; padding:0 20px; z-index:2000;
    }
    #play-btn{ font-size:2.5em; background:none; border:none; color:#fff; cursor:pointer; margin-right:15px; }
    #time-label{ font-size:1.4em; font-weight:900; margin-left:15px; min-width:140px; text-align:center; text-shadow:0 2px 10px #000; }
    input[type=range]{ flex-grow:1; height:5px; cursor:pointer; accent-color:#0088ff; }

    .hillshade-tiles{
      mix-blend-mode:multiply;
      filter:contrast(1.85) brightness(0.95);
    }
    canvas { image-rendering:auto; }
  </style>
</head>

<body>
  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">Caricamento...</div>
  </div>

  <div id="ui-container">
    <div class="panel" style="display:flex; gap:6px;">
      <button class="map-toggle active" onclick="setBase('dark')">DARK</button>
      <button class="map-toggle" onclick="setBase('sat')">SAT</button>
    </div>

    <div class="panel">
      <button class="layer-btn active" data-layer="wind"  onclick="toggleLayer('wind', event)">VENTO üí®</button>
      <button class="layer-btn"        data-layer="temp"  onclick="toggleLayer('temp', event)">TEMP üå°Ô∏è</button>
      <button class="layer-btn"        data-layer="rain"  onclick="toggleLayer('rain', event)">PIOGGIA ‚òî</button>
      <button class="layer-btn"        data-layer="rh"    onclick="toggleLayer('rh', event)">UMIDIT√Ä üíß</button>
      <button class="layer-btn"        data-layer="press" onclick="toggleLayer('press', event)">PRESS ‚è≤Ô∏è</button>
      <button class="layer-btn"        data-layer="cloud" onclick="toggleLayer('cloud', event)">NUVOLE ‚òÅÔ∏è</button>

      <hr style="border:0; border-top:1px solid #444; margin:6px 0;">
      <button class="layer-btn small" id="btn-iso"  onclick="toggleIso()">ISOBARE „Ä∞Ô∏è</button>
      <button class="layer-btn small" id="btn-grid" onclick="toggleGrid()">GRIGLIA #</button>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  var map, velocityLayer;
  var heatCanvas, isoCanvas, gridCanvas;

  var currentData = null, catalog = [];
  var showIso = false, showGrid = false, isPlaying = false;

  var enabledLayers = new Set(['wind']);
  var pickerLayer = 'wind';
  var lastFrameInterval = null;

  var baseLayers = {};
  var labelLayers = {};
  var hillshadeLayer = null;
  var isLightMode = false;

  // === Opacit√†: trasparente ma leggibile (su SAT aumentiamo un filo) ===
  const LAYER_OPACITY = {
    temp:  0.60,
    press: 0.55,
    rain:  0.70,
    rh:    0.55,
    cloud: 0.42
  };

  // ==== UTIL: clamp + lerp + interpolateColor ====
  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpColor(c1,c2,t){
    return [
      Math.round(lerp(c1[0], c2[0], t)),
      Math.round(lerp(c1[1], c2[1], t)),
      Math.round(lerp(c1[2], c2[2], t))
    ];
  }

  // ==== PALETTE CONTINUE (color stops) ====
  // NB: puoi cambiare min/max e stop senza toccare il resto.
  const CONTINUOUS = {
    // TEMP: viola -> blu -> ciano -> verde -> giallo -> arancio -> rosso -> rosso scuro
    // Range consigliato per Sicilia: -10..45 (ma regge oltre con clamp)
    temp: {
  min: -15, max: 45,
  stops: [
    {v:-15, c:[ 70,  0, 160]}, // viola freddo
    {v:-12, c:[ 55,  0, 190]}, // viola/blu
    {v:-10, c:[ 20, 40, 255]}, // blu
    {v: -8, c:[  0, 90, 255]}, // blu pi√π chiaro
    {v: -6, c:[  0,140, 255]}, // azzurro
    {v: -4, c:[  0,190, 255]}, // ciano
    {v: -2, c:[  0,240, 255]}, // ciano chiaro

    {v:  0, c:[  0,255, 220]}, // ciano/verde acqua
    {v:  2, c:[  0,255, 170]}, // verde acqua
    {v:  4, c:[  0,255, 120]}, // verde
    {v:  6, c:[ 60,255,  60]}, // verde chiaro
    {v:  8, c:[120,255,   0]}, // giallo-verde
    {v: 10, c:[170,255,   0]}, // giallo-verde caldo
    {v: 12, c:[220,255,   0]}, // giallo

    {v: 14, c:[255,245,   0]}, // giallo caldo
    {v: 16, c:[255,220,   0]}, // giallo/arancio
    {v: 18, c:[255,200,   0]}, // arancio chiaro
    {v: 20, c:[255,175,   0]}, // arancio
    {v: 22, c:[255,150,   0]}, // arancio forte
    {v: 24, c:[255,120,   0]}, // arancio/rosso
    {v: 26, c:[255, 95,   0]}, // rosso-arancio

    {v: 28, c:[255, 70,   0]}, // rosso-arancio pi√π caldo
    {v: 30, c:[255, 45,   0]}, // rosso
    {v: 32, c:[255, 20,   0]}, // rosso vivo
    {v: 34, c:[255,  0,   0]}, // rosso pieno
    {v: 36, c:[230,  0,   0]}, // rosso scuro
    {v: 38, c:[205,  0,   0]}, // rosso pi√π scuro
    {v: 40, c:[180,  0,   0]}, // rosso scurissimo
    {v: 42, c:[160,  0,   0]}, // quasi bordeaux
    {v: 45, c:[140,  0,   0]}  // molto caldo (rosso scuro)
  ]
},

    // PRESS (hPa): blu (bassa) -> ciano -> verde -> giallo -> arancio -> rosso (alta)
    press: {
      min: 980, max: 1040,
      stops: [
        {v: 980, c:[  0, 70,255]},
        {v: 995, c:[  0,190,255]},
        {v:1005, c:[  0,255,200]},
        {v:1013, c:[255,255,255]},
        {v:1022, c:[255,210,  0]},
        {v:1030, c:[255,120,  0]},
        {v:1040, c:[255,  0,  0]}
      ]
    },

    // RAIN (mm): 0 trasparente, poi ciano -> blu -> viola -> magenta
    rain: {
      min: 0, max: 50,
      transparentBelow: 0.1,
      stops: [
        {v: 0.1, c:[  0,220,255]},
        {v: 2.0, c:[  0,120,255]},
        {v:10.0, c:[  0,  0,255]},
        {v:25.0, c:[120,  0,255]},
        {v:50.0, c:[255,  0,255]}
      ]
    },

    // RH (%): secca arancio -> neutro -> verde -> blu
    rh: {
      min: 0, max: 100,
      stops: [
        {v:  0, c:[255,170,  0]},
        {v: 40, c:[220,220,220]},
        {v: 60, c:[  0,255,120]},
        {v: 80, c:[  0,170,255]},
        {v:100, c:[  0,  0,255]}
      ]
    },

    // CLOUD (%): bianco -> grigio scuro (copertura crescente)
    cloud: {
      min: 0, max: 100,
      transparentBelow: 2,
      stops: [
        {v:  0, c:[255,255,255]},
        {v: 30, c:[210,210,210]},
        {v: 60, c:[140,140,140]},
        {v: 85, c:[ 80, 80, 80]},
        {v:100, c:[ 30, 30, 30]}
      ]
    }
  };

  function colorFromStops(val, spec){
    // clamp sul range palette
    const v = clamp(val, spec.min, spec.max);
    const stops = spec.stops;

    // trova segmento [i, i+1]
    for(let i=0;i<stops.length-1;i++){
      const a = stops[i], b = stops[i+1];
      if(v >= a.v && v <= b.v){
        const t = (v - a.v) / (b.v - a.v || 1);
        return lerpColor(a.c, b.c, t);
      }
    }
    // fallback
    return (v < stops[0].v) ? stops[0].c : stops[stops.length-1].c;
  }

  function unitFor(type){
    if(type==='wind') return 'km/h';
    if(type==='temp') return '¬∞C';
    if(type==='rain') return 'mm';
    if(type==='rh') return '%';
    if(type==='press') return 'hPa';
    if(type==='cloud') return '%';
    return '';
  }

  window.addEventListener('load', async function() {
    map = L.map('map', { zoomControl:false }).setView([37.5, 14.2], 8);

    map.createPane('labelsPane');
    map.getPane('labelsPane').style.zIndex = 650;
    map.getPane('labelsPane').style.pointerEvents = 'none';

    baseLayers.dark = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, attribution: '¬©OpenStreetMap, ¬©Carto' }
    ).addTo(map);

    hillshadeLayer = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, opacity: 0.72, className:'hillshade-tiles', attribution:'Hillshade ¬© Esri' }
    ).addTo(map);

    baseLayers.sat = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution:'Tiles ¬© Esri' }
    );

    labelLayers.dark = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, pane:'labelsPane', attribution:'¬©Carto' }
    ).addTo(map);

    labelLayers.sat = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, pane:'labelsPane', opacity: 0.95, attribution:'Labels ¬© Esri' }
    );

    createCanvasLayers();
    await loadCatalogAndFirstFrame();

    map.on('mousemove', updatePickerFromEvent);
    map.on('click', updatePickerFromEvent);

    document.getElementById('unit-display').innerText = unitFor(pickerLayer);
    syncLayerButtons();
  });

  function setBase(type) {
    document.querySelectorAll('.map-toggle').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');

    if(type === 'dark') {
      isLightMode = false;
      if(map.hasLayer(baseLayers.sat)) map.removeLayer(baseLayers.sat);
      baseLayers.dark.addTo(map);
      if(hillshadeLayer && !map.hasLayer(hillshadeLayer)) hillshadeLayer.addTo(map);

      if(labelLayers.sat && map.hasLayer(labelLayers.sat)) map.removeLayer(labelLayers.sat);
      if(labelLayers.dark && !map.hasLayer(labelLayers.dark)) labelLayers.dark.addTo(map);
    } else {
      isLightMode = true;
      if(map.hasLayer(baseLayers.dark)) map.removeLayer(baseLayers.dark);
      if(hillshadeLayer && map.hasLayer(hillshadeLayer)) map.removeLayer(hillshadeLayer);
      baseLayers.sat.addTo(map);

      if(labelLayers.dark && map.hasLayer(labelLayers.dark)) map.removeLayer(labelLayers.dark);
      if(labelLayers.sat && !map.hasLayer(labelLayers.sat)) labelLayers.sat.addTo(map);
    }

    redrawAll();
  }

  async function loadCatalogAndFirstFrame() {
    try {
      const r = await fetch('data_weather/catalog.json?t=' + Date.now());
      if(!r.ok) throw new Error("catalog not found");
      catalog = await r.json();
      if(!catalog || catalog.length === 0) throw new Error("empty catalog");

      const slider = document.getElementById('time-slider');
      slider.max = catalog.length - 1;
      slider.value = 0;
      slider.addEventListener('input', (e) => loadStep(parseInt(e.target.value,10)));

      await loadStep(0);
      document.getElementById('unit-display').innerText = "Pronto";
    } catch(e) {
      document.getElementById('unit-display').innerText = "Errore dati";
    }
  }

  async function loadStep(idx) {
    if(!catalog[idx]) return;
    document.getElementById('time-label').innerText = catalog[idx].label;

    try {
      const r = await fetch('data_weather/' + catalog[idx].file + '?t=' + Date.now());
      if(!r.ok) throw new Error("frame not found");
      currentData = await r.json();
      redrawAll();
    } catch(e) {}
  }

  function createCanvasLayers() {
    const mkCanvas = (z) => {
      const c = L.DomUtil.create('canvas', 'leaflet-layer');
      c.style.pointerEvents = 'none';
      c.style.zIndex = z;
      map.getPanes().overlayPane.appendChild(c);
      return c;
    };
    heatCanvas = mkCanvas(300);
    isoCanvas  = mkCanvas(400);
    gridCanvas = mkCanvas(450);
    map.on('moveend resize', redrawAll);
  }

  function redrawAll() {
    if(!currentData) return;
    drawHeatLayersContinuous();
    drawIsobars();
    drawGrid();
    updateWind();
  }

  function syncLayerButtons(){
    document.querySelectorAll('.layer-btn[data-layer]').forEach(btn=>{
      const k = btn.getAttribute('data-layer');
      btn.classList.toggle('active', enabledLayers.has(k));
      if(k === pickerLayer){
        btn.style.outline = "2px solid rgba(255,255,255,0.35)";
        btn.style.outlineOffset = "1px";
      } else {
        btn.style.outline = "none";
      }
    });
  }

  window.toggleLayer = function(layer, ev){
    if(ev && ev.shiftKey){
      pickerLayer = layer;
      document.getElementById('unit-display').innerText = unitFor(pickerLayer);
      syncLayerButtons();
      return;
    }

    if(enabledLayers.has(layer)) enabledLayers.delete(layer);
    else enabledLayers.add(layer);

    if(!enabledLayers.has(pickerLayer)){
      pickerLayer = enabledLayers.values().next().value || 'wind';
      document.getElementById('unit-display').innerText = unitFor(pickerLayer);
    }
    syncLayerButtons();
    redrawAll();
  };

  function setupCanvasHiDPI(canvas){
    const ctx = canvas.getContext('2d');
    const dpr = Math.min(2.0, window.devicePixelRatio || 1);
    const s = map.getSize();
    canvas.width  = Math.floor(s.x * dpr);
    canvas.height = Math.floor(s.y * dpr);
    canvas.style.width  = s.x + "px";
    canvas.style.height = s.y + "px";
    L.DomUtil.setPosition(canvas, map.containerPointToLayerPoint([0,0]));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0,0,s.x,s.y);
    ctx.imageSmoothingEnabled = true;
    return {ctx, s, dpr};
  }

  // === CONTINUOUS HEAT LAYERS: niente quadretti, gradienti fluidi ===
  function drawHeatLayersContinuous(){
    const {ctx, s} = setupCanvasHiDPI(heatCanvas);
    if(!currentData || !currentData.meta) return;

    const m = currentData.meta;

    const heatKeys = ['temp','press','rain','rh','cloud'];
    const enabledHeat = heatKeys.filter(k => enabledLayers.has(k));
    if(enabledHeat.length === 0) return;

    const pNW = map.latLngToContainerPoint([m.la1, m.lo1]);
    const pSE = map.latLngToContainerPoint([m.la2, m.lo2]);
    const x0 = Math.min(pNW.x, pSE.x);
    const y0 = Math.min(pNW.y, pSE.y);
    const w  = Math.abs(pSE.x - pNW.x);
    const h  = Math.abs(pSE.y - pNW.y);

    const drawOrder = ['temp','press','rh','rain','cloud'].filter(k => enabledHeat.includes(k));

    for(const key of drawOrder){
      const spec = CONTINUOUS[key];
      if(!spec) continue;

      const off = document.createElement('canvas');
      off.width = m.nx;
      off.height = m.ny;
      const octx = off.getContext('2d');
      const img = octx.createImageData(m.nx, m.ny);
      const d = img.data;

      for(let y=0;y<m.ny;y++){
        for(let x=0;x<m.nx;x++){
          const idx = y*m.nx + x;

          let val = 0;
          if(key==='temp')  val = currentData.temp[idx];
          if(key==='press') val = currentData.press[idx];
          if(key==='rain')  val = currentData.rain[idx];
          if(key==='rh')    val = currentData.rh[idx];
          if(key==='cloud') val = currentData.cloud ? currentData.cloud[idx] : 0;

          // trasparenza sotto soglia (rain/cloud)
          if(spec.transparentBelow !== undefined && val < spec.transparentBelow){
            const o = (y*m.nx + x)*4;
            d[o+3] = 0;
            continue;
          }

          const rgb = colorFromStops(val, spec);
          const o = (y*m.nx + x)*4;
          d[o+0] = rgb[0];
          d[o+1] = rgb[1];
          d[o+2] = rgb[2];
          d[o+3] = 255;
        }
      }

      octx.putImageData(img,0,0);

      ctx.save();
      let alpha = LAYER_OPACITY[key] ?? 0.6;
      if(isLightMode) alpha = Math.min(0.85, alpha + 0.10); // su sat pi√π presente
      ctx.globalAlpha = alpha;

      ctx.drawImage(off, x0, y0, w, h);
      ctx.restore();
    }
  }

  function drawIsobars() {
    const {ctx, s} = setupCanvasHiDPI(isoCanvas);

    if(!showIso || !currentData || !currentData.press) return;

    const m = currentData.meta;
    const values = currentData.press;

    const contours = d3.contours()
      .size([m.nx, m.ny])
      .thresholds(d3.range(960, 1050, 2))(values);

    ctx.lineWidth = 1.7;
    ctx.font = "900 12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    contours.forEach(c => {
      ctx.strokeStyle = (!isLightMode) ? "rgba(255,255,255,0.95)" : "rgba(0,0,0,0.75)";

      ctx.beginPath();
      const labelCandidates = [];

      c.coordinates.forEach(ring => {
        ring.forEach(pts => {
          let first = true;
          const linePts = [];
          pts.forEach(coord => {
            const lat = m.la1 - (coord[1] * m.dy);
            const lon = m.lo1 + (coord[0] * m.dx);
            const p = map.latLngToContainerPoint([lat, lon]);
            linePts.push(p);
            if(first) { ctx.moveTo(p.x, p.y); first=false; }
            else ctx.lineTo(p.x, p.y);
          });
          if(linePts.length > 60) labelCandidates.push(linePts);
        });
      });

      ctx.stroke();

      labelCandidates.forEach(pts => {
        const mid = pts[Math.floor(pts.length/2)];
        const bg = isLightMode ? "rgba(255,255,255,0.85)" : "rgba(0,0,0,0.72)";
        const fg = isLightMode ? "#000" : "#fff";
        ctx.fillStyle = bg;
        ctx.fillRect(mid.x-16, mid.y-9, 32, 18);
        ctx.fillStyle = fg;
        ctx.fillText(Math.round(c.value), mid.x, mid.y);
      });
    });
  }

  function drawGrid() {
    const {ctx, s} = setupCanvasHiDPI(gridCanvas);
    if(!showGrid) return;

    const b = map.getBounds();
    const step = map.getZoom() > 9 ? 0.1 : 0.5;

    ctx.strokeStyle = isLightMode ? "rgba(0,0,0,0.20)" : "rgba(255,255,255,0.16)";
    ctx.lineWidth = 1;

    for(let lon=Math.floor(b.getWest()); lon<=Math.ceil(b.getEast()); lon+=step) {
      const x = map.latLngToContainerPoint([b.getSouth(), lon]).x;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,s.y); ctx.stroke();
    }
    for(let lat=Math.floor(b.getSouth()); lat<=Math.ceil(b.getNorth()); lat+=step) {
      const y = map.latLngToContainerPoint([lat, b.getWest()]).y;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(s.x,y); ctx.stroke();
    }
  }

  function updateWind() {
    if(velocityLayer) map.removeLayer(velocityLayer);
    if(!enabledLayers.has('wind') || !currentData) return;

    const isMobile = Math.min(window.innerWidth, window.innerHeight) < 900;
    const dpr = window.devicePixelRatio || 1;

    let particleMult = isMobile ? (1/190) : (1/145);
    if(dpr >= 2) particleMult = isMobile ? (1/270) : (1/210);

    const colorsDark = ["#0000ff", "#0066ff", "#00e5ff", "#00ff66", "#fff000", "#ff7a00", "#ff0000", "#ff00ff"];
    const colorsSat  = ["#001040", "#0030a8", "#0070ff", "#00b85a", "#c8b800", "#ff6a00", "#c00000", "#6a006a"];

    try {
      velocityLayer = L.velocityLayer({
        displayValues: false,
        data: [ currentData.wind_u, currentData.wind_v ],
        maxVelocity: 18.0,
        velocityScale: 0.006,
        particleMultiplier: particleMult,
        lineWidth: 0.9,
        particleAge: 140,
        frameRate: 60,
        opacity: 1.0,
        colorScale: (isLightMode ? colorsSat : colorsDark)
      });
      velocityLayer.addTo(map);
    } catch(e) {}
  }

  function valueAtLatLng(latlng) {
    if(!currentData || !currentData.meta) return null;
    const m = currentData.meta;

    const y = Math.round((m.la1 - latlng.lat) / m.dy);
    const x = Math.round((latlng.lng - m.lo1) / m.dx);

    if(x < 0 || x >= m.nx || y < 0 || y >= m.ny) return null;
    const idx = y*m.nx + x;

    if(pickerLayer === 'wind') {
      const u = currentData.wind_u.data[idx];
      const v = currentData.wind_v.data[idx];
      return (Math.sqrt(u*u + v*v) * 3.6);
    }
    if(pickerLayer === 'temp') return currentData.temp[idx];
    if(pickerLayer === 'rain') return currentData.rain[idx];
    if(pickerLayer === 'rh') return currentData.rh[idx];
    if(pickerLayer === 'press') return currentData.press[idx];
    if(pickerLayer === 'cloud') return currentData.cloud ? currentData.cloud[idx] : null;
    return null;
  }

  function updatePickerFromEvent(e) {
    const val = valueAtLatLng(e.latlng);
    if(val === null || val === undefined) return;

    let out = '--';
    if(pickerLayer === 'wind') out = val.toFixed(1);
    else if(pickerLayer === 'temp') out = val.toFixed(1);
    else if(pickerLayer === 'rain') out = val.toFixed(1);
    else if(pickerLayer === 'rh') out = Math.round(val).toString();
    else if(pickerLayer === 'press') out = Math.round(val).toString();
    else if(pickerLayer === 'cloud') out = Math.round(val).toString();

    document.getElementById('val-display').innerText = out;
    document.getElementById('unit-display').innerText = unitFor(pickerLayer);
  }

  window.toggleIso = function() {
    showIso = !showIso;
    document.getElementById('btn-iso').classList.toggle('active');
    redrawAll();
  };

  window.toggleGrid = function() {
    showGrid = !showGrid;
    document.getElementById('btn-grid').classList.toggle('active');
    redrawAll();
  };

  window.togglePlay = function() {
    if(isPlaying) {
      isPlaying = false;
      document.getElementById('play-btn').innerText = "‚ñ∫";
      if(lastFrameInterval) { clearInterval(lastFrameInterval); lastFrameInterval = null; }
      return;
    }
    isPlaying = true;

    const s = document.getElementById('time-slider');
    const btn = document.getElementById('play-btn');
    btn.innerText = "‚ùö‚ùö";

    let i = parseInt(s.value, 10);
    const max = parseInt(s.max, 10);

    lastFrameInterval = setInterval(() => {
      if(!isPlaying) { clearInterval(lastFrameInterval); lastFrameInterval=null; btn.innerText="‚ñ∫"; return; }
      if(i >= max) { clearInterval(lastFrameInterval); lastFrameInterval=null; isPlaying=false; btn.innerText="‚ñ∫"; return; }
      i++;
      s.value = i;
      loadStep(i);
    }, 800);
  };
</script>

</body>
</html>