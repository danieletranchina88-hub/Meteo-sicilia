<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - PRO (DARK + SAT, Multi-Layer)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin: 0; background: #111; font-family: 'Segoe UI', sans-serif; color: white; overflow: hidden; }
    #map { position: absolute; inset: 0; background: #111; }

    #ui-container { position: absolute; top: 10px; right: 10px; z-index: 2000; display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
    .panel { background: rgba(0,0,0,0.82); backdrop-filter: blur(8px); padding: 10px; border-radius: 14px; border: 1px solid rgba(255,255,255,0.18); box-shadow: 0 10px 30px rgba(0,0,0,0.35); }

    .map-toggle {
      padding: 8px 12px; background: rgba(255,255,255,0.06); color: #fff;
      border: 1px solid rgba(255,255,255,0.2); border-radius: 10px;
      cursor: pointer; font-size: 12px; font-weight: 900;
      transition: all 0.15s; min-width: 64px;
    }
    .map-toggle:hover { background: rgba(255,255,255,0.12); }
    .map-toggle.active { background: #2b78ff; border-color: rgba(160,200,255,0.7); }

    .layer-btn {
      display: block; width: 160px; padding: 10px 12px; margin-bottom: 6px;
      background: rgba(255,255,255,0.02); color: #d9d9d9; border: 1px solid rgba(255,255,255,0.10);
      text-align: right; cursor: pointer; font-size: 13px; font-weight: 900; border-radius: 10px;
      transition: all 0.15s;
    }
    .layer-btn:hover { background: rgba(255,255,255,0.10); color: #fff; }
    .layer-btn.active { background: #2b78ff; border-color: rgba(160,200,255,0.7); color: #fff; }

    .sub-btn { opacity: 0.92; font-weight: 800; }
    .toggle-btn.active { background: rgba(255,255,255,0.18); border-color: rgba(255,255,255,0.25); }

    #info-box { position: absolute; top: 16px; left: 16px; z-index: 2500; pointer-events: none; text-shadow: 0 2px 10px rgba(0,0,0,0.85); }
    #val-display { font-size: 3.2em; font-weight: 1000; line-height: 1; letter-spacing: -0.02em; }
    #unit-display { font-size: 1.05em; color: rgba(255,255,255,0.8); font-weight: 900; }

    #bottom-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: 90px;
      background: linear-gradient(to top, rgba(0,0,0,0.92), transparent);
      display: flex; align-items: center; padding: 0 20px; z-index: 3000;
      gap: 14px;
    }
    #play-btn { font-size: 2.5em; background: none; border: none; color: white; cursor: pointer; }
    #time-label { font-size: 1.4em; font-weight: 1000; min-width: 140px; text-align: center; text-shadow: 0 2px 10px rgba(0,0,0,0.85); }
    input[type=range] { flex-grow: 1; height: 5px; cursor: pointer; accent-color: #2b78ff; }

    /* Canvas: smooth */
    canvas { image-rendering: auto; }

    /* Piccolo toast errore basemap */
    #toast {
      position: absolute; left: 16px; bottom: 110px; z-index: 5000;
      background: rgba(120,0,0,0.85); border: 1px solid rgba(255,255,255,0.18);
      padding: 10px 12px; border-radius: 10px; font-size: 12px; font-weight: 800;
      display: none;
    }
  </style>
</head>

<body>
  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">--</div>
  </div>

  <div id="toast">Tile basemap non caricati (server/URL bloccato). Controlla connessione o URL.</div>

  <div id="ui-container">
    <div class="panel" style="display:flex; gap:6px; justify-content:flex-end;">
      <button class="map-toggle active" id="btn-dark" onclick="setBase('dark')">DARK</button>
      <button class="map-toggle" id="btn-sat" onclick="setBase('sat')">SAT</button>
    </div>

    <div class="panel">
      <!-- MULTI-LAYER: ogni bottone √® un toggle -->
      <button class="layer-btn active" data-layer="wind" onclick="toggleLayer('wind', this)">VENTO üí®</button>
      <button class="layer-btn active" data-layer="temp" onclick="toggleLayer('temp', this)">TEMP üå°Ô∏è</button>
      <button class="layer-btn" data-layer="rain" onclick="toggleLayer('rain', this)">PIOGGIA ‚òî</button>
      <button class="layer-btn" data-layer="rh" onclick="toggleLayer('rh', this)">UMIDIT√Ä üíß</button>
      <button class="layer-btn" data-layer="press" onclick="toggleLayer('press', this)">PRESSIONE üß≠</button>
      <button class="layer-btn" data-layer="cloud" onclick="toggleLayer('cloud', this)">NUVOLE ‚òÅÔ∏è</button>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.14); margin:8px 0;">

      <button class="layer-btn sub-btn toggle-btn" id="btn-iso" onclick="toggleIso()">ISOBARE „Ä∞Ô∏è</button>
      <button class="layer-btn sub-btn toggle-btn" id="btn-grid" onclick="toggleGrid()">GRIGLIA #</button>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  // =========================
  // GLOBALS
  // =========================
  let map;
  let velocityLayer = null;

  let heatCanvas = null;   // canvas heat per layer (temp/rain/rh/press/cloud) - unico, disegna tutti gli attivi in ordine
  let isoCanvas  = null;   // canvas isobare
  let gridCanvas = null;   // canvas griglia

  let currentData = null;
  let catalog = [];
  let isPlaying = false;

  // Multi-layer attivi (toggle)
  const active = {
    wind: true,
    temp: true,
    rain: false,
    rh: false,
    press: false,
    cloud: false
  };

  let showIso = false;
  let showGrid = false;

  // Base map
  const baseLayers = { dark:null, sat:null };
  const labelLayers = { dark:null, sat:null };
  let baseMode = 'dark'; // 'dark' | 'sat'

  // Z-order canvas e layers
  const Z = { heat: 300, iso: 500, wind: 650, grid: 700, labels: 800 };

  // =========================
  // PALETTES
  // =========================

  // (A) TEMP: palette coi tuoi punti fissi e quantizzazione a 1¬∞C
  const TEMP_STOPS = [
    {v:-15, c:[ 60,   0, 120, 0.62]}, // viola scuro
    {v:  0, c:[  0, 220, 255, 0.62]}, // ciano
    {v: 15, c:[255, 245, 140, 0.62]}, // giallo chiaro
    {v: 20, c:[255, 230,   0, 0.62]}, // giallo
    {v: 25, c:[255, 175,  80, 0.62]}, // arancione chiaro
    {v: 30, c:[255, 120,   0, 0.62]}, // arancione
    {v: 35, c:[255,  30,  30, 0.62]}, // rosso
    {v: 45, c:[120,   0,   0, 0.62]}  // rosso scuro
  ];

  // (B) Altri layer (puoi rifinirli dopo)
  const PALETTES = {
    rain: [
      {v:0.0, c:[0,0,0,0.00]},
      {v:0.1, c:[  0, 180, 255, 0.55]},
      {v:2.0, c:[  0,  70, 255, 0.62]},
      {v:10,  c:[160,   0, 220, 0.70]},
      {v:30,  c:[255,   0, 140, 0.78]}
    ],
    rh: [
      {v:20, c:[190, 160,  70, 0.52]},
      {v:40, c:[200, 200, 200, 0.52]},
      {v:60, c:[ 90, 255, 110, 0.56]},
      {v:80, c:[ 60, 160, 255, 0.60]},
      {v:95, c:[  0,  40, 200, 0.66]}
    ],
    press: [
      {v:980,  c:[  0,  70, 255, 0.54]},
      {v:995,  c:[  0, 170, 255, 0.54]},
      {v:1005, c:[  0, 255, 200, 0.54]},
      {v:1013, c:[255, 255, 255, 0.50]},
      {v:1022, c:[255, 200,   0, 0.56]},
      {v:1035, c:[255,  60,   0, 0.62]}
    ],
    // NUVOLE: bianco -> grigio scuro (come mi hai chiesto)
    cloud: [
      {v:0,   c:[255,255,255,0.00]},
      {v:20,  c:[245,245,245,0.20]},
      {v:40,  c:[220,220,220,0.30]},
      {v:60,  c:[180,180,180,0.40]},
      {v:80,  c:[120,120,120,0.50]},
      {v:100, c:[ 60, 60, 60,0.60]}
    ]
  };

  function lerp(a,b,t){ return a + (b-a)*t; }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function interpStops(val, stops){
    // stops: [{v, c:[r,g,b,a]}...]
    if(val <= stops[0].v) return stops[0].c;
    if(val >= stops[stops.length-1].v) return stops[stops.length-1].c;

    for(let i=0;i<stops.length-1;i++){
      const s1 = stops[i], s2 = stops[i+1];
      if(val >= s1.v && val <= s2.v){
        const t = (val - s1.v) / (s2.v - s1.v);
        const c1 = s1.c, c2 = s2.c;
        return [
          Math.round(lerp(c1[0], c2[0], t)),
          Math.round(lerp(c1[1], c2[1], t)),
          Math.round(lerp(c1[2], c2[2], t)),
          lerp(c1[3], c2[3], t)
        ];
      }
    }
    return stops[stops.length-1].c;
  }

  // TEMP: quantizza a 1¬∞C per evitare "troppi verdi uguali"
  function tempColor(valC){
    let v = Math.round(valC);
    v = clamp(v, -15, 45);
    return interpStops(v, TEMP_STOPS);
  }

  // =========================
  // INIT MAP
  // =========================
  window.addEventListener('load', async () => {
    map = L.map('map', { zoomControl: false, preferCanvas: true }).setView([37.5, 14.2], 8);

    // Pane dedicati (ordine controllato)
    map.createPane('basePane');   map.getPane('basePane').style.zIndex = 200;
    map.createPane('heatPane');   map.getPane('heatPane').style.zIndex = Z.heat;
    map.createPane('isoPane');    map.getPane('isoPane').style.zIndex  = Z.iso;
    map.createPane('windPane');   map.getPane('windPane').style.zIndex = Z.wind; map.getPane('windPane').style.pointerEvents='none';
    map.createPane('gridPane');   map.getPane('gridPane').style.zIndex = Z.grid; map.getPane('gridPane').style.pointerEvents='none';
    map.createPane('labelsPane'); map.getPane('labelsPane').style.zIndex = Z.labels; map.getPane('labelsPane').style.pointerEvents='none';

    // DARK base + labels
    baseLayers.dark = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, attribution: '¬©OpenStreetMap, ¬©Carto', pane: 'basePane' }
    ).addTo(map);

    labelLayers.dark = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, pane: 'labelsPane' }
    ).addTo(map);

    // SAT base + labels (nomi citt√† sul sat)
    baseLayers.sat = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 13, attribution: 'Tiles ¬© Esri', pane: 'basePane' }
    );

    // Labels chiari sopra SAT (OSM standard)
    labelLayers.sat = L.tileLayer(
      'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      { maxZoom: 19, pane: 'labelsPane', opacity: 0.65 }
    );

    // rileva errori tile
    baseLayers.dark.on('tileerror', () => toast(true));
    baseLayers.sat.on('tileerror', () => toast(true));
    if(labelLayers.sat) labelLayers.sat.on('tileerror', () => toast(true));

    // Canvas layers
    initCanvasLayers();

    // Data
    await loadCatalogAndFirstFrame();

    // Picker
    map.on('mousemove', updatePickerFromEvent);
    map.on('click', updatePickerFromEvent);

    // UI unit iniziale
    document.getElementById('unit-display').innerText = "km/h";
  });

  function toast(show){
    const t = document.getElementById('toast');
    if(show){
      t.style.display = 'block';
      clearTimeout(t._to);
      t._to = setTimeout(()=>{ t.style.display='none'; }, 4500);
    } else {
      t.style.display = 'none';
    }
  }

  // =========================
  // BASE SWITCH
  // =========================
  window.setBase = function(type){
    baseMode = type;

    document.getElementById('btn-dark').classList.toggle('active', type==='dark');
    document.getElementById('btn-sat').classList.toggle('active', type==='sat');

    // remove all base/labels
    map.removeLayer(baseLayers.dark);
    map.removeLayer(labelLayers.dark);
    if(baseLayers.sat) map.removeLayer(baseLayers.sat);
    if(labelLayers.sat) map.removeLayer(labelLayers.sat);

    if(type==='dark'){
      baseLayers.dark.addTo(map);
      labelLayers.dark.addTo(map);
    } else {
      baseLayers.sat.addTo(map);
      labelLayers.sat.addTo(map);
    }

    redrawAll();
  }

  // =========================
  // LOAD DATA
  // =========================
  async function loadCatalogAndFirstFrame(){
    try{
      const r = await fetch('data_weather/catalog.json?t='+Date.now());
      if(!r.ok) throw new Error('catalog not found');
      catalog = await r.json();
      if(!catalog || catalog.length===0) throw new Error('empty catalog');

      const slider = document.getElementById('time-slider');
      slider.max = catalog.length - 1;
      slider.value = 0;
      slider.addEventListener('input', (e)=> loadStep(parseInt(e.target.value,10)));

      await loadStep(0);
    } catch(e){
      document.getElementById('unit-display').innerText = "Errore dati";
    }
  }

  async function loadStep(idx){
    if(!catalog[idx]) return;
    document.getElementById('time-label').innerText = catalog[idx].label;

    try{
      const r = await fetch('data_weather/' + catalog[idx].file + '?t=' + Date.now());
      if(!r.ok) throw new Error('frame not found');
      currentData = await r.json();
      redrawAll();
    } catch(e){
      // silent
    }
  }

  // =========================
  // CANVAS
  // =========================
  function initCanvasLayers(){
    heatCanvas = L.DomUtil.create('canvas', 'leaflet-layer');
    heatCanvas.style.pointerEvents = 'none';
    map.getPane('heatPane').appendChild(heatCanvas);

    isoCanvas = L.DomUtil.create('canvas', 'leaflet-layer');
    isoCanvas.style.pointerEvents = 'none';
    map.getPane('isoPane').appendChild(isoCanvas);

    gridCanvas = L.DomUtil.create('canvas', 'leaflet-layer');
    gridCanvas.style.pointerEvents = 'none';
    map.getPane('gridPane').appendChild(gridCanvas);

    map.on('moveend resize', redrawAll);
  }

  function resizeCanvasToMap(c){
    const s = map.getSize();
    c.width = s.x;
    c.height = s.y;
    L.DomUtil.setPosition(c, map.containerPointToLayerPoint([0,0]));
    return s;
  }

  function redrawAll(){
    if(!currentData) return;

    drawHeatMulti();   // temp/rain/rh/press/cloud (multi attivi)
    drawIsobars();     // isobare
    drawGrid();        // griglia
    updateWind();      // vento (leaflet-velocity)
  }

  // =========================
  // HEAT (MULTI)
  // =========================
  function alphaForLayer(layer){
    // Opacit√† "intelligente": se sono attivi molti layer, abbassiamo un po' per non impastare
    const on = ['temp','rain','rh','press','cloud'].filter(k=>active[k]).length;
    const base = {
      temp: 0.80,
      rain: 0.78,
      rh:   0.62,
      press:0.60,
      cloud:0.55
    }[layer] || 0.70;

    if(on <= 1) return base;
    if(on === 2) return base * 0.85;
    if(on === 3) return base * 0.72;
    return base * 0.60;
  }

  function drawHeatMulti(){
    const ctx = heatCanvas.getContext('2d');
    const s = resizeCanvasToMap(heatCanvas);
    ctx.clearRect(0,0,s.x,s.y);

    // se nessun heat attivo, esci
    const anyHeat = active.temp || active.rain || active.rh || active.press || active.cloud;
    if(!anyHeat || !currentData || !currentData.meta) return;

    const m = currentData.meta;
    const b = map.getBounds();

    // ordine di compositing: press (soft) -> temp -> rh -> rain -> cloud (ultimo e pi√π leggero)
    const order = ['press','temp','rh','rain','cloud'].filter(k=>active[k]);

    // rendering: 1 pass per layer (pi√π leggibile)
    for(const layer of order){
      const aMul = alphaForLayer(layer);

      for(let y=0; y<m.ny; y++){
        const lat = m.la1 - (y*m.dy);
        if(lat < b.getSouth()-0.2 || lat > b.getNorth()+0.2) continue;

        for(let x=0; x<m.nx; x++){
          const lon = m.lo1 + (x*m.dx);
          if(lon < b.getWest()-0.2 || lon > b.getEast()+0.2) continue;

          const idx = y*m.nx + x;

          let val = null;
          if(layer==='temp')  val = currentData.temp?.[idx];
          if(layer==='rain')  val = currentData.rain?.[idx];
          if(layer==='rh')    val = currentData.rh?.[idx];
          if(layer==='press') val = currentData.press?.[idx];
          if(layer==='cloud') val = currentData.cloud?.[idx];

          if(val === null || val === undefined) continue;

          let c;
          if(layer==='temp'){
            c = tempColor(val);
          } else {
            const stops = PALETTES[layer];
            if(!stops) continue;

            // piccoli filtri
            if(layer==='rain' && val < 0.1) continue;

            c = interpStops(val, stops);
          }

          // applica opacit√† "intelligente"
          const alpha = clamp((c[3] || 0) * aMul, 0, 0.92);
          if(alpha <= 0) continue;

          const p1 = map.latLngToContainerPoint([lat, lon]);
          const p2 = map.latLngToContainerPoint([lat - m.dy, lon + m.dx]);

          // rettangoli leggermente sovrapposti
          const w = Math.ceil(p2.x - p1.x) + 1;
          const h = Math.ceil(p2.y - p1.y) + 1;

          ctx.fillStyle = `rgba(${c[0]},${c[1]},${c[2]},${alpha})`;
          ctx.fillRect(Math.floor(p1.x), Math.floor(p1.y), w, h);
        }
      }
    }
  }

  // =========================
  // ISOBARS (D3) - bianche come hai chiesto
  // =========================
  function drawIsobars(){
    const ctx = isoCanvas.getContext('2d');
    const s = resizeCanvasToMap(isoCanvas);
    ctx.clearRect(0,0,s.x,s.y);

    if(!showIso || !currentData || !currentData.press || !currentData.meta) return;

    const m = currentData.meta;
    const values = currentData.press;

    const contours = d3.contours()
      .size([m.nx, m.ny])
      .thresholds(d3.range(960, 1050, 2))(values);

    ctx.lineWidth = 1.35;
    ctx.strokeStyle = "rgba(255,255,255,0.80)";
    ctx.beginPath();

    contours.forEach(c => {
      c.coordinates.forEach(ring => {
        ring.forEach(pts => {
          let first = true;
          pts.forEach(coord => {
            const lat = m.la1 - (coord[1] * m.dy);
            const lon = m.lo1 + (coord[0] * m.dx);
            const p = map.latLngToContainerPoint([lat, lon]);
            if(first){ ctx.moveTo(p.x, p.y); first=false; }
            else ctx.lineTo(p.x, p.y);
          });
        });
      });
    });

    ctx.stroke();
  }

  // =========================
  // GRID (solo linee)
  // =========================
  function drawGrid(){
    const ctx = gridCanvas.getContext('2d');
    const s = resizeCanvasToMap(gridCanvas);
    ctx.clearRect(0,0,s.x,s.y);

    if(!showGrid) return;

    const b = map.getBounds();
    const step = (map.getZoom() > 9) ? 0.1 : 0.5;

    // griglia leggera
    ctx.strokeStyle = (baseMode==='sat') ? "rgba(0,0,0,0.22)" : "rgba(255,255,255,0.16)";
    ctx.lineWidth = 1;

    for(let lon=Math.floor(b.getWest()); lon<=Math.ceil(b.getEast()); lon+=step){
      const x = map.latLngToContainerPoint([b.getSouth(), lon]).x;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,s.y); ctx.stroke();
    }
    for(let lat=Math.floor(b.getSouth()); lat<=Math.ceil(b.getNorth()); lat+=step){
      const y = map.latLngToContainerPoint([lat, b.getWest()]).y;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(s.x,y); ctx.stroke();
    }
  }

  // =========================
  // WIND (contrast: scurito su mappa chiara)
  // =========================
  function updateWind(){
    if(velocityLayer) { map.removeLayer(velocityLayer); velocityLayer = null; }

    if(!active.wind || !currentData) return;

    const isMobile = Math.min(window.innerWidth, window.innerHeight) < 900;
    const dpr = window.devicePixelRatio || 1;

    let particleMult = isMobile ? (1/170) : (1/120);
    if(dpr >= 2) particleMult = isMobile ? (1/240) : (1/180);

    // ColorScale:
    // - su DARK: la tua originale
    // - su SAT (chiara): stessi colori ma pi√π scuri/contrastati
    const darkScale = ["#000080", "#0044ff", "#00ddff", "#00ff55", "#ffff00", "#ff6600", "#ff0000", "#ff00ff"];
    const satScale  = ["#00004d", "#002fb3", "#0096b3", "#00a838", "#b3b300", "#b34700", "#b30000", "#800080"];

    try{
      velocityLayer = L.velocityLayer({
        pane: 'windPane',
        displayValues: false,
        data: [ currentData.wind_u, currentData.wind_v ],

        // parametri (come tua base) + particelle pi√π leggere
        maxVelocity: 18.0,
        velocityScale: 0.006,
        particleMultiplier: particleMult,
        lineWidth: 0.85,
        particleAge: 140,
        frameRate: 60,
        opacity: 0.95,
        colorScale: (baseMode==='sat') ? satScale : darkScale
      });
      velocityLayer.addTo(map);
    } catch(e){
      // silent
    }
  }

  // =========================
  // PICKER (valore sotto dito/mouse)
  // =========================
  function unitLabel(){
    // mostra unit√† "principale": se wind attivo -> km/h, altrimenti temp ecc.
    if(active.wind) return "km/h";
    if(active.temp) return "¬∞C";
    if(active.rain) return "mm";
    if(active.rh) return "%";
    if(active.press) return "hPa";
    if(active.cloud) return "%";
    return "--";
  }

  function valueAtLatLng(latlng){
    if(!currentData || !currentData.meta) return null;
    const m = currentData.meta;

    const y = Math.round((m.la1 - latlng.lat) / m.dy);
    const x = Math.round((latlng.lng - m.lo1) / m.dx);
    if(x<0 || x>=m.nx || y<0 || y>=m.ny) return null;

    const idx = y*m.nx + x;

    // priorit√†: se wind attivo, mostro wind. altrimenti temp > rain > rh > press > cloud
    if(active.wind && currentData.wind_u?.data && currentData.wind_v?.data){
      const u = currentData.wind_u.data[idx];
      const v = currentData.wind_v.data[idx];
      const sp = Math.sqrt(u*u + v*v) * 3.6;
      return {v: sp, type:'wind'};
    }
    if(active.temp && currentData.temp) return {v: currentData.temp[idx], type:'temp'};
    if(active.rain && currentData.rain) return {v: currentData.rain[idx], type:'rain'};
    if(active.rh && currentData.rh) return {v: currentData.rh[idx], type:'rh'};
    if(active.press && currentData.press) return {v: currentData.press[idx], type:'press'};
    if(active.cloud && currentData.cloud) return {v: currentData.cloud[idx], type:'cloud'};

    return null;
  }

  function updatePickerFromEvent(e){
    const res = valueAtLatLng(e.latlng);
    if(!res) return;

    let out = '--';
    if(res.type==='wind') out = res.v.toFixed(1);
    else if(res.type==='temp') out = res.v.toFixed(1);
    else if(res.type==='rain') out = res.v.toFixed(1);
    else if(res.type==='rh') out = Math.round(res.v).toString();
    else if(res.type==='press') out = Math.round(res.v).toString();
    else if(res.type==='cloud') out = Math.round(res.v).toString();

    document.getElementById('val-display').innerText = out;
    document.getElementById('unit-display').innerText = unitLabel();
  }

  // =========================
  // UI ACTIONS
  // =========================
  window.toggleLayer = function(layer, btnEl){
    active[layer] = !active[layer];
    btnEl.classList.toggle('active', active[layer]);

    // unit aggiornate
    document.getElementById('unit-display').innerText = unitLabel();
    document.getElementById('val-display').innerText = '--';

    redrawAll();
  }

  window.toggleIso = function(){
    showIso = !showIso;
    document.getElementById('btn-iso').classList.toggle('active', showIso);
    redrawAll();
  }

  window.toggleGrid = function(){
    showGrid = !showGrid;
    document.getElementById('btn-grid').classList.toggle('active', showGrid);
    redrawAll();
  }

  window.togglePlay = function(){
    if(isPlaying){
      isPlaying = false;
      document.getElementById('play-btn').innerText = "‚ñ∫";
      return;
    }
    isPlaying = true;
    document.getElementById('play-btn').innerText = "‚ùö‚ùö";

    const s = document.getElementById('time-slider');
    let i = parseInt(s.value, 10);
    const max = parseInt(s.max, 10);

    const interval = setInterval(() => {
      if(!isPlaying){ clearInterval(interval); return; }
      if(i >= max){
        clearInterval(interval);
        isPlaying = false;
        document.getElementById('play-btn').innerText = "‚ñ∫";
        return;
      }
      i++;
      s.value = i;
      loadStep(i);
    }, 800);
  }

</script>
</body>
</html>
```Ó®Å0Ó®Ç