<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - PRO (GRAY RELIEF + MULTILAYER)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin: 0; background: #0f0f0f; font-family: 'Segoe UI', sans-serif; color: white; overflow: hidden; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #0f0f0f; }

    /* UI */
    #ui-container {
      position: absolute; top: 10px; right: 10px; z-index: 1000;
      display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
    }
    .panel {
      background: rgba(0,0,0,0.85);
      backdrop-filter: blur(6px);
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    }

    .layer-btn {
      display: block; width: 190px;
      padding: 10px 12px; margin-bottom: 6px;
      background: transparent; color: #cfcfcf; border: none; text-align: right;
      cursor: pointer; font-size: 13px; font-weight: 800; border-radius: 10px;
      transition: all 0.15s;
    }
    .layer-btn:hover { background: rgba(255,255,255,0.08); color: #fff; }
    .layer-btn.active { background: linear-gradient(90deg, #0055ff, #0022aa); color: #fff; }

    .sub-btn {
      display: block; width: 190px;
      padding: 10px 12px; margin-top: 8px;
      background: rgba(255,255,255,0.06);
      color: #ddd; border: 1px solid rgba(255,255,255,0.12);
      text-align: right; cursor: pointer; font-size: 12px; font-weight: 900;
      border-radius: 10px; transition: all 0.15s;
    }
    .sub-btn:hover { background: rgba(255,255,255,0.12); }
    .sub-btn.active { background: rgba(0,136,255,0.95); border-color: rgba(0,136,255,0.95); color: white; }

    /* INFO */
    #info-box {
      position: absolute; top: 18px; left: 18px; z-index: 1000;
      pointer-events: none; text-shadow: 0 3px 12px rgba(0,0,0,0.9);
    }
    #val-display { font-size: 3.7em; font-weight: 950; line-height: 1; }
    #unit-display { font-size: 1.15em; color: #d0d0d0; font-weight: 900; }

    /* TIME */
    #bottom-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: 92px;
      background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
      display: flex; align-items: center; padding: 0 20px; z-index: 2000;
    }
    #play-btn { font-size: 2.5em; background: none; border: none; color: white; cursor: pointer; margin-right: 15px; }
    #time-label {
      font-size: 1.35em; font-weight: 950; margin-left: 15px; min-width: 140px;
      text-align: center; text-shadow: 0 2px 10px rgba(0,0,0,0.85);
    }
    input[type=range] { flex-grow: 1; height: 5px; cursor: pointer; accent-color: #0088ff; }

    /* Hillshade styling for relief */
    .hillshade-tiles {
      mix-blend-mode: multiply;
      filter: contrast(2.15) brightness(0.98);
    }

    canvas { image-rendering: auto; }
    * { -webkit-tap-highlight-color: transparent; }
  </style>
</head>

<body>
  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">Caricamento...</div>
  </div>

  <div id="ui-container">
    <div class="panel">
      <!-- MULTI LAYER: toggles -->
      <button class="layer-btn" id="btn-temp"  onclick="toggleLayer('temp')">TEMP üå°Ô∏è</button>
      <button class="layer-btn" id="btn-rain"  onclick="toggleLayer('rain')">PIOGGIA ‚òî</button>
      <button class="layer-btn" id="btn-rh"    onclick="toggleLayer('rh')">UMIDIT√Ä üíß</button>
      <button class="layer-btn" id="btn-press" onclick="toggleLayer('press')">PRESSIONE ‚è≤Ô∏è</button>
      <button class="layer-btn" id="btn-cloud" onclick="toggleLayer('cloud')">NUVOLE ‚òÅÔ∏è</button>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.18); margin:10px 0;">

      <button class="layer-btn" id="btn-wind-syn" onclick="toggleLayer('wind_syn')">VENTO (SINOTTICO) üß≠</button>
      <button class="sub-btn" id="btn-particles" onclick="toggleParticles()">PARTICELLE üí®</button>

      <button class="sub-btn" id="btn-iso" onclick="toggleIso()">ISOBARE „Ä∞Ô∏è</button>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  // =========================
  // GLOBALS
  // =========================
  var map, velocityLayer;

  // One canvas per field so we can manage opacity & stacking cleanly
  var canvasTemp, canvasRain, canvasRH, canvasPress, canvasCloud;
  var canvasIso, canvasWind; // wind_syn drawn here (bg+arrows)

  var currentData = null, catalog = [];
  var isPlaying = false;

  // Multi-layer active set
  var active = {
    temp: false,
    rain: false,
    rh: false,
    press: false,
    cloud: false,
    wind_syn: true
  };

  var showParticles = false;
  var showIso = false;

  // Base layers: GRAY + RELIEF (what you asked)
  var baseGray, labelsGray, hillshade;

  // =========================
  // WIND: KEEP EXACT SETTINGS YOU LIKED (DO NOT CHANGE)
  // =========================
  const WIND_MAX_VELOCITY = 18.0;
  const WIND_VELOCITY_SCALE = 0.006;
  const WIND_LINE_WIDTH = 0.8;
  const WIND_PARTICLE_AGE = 140;
  const WIND_FRAME_RATE = 60;
  const WIND_OPACITY = 0.95;

  // EXACT palette you asked to keep
  const WIND_COLORS = ["#000080", "#0044ff", "#00ddff", "#00ff55", "#ffff00", "#ff6600", "#ff0000", "#ff00ff"];

  // =========================
  // PALETTES (heat layers)
  // =========================
  const PALETTES = {
    temp: [
      {v:-15,c:[ 80,  0,120,0.62]},
      {v:  0,c:[  0,255,255,0.62]},
      {v: 15,c:[255,255,180,0.62]},
      {v: 20,c:[255,235,  0,0.62]},
      {v: 25,c:[255,190, 80,0.62]},
      {v: 30,c:[255,140,  0,0.62]},
      {v: 35,c:[255, 50, 50,0.62]},
      {v: 45,c:[120,  0,  0,0.62]}
    ],
    rain: [
      {v:0,   c:[0,0,0,0]},
      {v:0.1, c:[0,200,255,0.68]},
      {v:2,   c:[0,0,255,0.78]},
      {v:10,  c:[150,0,200,0.85]}
    ],
    rh: [
      {v:20,c:[200,150, 50,0.62]},
      {v:40,c:[200,200,200,0.62]},
      {v:60,c:[100,255,100,0.62]},
      {v:80,c:[ 50,150,255,0.70]},
      {v:95,c:[  0,  0,200,0.75]}
    ],
    // DO NOT CHANGE press (per your instruction earlier)
    press: [
      {v:980, c:[0,70,255,0.60]},
      {v:995, c:[0,170,255,0.60]},
      {v:1005,c:[0,255,200,0.60]},
      {v:1013,c:[255,255,255,0.60]},
      {v:1022,c:[255,200,0,0.60]},
      {v:1035,c:[255,60,0,0.65]}
    ],
    // Clouds: white -> dark grey (as requested)
    cloud: [
      {v:0,   c:[255,255,255,0.00]},
      {v:10,  c:[245,245,245,0.20]},
      {v:30,  c:[220,220,220,0.34]},
      {v:60,  c:[170,170,170,0.52]},
      {v:85,  c:[110,110,110,0.68]},
      {v:100, c:[ 50, 50, 50,0.78]}
    ]
  };

  function lerp(a,b,t){ return a+(b-a)*t; }

  function getColor(val, type) {
    const p = PALETTES[type];
    if(!p) return [0,0,0,0];
    if(type==='rain' && val < 0.1) return [0,0,0,0];

    if(val <= p[0].v) return p[0].c.slice();
    if(val >= p[p.length-1].v) return p[p.length-1].c.slice();

    for(let i=0; i<p.length-1; i++) {
      if(val >= p[i].v && val <= p[i+1].v) {
        const t = (val - p[i].v) / (p[i+1].v - p[i].v);
        const c1 = p[i].c, c2 = p[i+1].c;
        return [
          Math.round(lerp(c1[0], c2[0], t)),
          Math.round(lerp(c1[1], c2[1], t)),
          Math.round(lerp(c1[2], c2[2], t)),
          lerp(c1[3], c2[3], t)
        ];
      }
    }
    return p[p.length-1].c.slice();
  }

  // =========================
  // WIND color interpolation (same palette as particles)
  // =========================
  function hexToRgb(hex){
    const h = hex.replace('#','');
    const bigint = parseInt(h, 16);
    return { r:(bigint>>16)&255, g:(bigint>>8)&255, b:bigint&255 };
  }
  function windColorFromSpeed(speedMS, alpha=0.95){
    const t = Math.max(0, Math.min(1, speedMS / WIND_MAX_VELOCITY));
    const n = WIND_COLORS.length;
    const i = Math.min(n-2, Math.floor(t*(n-1)));
    const f = (t*(n-1)) - i;
    const c1 = hexToRgb(WIND_COLORS[i]);
    const c2 = hexToRgb(WIND_COLORS[i+1]);
    const r = Math.round(lerp(c1.r, c2.r, f));
    const g = Math.round(lerp(c1.g, c2.g, f));
    const b = Math.round(lerp(c1.b, c2.b, f));
    return `rgba(${r},${g},${b},${alpha})`;
  }

  // =========================
  // INIT
  // =========================
  window.addEventListener('load', async function() {
    map = L.map('map', { zoomControl: false }).setView([37.5, 14.2], 8);

    // === GRAY BASE (cartografica) + relief overlay ===
    baseGray = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, attribution: '¬©OpenStreetMap, ¬©Carto' }
    ).addTo(map);

    // hillshade on top for visible relief
    hillshade = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}',
      {
        maxZoom: 19,
        opacity: 0.78,
        className: 'hillshade-tiles',
        attribution: 'Hillshade ¬© Esri'
      }
    ).addTo(map);

    // labels
    labelsGray = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, opacity: 0.95, attribution: '¬©Carto' }
    ).addTo(map);

    createCanvasLayers();
    await loadCatalogAndFirstFrame();

    map.on('mousemove', updatePickerFromEvent);
    map.on('click', updatePickerFromEvent);

    // Default UI states
    document.getElementById('btn-wind-syn').classList.add('active');
    document.getElementById('unit-display').innerText = "Pronto";
  });

  function createCanvasLayers() {
    const mkCanvas = (z) => {
      const c = L.DomUtil.create('canvas', 'leaflet-layer');
      c.style.pointerEvents = 'none';
      c.style.zIndex = z;
      map.getPanes().overlayPane.appendChild(c);
      return c;
    };

    // heat layers (separate canvases = separable overlays)
    canvasTemp  = mkCanvas(300);
    canvasRain  = mkCanvas(310);
    canvasRH    = mkCanvas(320);
    canvasPress = mkCanvas(330);
    canvasCloud = mkCanvas(340);

    // wind syn (bg+arrows) above heat, below isobars & particles
    canvasWind = mkCanvas(380);

    // isobars top (but still below labels)
    canvasIso  = mkCanvas(420);

    map.on('moveend resize', redrawAll);
  }

  // =========================
  // DATA LOAD
  // =========================
  async function loadCatalogAndFirstFrame() {
    try {
      const r = await fetch('data_weather/catalog.json?t=' + Date.now());
      if(!r.ok) throw new Error("catalog not found");
      catalog = await r.json();
      if(!catalog || catalog.length === 0) throw new Error("empty catalog");

      const slider = document.getElementById('time-slider');
      slider.max = catalog.length - 1;
      slider.value = 0;
      slider.addEventListener('input', (e) => loadStep(parseInt(e.target.value,10)));

      await loadStep(0);
    } catch(e) {
      document.getElementById('unit-display').innerText = "Errore dati";
    }
  }

  async function loadStep(idx) {
    if(!catalog[idx]) return;
    document.getElementById('time-label').innerText = catalog[idx].label;

    try {
      const r = await fetch('data_weather/' + catalog[idx].file + '?t=' + Date.now());
      if(!r.ok) throw new Error("frame not found");
      currentData = await r.json();
      redrawAll();
    } catch(e) {}
  }

  // =========================
  // SMART OPACITY
  // =========================
  function getActiveHeatLayers() {
    const list = [];
    if(active.temp) list.push('temp');
    if(active.rain) list.push('rain');
    if(active.rh) list.push('rh');
    if(active.press) list.push('press');
    if(active.cloud) list.push('cloud');
    return list;
  }

  function layerAlphaMultiplier(layerKey, nActive) {
    // Base weights so clouds don't kill everything
    const base = {
      temp:  1.00,
      rain:  1.05,
      rh:    0.95,
      press: 0.95,
      cloud: 0.80
    }[layerKey] || 1.0;

    // Reduce with number of layers (not linear, otherwise becomes invisible)
    // n=1 => 1.00
    // n=2 => ~0.78
    // n=3 => ~0.66
    // n=4 => ~0.58
    // n=5 => ~0.52
    const k = 1 / Math.sqrt(Math.max(1, nActive));
    return base * (0.92 + 0.20*k) * k;
  }

  // Additionally: if particles are ON, reduce cloud overlay so particles are readable
  function cloudCapWhenParticles(mult) {
    if(!showParticles) return mult;
    return Math.min(mult, 0.55);
  }

  // =========================
  // DRAW PIPELINE
  // =========================
  function redrawAll() {
    if(!currentData) return;

    // draw each heat layer independently
    drawHeatLayer(canvasTemp,  'temp');
    drawHeatLayer(canvasRain,  'rain');
    drawHeatLayer(canvasRH,    'rh');
    drawHeatLayer(canvasPress, 'press');
    drawHeatLayer(canvasCloud, 'cloud');

    drawWindSynoptic();    // KEEP arrows/colors logic as you liked
    drawIsobars();         // isobars (on gray map: black + labels)
    updateWindParticles(); // particles on top
  }

  function clearCanvas(c) {
    const ctx = c.getContext('2d');
    const s = map.getSize();
    c.width = s.x; c.height = s.y;
    L.DomUtil.setPosition(c, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);
    return {ctx, s};
  }

  function drawHeatLayer(canvas, key) {
    const {ctx} = clearCanvas(canvas);

    if(!active[key] || !currentData) return;

    const m = currentData.meta;
    const b = map.getBounds();

    const activeHeat = getActiveHeatLayers();
    const n = activeHeat.length;

    // For this layer, scale alpha intelligently
    let mult = layerAlphaMultiplier(key, n);
    if(key === 'cloud') mult = cloudCapWhenParticles(mult);

    for(let y=0; y<m.ny; y++) {
      const lat = m.la1 - (y*m.dy);
      if(lat < b.getSouth()-0.12 || lat > b.getNorth()+0.12) continue;

      for(let x=0; x<m.nx; x++) {
        const lon = m.lo1 + (x*m.dx);
        if(lon < b.getWest()-0.12 || lon > b.getEast()+0.12) continue;

        const idx = y*m.nx + x;

        let val = 0;
        if(key==='temp')  val = currentData.temp[idx];
        if(key==='rain')  val = currentData.rain[idx];
        if(key==='rh')    val = currentData.rh[idx];
        if(key==='press') val = currentData.press[idx];
        if(key==='cloud') val = currentData.cloud ? currentData.cloud[idx] : 0;

        const c = getColor(val, key);
        if(c[3] <= 0) continue;

        const p1 = map.latLngToContainerPoint([lat, lon]);
        const p2 = map.latLngToContainerPoint([lat - m.dy, lon + m.dx]);
        const w = Math.ceil(p2.x - p1.x) + 1;
        const h = Math.ceil(p2.y - p1.y) + 1;

        const a = Math.max(0, Math.min(1, c[3] * mult));
        if(a <= 0.001) continue;

        ctx.fillStyle = `rgba(${c[0]},${c[1]},${c[2]},${a})`;
        ctx.fillRect(Math.floor(p1.x), Math.floor(p1.y), w, h);
      }
    }
  }

  // =========================
  // WIND SYNOPTIC (ARROWS + BACKGROUND) - DO NOT ALTER LOGIC
  // =========================
  function drawWindSynoptic() {
    const {ctx} = clearCanvas(canvasWind);

    if(!active.wind_syn || !currentData) return;

    const m = currentData.meta;
    const b = map.getBounds();

    // Background intensity (subtle)
    const bgAlpha = 0.28;

    for(let y=0; y<m.ny; y++) {
      const lat = m.la1 - (y*m.dy);
      if(lat < b.getSouth()-0.12 || lat > b.getNorth()+0.12) continue;

      for(let x=0; x<m.nx; x++) {
        const lon = m.lo1 + (x*m.dx);
        if(lon < b.getWest()-0.12 || lon > b.getEast()+0.12) continue;

        const idx = y*m.nx + x;
        const u = currentData.wind_u.data[idx];
        const v = currentData.wind_v.data[idx];
        const sp = Math.sqrt(u*u + v*v);

        const p1 = map.latLngToContainerPoint([lat, lon]);
        const p2 = map.latLngToContainerPoint([lat - m.dy, lon + m.dx]);
        const w = Math.ceil(p2.x - p1.x) + 1;
        const h = Math.ceil(p2.y - p1.y) + 1;

        ctx.fillStyle = windColorFromSpeed(sp, bgAlpha);
        ctx.fillRect(Math.floor(p1.x), Math.floor(p1.y), w, h);
      }
    }

    // Arrows
    const zoom = map.getZoom();
    const step = (zoom >= 9) ? 2 : (zoom >= 8 ? 3 : 4);
    const arrowLenBase = (zoom >= 9) ? 18 : 14;
    const arrowWidth = (zoom >= 9) ? 2.2 : 1.9;
    const arrowAlpha = 0.95;

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    for(let y=0; y<m.ny; y+=step) {
      const lat = m.la1 - (y*m.dy);
      if(lat < b.getSouth()-0.22 || lat > b.getNorth()+0.22) continue;

      for(let x=0; x<m.nx; x+=step) {
        const lon = m.lo1 + (x*m.dx);
        if(lon < b.getWest()-0.22 || lon > b.getEast()+0.22) continue;

        const idx = y*m.nx + x;
        const u = currentData.wind_u.data[idx];
        const v = currentData.wind_v.data[idx];
        const sp = Math.sqrt(u*u + v*v);
        if(!isFinite(sp) || sp < 0.3) continue;

        // Direction fix (same as before)
        const angle = Math.atan2(-v, u);

        const p = map.latLngToContainerPoint([lat, lon]);
        const L = Math.max(8, Math.min(arrowLenBase + sp*1.2, 34));

        const x2 = p.x + Math.cos(angle) * L;
        const y2 = p.y + Math.sin(angle) * L;

        const col = windColorFromSpeed(sp, arrowAlpha);

        ctx.strokeStyle = col;
        ctx.lineWidth = arrowWidth;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        const head = 6.5;
        const a1 = angle + Math.PI * 0.82;
        const a2 = angle - Math.PI * 0.82;

        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 + Math.cos(a1) * head, y2 + Math.sin(a1) * head);
        ctx.lineTo(x2 + Math.cos(a2) * head, y2 + Math.sin(a2) * head);
        ctx.closePath();
        ctx.fillStyle = col;
        ctx.fill();
      }
    }
  }

  // =========================
  // ISOBARE
  // =========================
  function drawIsobars() {
    const {ctx} = clearCanvas(canvasIso);

    if(!showIso || !currentData || !currentData.press) return;

    const m = currentData.meta;
    const values = currentData.press;

    const contours = d3.contours()
      .size([m.nx, m.ny])
      .thresholds(d3.range(960, 1050, 2))(values);

    ctx.lineWidth = 1.35;
    ctx.font = "900 12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // On GRAY map: dark isobars with labels
    contours.forEach(c => {
      ctx.strokeStyle = "rgba(0,0,0,0.70)";

      ctx.beginPath();
      const labelCandidates = [];

      c.coordinates.forEach(ring => {
        ring.forEach(pts => {
          let first = true;
          const linePts = [];
          pts.forEach(coord => {
            const lat = m.la1 - (coord[1] * m.dy);
            const lon = m.lo1 + (coord[0] * m.dx);
            const p = map.latLngToContainerPoint([lat, lon]);
            linePts.push(p);
            if(first) { ctx.moveTo(p.x, p.y); first=false; }
            else ctx.lineTo(p.x, p.y);
          });
          if(linePts.length > 80) labelCandidates.push(linePts);
        });
      });

      ctx.stroke();

      // labels
      labelCandidates.forEach(pts => {
        const mid = pts[Math.floor(pts.length/2)];
        ctx.fillStyle = "rgba(255,255,255,0.78)";
        ctx.fillRect(mid.x-16, mid.y-9, 32, 18);
        ctx.fillStyle = "#000";
        ctx.fillText(Math.round(c.value), mid.x, mid.y);
      });
    });
  }

  // =========================
  // PARTICLES (leaflet-velocity)
  // =========================
  function updateWindParticles() {
    if(velocityLayer) { map.removeLayer(velocityLayer); velocityLayer = null; }
    if(!showParticles || !currentData) return;

    // Reduce particles for FPS
    const isMobile = Math.min(window.innerWidth, window.innerHeight) < 900;
    const dpr = window.devicePixelRatio || 1;
    let particleMult = isMobile ? (1/180) : (1/140);
    if(dpr >= 2) particleMult = isMobile ? (1/260) : (1/200);

    try {
      velocityLayer = L.velocityLayer({
        displayValues: false,
        data: [ currentData.wind_u, currentData.wind_v ],
        maxVelocity: WIND_MAX_VELOCITY,
        velocityScale: WIND_VELOCITY_SCALE,
        particleMultiplier: particleMult,
        lineWidth: WIND_LINE_WIDTH,
        particleAge: WIND_PARTICLE_AGE,
        frameRate: WIND_FRAME_RATE,
        opacity: WIND_OPACITY,
        colorScale: WIND_COLORS
      });
      velocityLayer.addTo(map);
    } catch(e) {}
  }

  // =========================
  // PICKER (shows value of top ‚Äúpriority‚Äù layer)
  // Priority: temp > rain > press > rh > cloud > wind
  // =========================
  function pickerUnitAndValue(latlng) {
    if(!currentData || !currentData.meta) return null;
    const m = currentData.meta;

    const y = Math.round((m.la1 - latlng.lat) / m.dy);
    const x = Math.round((latlng.lng - m.lo1) / m.dx);
    if(x < 0 || x >= m.nx || y < 0 || y >= m.ny) return null;
    const idx = y*m.nx + x;

    const order = ['temp','rain','press','rh','cloud','wind_syn'];
    let key = null;
    for(const k of order) {
      if(k === 'wind_syn') { if(active.wind_syn) { key = 'wind'; break; } }
      else if(active[k]) { key = k; break; }
    }

    if(!key) return null;

    if(key === 'wind') {
      const u = currentData.wind_u.data[idx];
      const v = currentData.wind_v.data[idx];
      const sp = Math.sqrt(u*u+v*v);
      return { val: sp.toFixed(1), unit: "m/s" };
    }
    if(key === 'temp')  return { val: currentData.temp[idx].toFixed(1), unit: "¬∞C" };
    if(key === 'rain')  return { val: currentData.rain[idx].toFixed(1), unit: "mm" };
    if(key === 'rh')    return { val: Math.round(currentData.rh[idx]).toString(), unit: "%" };
    if(key === 'press') return { val: Math.round(currentData.press[idx]).toString(), unit: "hPa" };
    if(key === 'cloud') return { val: Math.round(currentData.cloud ? currentData.cloud[idx] : 0).toString(), unit: "%" };

    return null;
  }

  function updatePickerFromEvent(e) {
    const r = pickerUnitAndValue(e.latlng);
    if(!r) return;
    document.getElementById('val-display').innerText = r.val;
    document.getElementById('unit-display').innerText = r.unit;
  }

  // =========================
  // UI ACTIONS (MULTI TOGGLE)
  // =========================
  window.toggleLayer = function(key) {
    // wind_syn stays independent
    active[key] = !active[key];

    const btnId = 'btn-' + key;
    const btn = document.getElementById(btnId);
    if(btn) btn.classList.toggle('active', active[key]);

    redrawAll();
  };

  window.toggleParticles = function() {
    showParticles = !showParticles;
    document.getElementById('btn-particles').classList.toggle('active', showParticles);
    updateWindParticles();
    // Also redraw heat layers because clouds opacity is capped when particles ON
    redrawAll();
  };

  window.toggleIso = function() {
    showIso = !showIso;
    document.getElementById('btn-iso').classList.toggle('active', showIso);
    redrawAll();
  };

  window.togglePlay = function() {
    if(isPlaying) { isPlaying = false; document.getElementById('play-btn').innerText = "‚ñ∫"; return; }
    isPlaying = true;

    const s = document.getElementById('time-slider');
    const btn = document.getElementById('play-btn');
    btn.innerText = "‚ùö‚ùö";

    let i = parseInt(s.value, 10);
    const max = parseInt(s.max, 10);

    const interval = setInterval(() => {
      if(!isPlaying) { clearInterval(interval); btn.innerText = "‚ñ∫"; return; }
      if(i >= max) { clearInterval(interval); isPlaying=false; btn.innerText="‚ñ∫"; return; }
      i++;
      s.value = i;
      loadStep(i);
    }, 800);
  };
</script>

</body>
</html>