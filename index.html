<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - ULTIMATE</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin: 0; background: #202020; font-family: 'Segoe UI', sans-serif; color: white; overflow: hidden; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #202020; }

    /* UI */
    #ui-container { position: absolute; top: 10px; right: 10px; z-index: 1000; display: flex; flex-direction: column; gap: 8px; align-items: flex-end; }
    .panel { background: rgba(20,20,20,0.9); backdrop-filter: blur(8px); padding: 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.15); box-shadow: 0 4px 15px rgba(0,0,0,0.5); }

    .layer-btn {
      display: block; width: 140px; padding: 10px; margin-bottom: 4px;
      background: transparent; color: #bbb; border: none; text-align: right;
      cursor: pointer; font-size: 13px; font-weight: 700; border-radius: 6px;
      transition: all .2s; border-right: 3px solid transparent;
    }
    .layer-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
    .layer-btn.active { background: linear-gradient(90deg, rgba(0,100,255,0.1), rgba(0,100,255,0.3)); color: #fff; border-right: 3px solid #0088ff; }
    
    .layer-btn.toggle { color: #888; font-size: 11px; margin-top: 4px; border-top: 1px solid rgba(255,255,255,0.1); padding-top:8px;}
    .layer-btn.toggle.active { color: #fff; border-right: 3px solid #fff; }

    .map-toggle {
      padding: 6px 10px; background: rgba(255,255,255,0.1); color: #aaa;
      border: 1px solid rgba(255,255,255,0.2); border-radius: 6px;
      cursor: pointer; font-size: 11px; font-weight: bold;
    }
    .map-toggle.active { background: #0088ff; color: #fff; border-color: #0088ff; }

    /* INFO & BOTTOM BAR */
    #info-box { position: absolute; top: 20px; left: 20px; z-index: 1000; pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
    #val-display { font-size: 3.5em; font-weight: 900; line-height: 0.9; letter-spacing: -1px; }
    #unit-display { font-size: 1.2em; color: #ccc; font-weight: 700; margin-left: 5px; }

    #bottom-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: 90px;
      background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0) 100%);
      display: flex; align-items: center; padding: 0 20px 20px 20px; z-index: 2000;
    }
    #play-btn { font-size: 2.2em; background: none; border: none; color: #fff; cursor: pointer; margin-right: 15px; }
    #time-label { font-size: 1.3em; font-weight: 700; margin-left: 15px; min-width: 140px; text-align: center; font-variant-numeric: tabular-nums; }
    input[type=range] { flex-grow: 1; height: 4px; cursor: pointer; accent-color: #0088ff; background: rgba(255,255,255,0.3); border-radius: 2px; }

    /* LEGENDA */
    #legend-container { margin-top: 8px; }
    #legend-bar { width: 100%; height: 10px; border-radius: 5px; border: 1px solid rgba(255,255,255,0.3); }
    #legend-labels { display: flex; justify-content: space-between; font-size: 9px; color: #aaa; margin-top: 2px; font-weight: bold;}

    /* TRUCCO PER LA MAPPA:
       Usiamo CSS per gestire il blending.
       In Dark Mode: 'overlay' o 'hard-light' per fondersi col rilievo scuro.
       In Sat Mode: 'normal' per non sparire sul bianco.
    */
    canvas.leaflet-layer { 
        image-rendering: auto; /* Sfumatura attiva (No Pixelloso) */
        transition: opacity 0.3s;
    }
    
    body.mode-dark canvas.leaflet-layer.scalar-layer {
        mix-blend-mode: hard-light; /* Colori vibranti su scuro */
        opacity: 0.65;
    }
    
    body.mode-sat canvas.leaflet-layer.scalar-layer {
        mix-blend-mode: normal; /* Normale su satellite */
        opacity: 0.60;
    }

  </style>
</head>

<body class="mode-dark">

  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">Caricamento...</div>
  </div>

  <div id="ui-container">
    <div class="panel" style="display:flex; gap:6px; justify-content: flex-end;">
      <button class="map-toggle active" onclick="setBase('dark')">DARK</button>
      <button class="map-toggle" onclick="setBase('sat')">SAT</button>
    </div>

    <div class="panel">
      <button class="layer-btn active" onclick="toggleLayer('wind')">VENTO üí®</button>
      <button class="layer-btn" onclick="toggleLayer('temp')">TEMP üå°Ô∏è</button>
      <button class="layer-btn" onclick="toggleLayer('rain')">PIOGGIA ‚òî</button>
      <button class="layer-btn" onclick="toggleLayer('rh')">UMIDIT√Ä üíß</button>
      <button class="layer-btn" onclick="toggleLayer('press')">PRESSIONE ‚è≤Ô∏è</button>
      <button class="layer-btn" onclick="toggleLayer('clouds')">NUVOLE ‚òÅÔ∏è</button>
      
      <div id="legend-container">
          <div id="legend-bar"></div>
          <div id="legend-labels"><span id="l-min"></span><span id="l-max"></span></div>
      </div>

      <button class="layer-btn toggle" id="btn-iso" onclick="toggleIso()">ISOBARE „Ä∞Ô∏è</button>
      <button class="layer-btn toggle" id="btn-grid" onclick="toggleGrid()">GRIGLIA #</button>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  let map, velocityLayer, isoCanvas, gridCanvas;
  const scalarCanvases = {};
  const scalarOffscreen = {}; 
  let currentData = null, catalog = [];
  let showIso = false, showGrid = false, isPlaying = false;
  let baseLayers = {}, labelsLayers = {}, hillshadeLayer = null;
  let baseMode = 'dark';
  const enabled = { wind: true, temp: false, rain: false, rh: false, press: false, clouds: false };

  // =========================
  // PALETTE "DENSE" (Ogni 2 gradi = Colore Netto)
  // Questo crea l'effetto "Banding" senza pixellare la geometria
  // =========================
  const TEMP_STOPS = [
    {v:-10, c:[255,255,255]}, {v:-8, c:[255,200,255]}, {v:-6, c:[255,0,255]}, 
    {v:-4, c:[200,0,200]}, {v:-2, c:[150,0,150]}, {v:0, c:[0,0,150]},
    {v:2, c:[0,0,200]}, {v:4, c:[0,50,255]}, {v:6, c:[0,100,255]}, 
    {v:8, c:[0,160,255]}, {v:10, c:[0,200,255]}, {v:12, c:[0,220,150]}, 
    {v:14, c:[0,200,0]}, {v:16, c:[50,220,0]}, {v:18, c:[120,240,0]}, 
    {v:20, c:[200,255,0]}, {v:22, c:[255,255,0]}, {v:24, c:[255,200,0]}, 
    {v:26, c:[255,150,0]}, {v:28, c:[255,100,0]}, {v:30, c:[255,50,0]}, 
    {v:32, c:[255,0,0]}, {v:34, c:[200,0,0]}, {v:36, c:[150,0,0]}, 
    {v:38, c:[100,0,0]}, {v:40, c:[80,0,0]}, {v:42, c:[180,100,100]}
  ];

  const RAIN_STOPS = [
    {v:0.1, c:[150,230,255]}, {v:1, c:[100,200,255]}, {v:3, c:[50,150,255]},
    {v:5, c:[0,100,255]}, {v:10, c:[0,0,255]}, {v:20, c:[100,0,200]},
    {v:40, c:[200,0,200]}, {v:80, c:[255,0,255]}, {v:150, c:[255,255,0]}
  ];

  const RH_STOPS = [
    {v:10, c:[200,100,50]}, {v:30, c:[255,200,0]}, {v:50, c:[200,255,100]},
    {v:70, c:[100,255,100]}, {v:90, c:[50,200,255]}, {v:99, c:[0,100,255]}
  ];

  // Funzione Stepped (Netta)
  function colorStepped(val, stops){
    if(val <= stops[0].v) return stops[0].c;
    if(val >= stops[stops.length-1].v) return stops[stops.length-1].c;
    for(let i=0; i < stops.length-1; i++){
        if(val >= stops[i].v && val < stops[i+1].v) return stops[i].c;
    }
    return stops[stops.length-1].c;
  }

  function unitFor(layer){
    if(layer==='wind') return 'km/h'; if(layer==='temp') return '¬∞C';
    if(layer==='rain') return 'mm'; if(layer==='rh') return '%';
    if(layer==='press') return 'hPa'; if(layer==='clouds') return '%';
    return '';
  }

  // =========================
  // INIT
  // =========================
  window.addEventListener('load', async () => {
    map = L.map('map', { zoomControl:false }).setView([37.5, 14.2], 8);

    // BASE LAYERS
    baseLayers.dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', { maxZoom: 19 }).addTo(map);
    baseLayers.sat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19 });

    // HILLSHADE (Questo fa la magia del rilievo)
    hillshadeLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}', { 
        maxZoom: 19, opacity: 0.6 // Opacit√† bilanciata
    }).addTo(map);

    // LABELS
    map.createPane('labelsPane'); map.getPane('labelsPane').style.zIndex = 600; map.getPane('labelsPane').style.pointerEvents = 'none';
    labelsLayers.dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', { pane: 'labelsPane', opacity: 0.8 }).addTo(map);
    labelsLayers.sat = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { pane: 'labelsPane', opacity: 0.9 });

    createCanvasLayers();
    await loadCatalog();
    
    map.on('mousemove', updatePickerFromEvent);
    map.on('click', updatePickerFromEvent);
    document.getElementById('unit-display').innerText = "Pronto";
    updateLegendUI();
  });

  window.setBase = function(type){
    document.querySelectorAll('.map-toggle').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
    baseMode = type;
    document.body.className = type==='dark' ? 'mode-dark' : 'mode-sat';

    if(type==='dark'){
      map.removeLayer(baseLayers.sat); baseLayers.dark.addTo(map);
      map.removeLayer(labelsLayers.sat); labelsLayers.dark.addTo(map);
    } else {
      map.removeLayer(baseLayers.dark); baseLayers.sat.addTo(map);
      map.removeLayer(labelsLayers.dark); labelsLayers.sat.addTo(map);
    }
    // Ridisegna per aggiornare il blending mode
    redrawAll();
    updateWind();
  }

  function createCanvasLayers(){
    const mkCanvas = (z) => {
      const c = L.DomUtil.create('canvas', 'leaflet-layer scalar-layer'); // Aggiunta classe per CSS
      c.style.pointerEvents = 'none';
      c.style.zIndex = z;
      // TRUCCO ANTI-PIXEL: Usiamo 'auto' (smoothing) per la geometria, ma i colori sono stepped
      c.style.imageRendering = 'auto'; 
      map.getPanes().overlayPane.appendChild(c);
      return c;
    };
    scalarCanvases.temp   = mkCanvas(300);
    scalarCanvases.rain   = mkCanvas(310);
    scalarCanvases.rh     = mkCanvas(320);
    scalarCanvases.press  = mkCanvas(330);
    scalarCanvases.clouds = mkCanvas(340);
    isoCanvas  = mkCanvas(420);
    gridCanvas = mkCanvas(450);
    map.on('moveend resize', redrawAll);
  }

  async function loadCatalog(){
    try{
      const r = await fetch('data_weather/catalog.json?t=' + Date.now());
      catalog = await r.json();
      const s = document.getElementById('time-slider');
      s.max = catalog.length-1;
      s.addEventListener('input', e => loadStep(parseInt(e.target.value)));
      await loadStep(0);
    } catch(e){ document.getElementById('unit-display').innerText = "No Data"; }
  }

  async function loadStep(idx){
    if(!catalog[idx]) return;
    document.getElementById('time-label').innerText = catalog[idx].label;
    try{
      const r = await fetch('data_weather/' + catalog[idx].file + '?t=' + Date.now());
      currentData = await r.json();
      for(const k of Object.keys(scalarOffscreen)) delete scalarOffscreen[k];
      redrawAll();
    }catch(e){}
  }

  window.toggleLayer = function(layer){
    enabled[layer] = !enabled[layer];
    event.target.classList.toggle('active', enabled[layer]);
    document.getElementById('unit-display').innerText = unitFor(layer);
    updateLegendUI();
    redrawAll();
  }

  function updateLegendUI() {
      const bar = document.getElementById('legend-bar');
      const min = document.getElementById('l-min');
      const max = document.getElementById('l-max');
      let active = 'wind';
      if(enabled.temp) active = 'temp';
      else if(enabled.rain) active = 'rain';
      else if(enabled.rh) active = 'rh';
      
      if(active === 'temp') {
          bar.style.background = 'linear-gradient(to right, #fff, #f0f, #00f, #0ff, #0f0, #ff0, #f00, #500)';
          min.innerText = "-10¬∞"; max.innerText = "+42¬∞";
      } else if(active === 'wind') {
          bar.style.background = 'linear-gradient(to right, #004, #00f, #0f0, #ff0, #f00, #f0f)';
          min.innerText = "0"; max.innerText = "100 km/h";
      } else {
          bar.style.background = 'transparent'; min.innerText = ""; max.innerText = "";
      }
  }

  window.toggleIso = function(){ showIso = !showIso; document.getElementById('btn-iso').classList.toggle('active'); redrawAll(); }
  window.toggleGrid = function(){ showGrid = !showGrid; document.getElementById('btn-grid').classList.toggle('active'); redrawAll(); }

  // =========================
  // RENDER & BLENDING
  // =========================
  function redrawAll(){
    if(!currentData || !currentData.meta) return;
    drawScalarsHD();
    drawIsobars();
    drawGrid();
    updateWind();
  }

  function drawScalarsHD(){
    const m = currentData.meta;
    const bounds = { nw: L.latLng(m.la1, m.lo1), se: L.latLng(m.la2, m.lo2) };
    const nw = map.latLngToContainerPoint(bounds.nw);
    const se = map.latLngToContainerPoint(bounds.se);
    const w = Math.ceil(se.x - nw.x);
    const h = Math.ceil(se.y - nw.y);

    for(const layer of ['temp','press','rain','rh','clouds']){
      const canvas = scalarCanvases[layer];
      const ctx = canvas.getContext('2d');
      const size = map.getSize();
      canvas.width = size.x; canvas.height = size.y;
      L.DomUtil.setPosition(canvas, map.containerPointToLayerPoint([0,0]));
      ctx.clearRect(0,0,size.x,size.y);

      if(!enabled[layer]) continue;

      const off = getOrBuildOffscreen(layer, m);
      if(!off) continue;

      ctx.save();
      // Nota: Blending e Opacit√† sono gestiti dal CSS per Dark/Sat
      // Qui dobbiamo solo abilitare lo smoothing per avere forme morbide
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      ctx.drawImage(off.c, Math.floor(nw.x), Math.floor(nw.y), w, h);
      ctx.restore();
    }
  }

  function getOrBuildOffscreen(layer, meta){
    const key = layer + '|' + (meta.refTime || '');
    if(scalarOffscreen[layer] && scalarOffscreen[layer].key === key) return scalarOffscreen[layer];

    const nx = meta.nx, ny = meta.ny;
    const c = document.createElement('canvas');
    c.width = nx; c.height = ny;
    const ctx = c.getContext('2d');
    const img = ctx.createImageData(nx, ny);
    const data = img.data;

    let arr = null;
    if(layer==='temp') arr = currentData.temp;
    else if(layer==='press') arr = currentData.press;
    else if(layer==='rain') arr = currentData.rain;
    else if(layer==='rh') arr = currentData.rh;
    else if(layer==='clouds') arr = currentData.cloud || currentData.clouds;

    if(!arr) return null;

    for(let i=0; i<nx*ny; i++){
      let v = arr[i];
      let rgb = [0,0,0], a = 0;

      if(layer === 'temp'){
        rgb = colorStepped(v, TEMP_STOPS); 
        a = 255; // Opacit√† piena sulla texture (gestita poi in drawImage/CSS)
      } 
      else if(layer === 'rain' && v > 0.1){
        rgb = colorStepped(v, RAIN_STOPS);
        a = 255;
      }
      else if(layer === 'rh'){
        rgb = colorStepped(v, RH_STOPS);
        a = 255;
      }
      else if(layer === 'clouds'){
        rgb = [v*2.5, v*2.5, v*2.5];
        a = Math.min(255, v * 2);
      }

      const p = i*4;
      data[p] = rgb[0]; data[p+1] = rgb[1]; data[p+2] = rgb[2]; data[p+3] = a;
    }

    ctx.putImageData(img, 0, 0);
    scalarOffscreen[layer] = { c, ctx, img, key };
    return scalarOffscreen[layer];
  }

  function drawIsobars(){
    const ctx = isoCanvas.getContext('2d');
    const size = map.getSize();
    isoCanvas.width = size.x; isoCanvas.height = size.y;
    L.DomUtil.setPosition(isoCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,size.x,size.y);

    if(!showIso || !currentData || !currentData.press) return;
    const m = currentData.meta;
    const contours = d3.contours().size([m.nx, m.ny]).thresholds(d3.range(960, 1050, 2))(currentData.press);

    ctx.lineWidth = 1.0;
    // Colore Isobare adattivo
    ctx.strokeStyle = baseMode==='dark' ? "rgba(255,255,255,0.6)" : "rgba(0,0,0,0.6)";
    
    contours.forEach(c => {
      ctx.beginPath();
      c.coordinates.forEach(ring => {
        ring.forEach(pts => {
          let first = true;
          pts.forEach(coord => {
            const lat = m.la1 - (coord[1] * m.dy);
            const lon = m.lo1 + (coord[0] * m.dx);
            const p = map.latLngToContainerPoint([lat, lon]);
            if(first){ ctx.moveTo(p.x,p.y); first=false; } else ctx.lineTo(p.x,p.y);
          });
        });
      });
      ctx.stroke();
    });
  }

  function drawGrid(){
    const ctx = gridCanvas.getContext('2d');
    const size = map.getSize();
    gridCanvas.width = size.x; gridCanvas.height = size.y;
    L.DomUtil.setPosition(gridCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,size.x,size.y);
    if(!showGrid) return;
    const step = 0.5; const b = map.getBounds();
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.beginPath();
    for(let lon=Math.floor(b.getWest()); lon<=Math.ceil(b.getEast()); lon+=step){
        const x = map.latLngToContainerPoint([b.getSouth(), lon]).x;
        ctx.moveTo(x, 0); ctx.lineTo(x, size.y);
    }
    for(let lat=Math.floor(b.getSouth()); lat<=Math.ceil(b.getNorth()); lat+=step){
        const y = map.latLngToContainerPoint([lat, b.getWest()]).y;
        ctx.moveTo(0, y); ctx.lineTo(size.x, y);
    }
    ctx.stroke();
  }

  function updateWind(){
    if(velocityLayer) { map.removeLayer(velocityLayer); velocityLayer = null; }
    if(!enabled.wind || !currentData) return;
    
    // Colori Vento Adattivi
    const windColors = baseMode==='dark' 
        ? ["#004", "#00f", "#0f0", "#ff0", "#f00"]
        : ["#000", "#00f", "#080", "#a80", "#a00"]; // Pi√π scuri su satellite
    
    velocityLayer = L.velocityLayer({
      displayValues: false,
      data: [ currentData.wind_u, currentData.wind_v ],
      maxVelocity: 18.0,
      velocityScale: 0.005,
      particleMultiplier: 1/180,
      lineWidth: 1.0,
      particleAge: 100,
      frameRate: 40,
      opacity: 0.9,
      colorScale: windColors
    });
    velocityLayer.addTo(map);
  }

  function updatePickerFromEvent(e){
    if(!currentData) return;
    const m = currentData.meta;
    const y = Math.round((m.la1 - e.latlng.lat) / m.dy);
    const x = Math.round((e.latlng.lng - m.lo1) / m.dx);
    if(x<0||x>=m.nx||y<0||y>=m.ny) return;
    const idx = y*m.nx + x;
    let val = '--', unit = '';
    if(enabled.wind) {
        const u = currentData.wind_u.data[idx], v = currentData.wind_v.data[idx];
        val = (Math.sqrt(u*u+v*v)*3.6).toFixed(1); unit = 'km/h';
    } else if(enabled.temp) { val = currentData.temp[idx].toFixed(1); unit = '¬∞C'; }
    else if(enabled.rain) { val = currentData.rain[idx].toFixed(1); unit = 'mm'; }
    document.getElementById('val-display').innerText = val;
    document.getElementById('unit-display').innerText = unit;
  }

  window.togglePlay = function(){
    if(isPlaying){ isPlaying=false; document.getElementById('play-btn').innerText="‚ñ∫"; return; }
    isPlaying=true; document.getElementById('play-btn').innerText="‚ùö‚ùö";
    const s = document.getElementById('time-slider');
    let i = parseInt(s.value);
    const interval = setInterval(() => {
        if(!isPlaying || i>=s.max){ clearInterval(interval); isPlaying=false; document.getElementById('play-btn').innerText="‚ñ∫"; return; }
        i++; s.value=i; loadStep(i);
    }, 800);
  }
</script>
</body>
</html>
