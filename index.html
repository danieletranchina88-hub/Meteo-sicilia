<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - PRO (RELIEF + WIND ARROWS + PARTICLES)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin: 0; background: #111; font-family: 'Segoe UI', sans-serif; color: white; overflow: hidden; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #111; }

    /* UI */
    #ui-container { position: absolute; top: 10px; right: 10px; z-index: 1000; display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
    .panel { background: rgba(0,0,0,0.78); backdrop-filter: blur(6px); padding: 8px; border-radius: 14px; border: 1px solid rgba(255,255,255,0.18); }
    .layer-btn {
      display: block; width: 160px; padding: 10px 12px; margin-bottom: 6px;
      background: transparent; color: #d6d6d6; border: none; text-align: right;
      cursor: pointer; font-size: 13px; font-weight: 800; border-radius: 10px;
      transition: all 0.15s;
    }
    .layer-btn:hover { background: rgba(255,255,255,0.10); color: #fff; }
    .layer-btn.active { background: #1e6bff; color: white; }

    .map-toggle {
      padding: 8px 12px; background: rgba(255,255,255,0.08); color: #fff;
      border: 1px solid rgba(255,255,255,0.22); border-radius: 10px;
      cursor: pointer; font-size: 12px; font-weight: 900;
      transition: all 0.15s;
    }
    .map-toggle:hover { background: rgba(255,255,255,0.14); }
    .map-toggle.active { background: #eaeaea; color: #000; }

    /* info */
    #info-box { position: absolute; top: 18px; left: 18px; z-index: 1000; pointer-events: none; text-shadow: 0 3px 12px rgba(0,0,0,0.95); }
    #val-display { font-size: 3.4em; font-weight: 950; line-height: 1; }
    #unit-display { font-size: 1.15em; color: rgba(255,255,255,0.75); font-weight: 800; }

    /* bottom bar */
    #bottom-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: 92px;
      background: linear-gradient(to top, rgba(0,0,0,0.92), transparent);
      display: flex; align-items: center; padding: 0 16px; z-index: 2000;
    }
    #play-btn { font-size: 2.4em; background: none; border: none; color: white; cursor: pointer; margin-right: 12px; }
    #time-label { font-size: 1.2em; font-weight: 950; margin-left: 12px; min-width: 140px; text-align: center; text-shadow: 0 2px 10px rgba(0,0,0,0.95); }
    input[type=range] { flex-grow: 1; height: 5px; cursor: pointer; accent-color: #1e6bff; }

    /* canvases */
    canvas { image-rendering: auto; }
  </style>
</head>

<body>
  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">Caricamento...</div>
  </div>

  <div id="ui-container">
    <div class="panel" style="display:flex; gap:6px;">
      <button class="map-toggle active" onclick="setBase('relief')">RELIEF</button>
      <button class="map-toggle" onclick="setBase('sat')">SAT</button>
    </div>

    <div class="panel">
      <!-- NOTA: multi-layer = toggle ON/OFF -->
      <button class="layer-btn active" onclick="toggleOverlay('wind')">VENTO üí®</button>
      <button class="layer-btn" onclick="toggleOverlay('temp')">TEMP üå°Ô∏è</button>
      <button class="layer-btn" onclick="toggleOverlay('rain')">PIOGGIA ‚òî</button>
      <button class="layer-btn" onclick="toggleOverlay('rh')">UMIDIT√Ä üíß</button>
      <button class="layer-btn" onclick="toggleOverlay('press')">PRESSIONE ‚è≤Ô∏è</button>
      <button class="layer-btn" onclick="toggleOverlay('clouds')">NUVOLE ‚òÅÔ∏è</button>

      <hr style="border:0; border-top:1px solid rgba(255,255,255,0.18); margin:8px 0;">

      <button class="layer-btn" id="btn-iso" onclick="toggleIso()">ISOBARE „Ä∞Ô∏è</button>
      <button class="layer-btn" id="btn-particles" onclick="toggleParticles()">PARTICELLE ‚ü≤</button>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  // =========================
  // GLOBALS
  // =========================
  var map;
  var baseLayers = {};
  var labelLayers = {};
  var currentBase = 'relief';

  // canvases
  var heatCanvas, isoCanvas, arrowsCanvas;

  // wind particles (leaflet-velocity)
  var velocityLayer = null;
  var showParticles = false;

  // data
  var currentData = null, catalog = [];
  var showIso = false, isPlaying = false;

  // Multi-layer: Set di overlay attivi
  // wind √® ON di default
  var activeOverlays = new Set(['wind']);

  // Sicilia bounds (per "non andare nel mondo")
  const SICILY_BOUNDS = L.latLngBounds(
    L.latLng(35.0, 11.0),
    L.latLng(39.6, 16.6)
  );

  // =========================
  // COLOR: Temperature discrete per grado (-15..45) con ancore (come hai chiesto)
  // =========================
  const TEMP_MIN = -15;
  const TEMP_MAX = 45;

  // Ancore: -15 viola scuro -> 0 ciano -> 15 giallo chiaro -> 20 giallo -> 25 arancione chiaro -> 30 arancione -> 35 rosso -> 45 rosso scuro
  const TEMP_ANCHORS = [
    {v:-15, rgb:[60,  0, 110]},   // viola scuro
    {v:  0, rgb:[ 0, 220, 255]},  // ciano
    {v: 15, rgb:[255, 255, 150]}, // giallo chiaro
    {v: 20, rgb:[255, 230,   0]}, // giallo
    {v: 25, rgb:[255, 170,  70]}, // arancione chiaro
    {v: 30, rgb:[255, 120,   0]}, // arancione
    {v: 35, rgb:[255,  30,  30]}, // rosso
    {v: 45, rgb:[120,   0,   0]}  // rosso scuro
  ];

  function lerp(a,b,t){ return a+(b-a)*t; }

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  // Interpolazione ‚Äúviva‚Äù: piccolo boost di contrasto per evitare ‚Äútutto uguale‚Äù
  // (quantizziamo per GRADO e usiamo lookup: ogni grado ha un colore suo)
  function buildTempLUT() {
    const lut = {};
    for(let T=TEMP_MIN; T<=TEMP_MAX; T++){
      // trova segmento di ancore
      let a = TEMP_ANCHORS[0], b = TEMP_ANCHORS[TEMP_ANCHORS.length-1];
      for(let i=0;i<TEMP_ANCHORS.length-1;i++){
        if(T >= TEMP_ANCHORS[i].v && T <= TEMP_ANCHORS[i+1].v){
          a = TEMP_ANCHORS[i]; b = TEMP_ANCHORS[i+1]; break;
        }
      }
      const t = (T - a.v) / (b.v - a.v);
      let r = Math.round(lerp(a.rgb[0], b.rgb[0], t));
      let g = Math.round(lerp(a.rgb[1], b.rgb[1], t));
      let bl = Math.round(lerp(a.rgb[2], b.rgb[2], t));

      // boost contrasto leggero: saturazione ‚Äúpercepita‚Äù (senza HSL pesante)
      // spinge un po‚Äô lontano dal grigio
      const mid = (r+g+bl)/3;
      r = Math.round(clamp(mid + (r-mid)*1.12, 0, 255));
      g = Math.round(clamp(mid + (g-mid)*1.12, 0, 255));
      bl = Math.round(clamp(mid + (bl-mid)*1.12, 0, 255));

      lut[T] = [r,g,bl];
    }
    return lut;
  }
  const TEMP_LUT = buildTempLUT();

  // =========================
  // OTHER PALETTES (pi√π ‚Äúnetti‚Äù e brillanti)
  // =========================
  const PALETTES = {
    rain: [
      {v:0.0,  c:[0,0,0,0]},
      {v:0.1,  c:[ 70, 220, 255, 0.55]},
      {v:2.0,  c:[  0, 120, 255, 0.65]},
      {v:10.0, c:[140,   0, 220, 0.75]},
      {v:30.0, c:[255,   0, 140, 0.78]}
    ],
    rh: [
      {v:10, c:[220,180, 80, 0.45]},
      {v:40, c:[210,210,210, 0.50]},
      {v:60, c:[120,255,120, 0.55]},
      {v:80, c:[ 80,170,255, 0.62]},
      {v:95, c:[ 30, 60,220, 0.70]}
    ],
    // NON cambiamo la tua logica di pressione: blu(bassa)->rosso(alta)
    press: [
      {v:980,  c:[  0, 70,255, 0.52]},
      {v:995,  c:[  0,170,255, 0.52]},
      {v:1005, c:[  0,255,200, 0.52]},
      {v:1013, c:[255,255,255, 0.52]},
      {v:1022, c:[255,200,  0, 0.55]},
      {v:1035, c:[255, 60,  0, 0.60]}
    ],
    // Nuvole: bianco -> grigio scuro, pi√π opache e distinguibili
    // Assumiamo valore 0..100 (% copertura). Se il tuo JSON √® 0..1, lo gestiamo sotto.
    clouds: [
      {v:0,   c:[255,255,255,0.00]},
      {v:10,  c:[245,245,245,0.22]},
      {v:30,  c:[220,220,220,0.35]},
      {v:60,  c:[160,160,160,0.50]},
      {v:85,  c:[ 90, 90, 90,0.62]},
      {v:100, c:[ 40, 40, 40,0.70]}
    ]
  };

  function getColorStops(val, type) {
    const p = PALETTES[type];
    if(!p) return [0,0,0,0];

    if(type === 'rain' && val < 0.1) return [0,0,0,0];

    for(let i=0; i<p.length-1; i++) {
      if(val >= p[i].v && val <= p[i+1].v) {
        const t = (val - p[i].v) / (p[i+1].v - p[i].v);
        const c1 = p[i].c, c2 = p[i+1].c;
        return [
          Math.round(lerp(c1[0], c2[0], t)),
          Math.round(lerp(c1[1], c2[1], t)),
          Math.round(lerp(c1[2], c2[2], t)),
          lerp(c1[3], c2[3], t)
        ];
      }
    }
    const last = p[p.length-1].c;
    return [last[0], last[1], last[2], last[3]];
  }

  function unitFor(type){
    if(type==='wind') return 'km/h';
    if(type==='temp') return '¬∞C';
    if(type==='rain') return 'mm';
    if(type==='rh') return '%';
    if(type==='press') return 'hPa';
    if(type==='clouds') return '%';
    return '';
  }

  // =========================
  // INIT
  // =========================
  window.addEventListener('load', async function() {
    map = L.map('map', { zoomControl: false, maxBounds: SICILY_BOUNDS, maxBoundsViscosity: 1.0 })
      .setView([37.5, 14.2], 7);

    map.setMinZoom(6);
    map.setMaxZoom(11);

    // --- BASE: Relief grigio (come screenshot) ---
    // (Esri Terrain Base: rilievi + colori ‚Äúterrain‚Äù chiari; noi vogliamo grigio)
    // Usiamo Hillshade + Gray Base per ‚Äúmeteo sinottica‚Äù pulita e leggibile.
    baseLayers.relief = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 16, attribution: '¬© Esri, ¬© OpenStreetMap contributors' }
    ).addTo(map);

    // Hillshade sopra (rilievo evidente)
    baseLayers.relief_hs = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 16, opacity: 0.55, attribution: 'Hillshade ¬© Esri' }
    ).addTo(map);

    // Labels sopra (citt√†)
    labelLayers.relief = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 16, opacity: 0.95, attribution: 'Labels ¬© Esri' }
    ).addTo(map);

    // --- SAT (satellite) + labels ---
    baseLayers.sat = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 16, attribution: 'Imagery ¬© Esri' }
    );

    labelLayers.sat = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 16, opacity: 0.95, attribution: 'Places ¬© Esri' }
    );

    createCanvasLayers();
    await loadCatalogAndFirstFrame();

    map.on('mousemove', updatePickerFromEvent);
    map.on('click', updatePickerFromEvent);

    document.getElementById('unit-display').innerText = unitFor('wind');
  });

  function setBase(type) {
    document.querySelectorAll('.map-toggle').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');

    // cleanup base+labels
    Object.values(baseLayers).forEach(l => { if(l && map.hasLayer(l)) map.removeLayer(l); });
    Object.values(labelLayers).forEach(l => { if(l && map.hasLayer(l)) map.removeLayer(l); });

    currentBase = type;

    if(type === 'relief') {
      baseLayers.relief.addTo(map);
      baseLayers.relief_hs.addTo(map);
      labelLayers.relief.addTo(map);
    } else {
      baseLayers.sat.addTo(map);
      labelLayers.sat.addTo(map);
    }

    redrawAll();
  }

  // =========================
  // DATA LOAD
  // =========================
  async function loadCatalogAndFirstFrame() {
    try {
      const r = await fetch('data_weather/catalog.json?t=' + Date.now());
      if(!r.ok) throw new Error("catalog not found");
      catalog = await r.json();
      if(!catalog || catalog.length === 0) throw new Error("empty catalog");

      const slider = document.getElementById('time-slider');
      slider.max = catalog.length - 1;
      slider.value = 0;
      slider.addEventListener('input', (e) => loadStep(parseInt(e.target.value,10)));

      await loadStep(0);
      document.getElementById('unit-display').innerText = "Pronto";
    } catch(e) {
      document.getElementById('unit-display').innerText = "Errore dati";
    }
  }

  async function loadStep(idx) {
    if(!catalog[idx]) return;
    document.getElementById('time-label').innerText = catalog[idx].label;

    try {
      const r = await fetch('data_weather/' + catalog[idx].file + '?t=' + Date.now());
      if(!r.ok) throw new Error("frame not found");
      currentData = await r.json();

      redrawAll();
    } catch(e) {}
  }

  // =========================
  // CANVAS LAYERS
  // =========================
  function createCanvasLayers() {
    const mkCanvas = (z) => {
      const c = L.DomUtil.create('canvas', 'leaflet-layer');
      c.style.pointerEvents = 'none';
      c.style.zIndex = z;
      map.getPanes().overlayPane.appendChild(c);
      return c;
    };

    heatCanvas   = mkCanvas(300); // scalari (temp/rain/rh/press/clouds + wind background)
    isoCanvas    = mkCanvas(380); // isobare
    arrowsCanvas = mkCanvas(420); // frecce vento

    map.on('moveend resize zoomend', redrawAll);
  }

  function resizeCanvasToMap(c) {
    const s = map.getSize();
    c.width = s.x;
    c.height = s.y;
    L.DomUtil.setPosition(c, map.containerPointToLayerPoint([0,0]));
    return s;
  }

  function redrawAll() {
    if(!currentData) return;
    drawScalarOverlaysHD();
    drawIsobars();
    drawWindArrows();
    updateWindParticles();
  }

  // =========================
  // MULTI-LAYER TOGGLE
  // =========================
  window.toggleOverlay = function(type) {
    // toggle
    if(activeOverlays.has(type)) activeOverlays.delete(type);
    else activeOverlays.add(type);

    // aggiorna UI
    document.querySelectorAll('.layer-btn').forEach(btn => {
      const t = btn.getAttribute('onclick') || '';
      if(t.includes(`'${type}'`)) btn.classList.toggle('active', activeOverlays.has(type));
    });

    // unit display: mostra l‚Äôultima selezionata ‚Äúsensata‚Äù
    if(type !== 'wind') document.getElementById('unit-display').innerText = unitFor(type);
    else document.getElementById('unit-display').innerText = unitFor('wind');

    redrawAll();
  };

  // =========================
  // SCALAR OVERLAYS in "HD" (NO QUADRATI):
  // - creiamo una bitmap nx*ny e la "stiriamo" con smoothing sul rettangolo del dominio
  // =========================
  function gridDomainToScreenRect(meta) {
    const northWest = L.latLng(meta.la1, meta.lo1);
    const southEast = L.latLng(meta.la2, meta.lo2);
    const p1 = map.latLngToContainerPoint(northWest);
    const p2 = map.latLngToContainerPoint(southEast);

    // rettangolo in pixel
    const x = Math.min(p1.x, p2.x);
    const y = Math.min(p1.y, p2.y);
    const w = Math.abs(p2.x - p1.x);
    const h = Math.abs(p2.y - p1.y);
    return {x,y,w,h};
  }

  function getScalarArray(type) {
    if(!currentData) return null;

    if(type === 'temp') return currentData.temp;
    if(type === 'rain') return currentData.rain;
    if(type === 'rh') return currentData.rh;
    if(type === 'press') return currentData.press;

    // nuvole: supporta "clouds" o "tcc" ecc se presente
    if(type === 'clouds') {
      if(currentData.clouds) return currentData.clouds;
      if(currentData.tcc) return currentData.tcc;
      return null;
    }

    // background vento: velocit√† (km/h) da u/v
    if(type === 'windbg') {
      const u = currentData.wind_u?.data;
      const v = currentData.wind_v?.data;
      if(!u || !v) return null;
      const out = new Array(u.length);
      for(let i=0;i<u.length;i++){
        const sp = Math.sqrt(u[i]*u[i] + v[i]*v[i]) * 3.6;
        out[i] = sp;
      }
      return out;
    }

    return null;
  }

  // palette vento background (stessa scala ‚Äúparticelle‚Äù, brillante ma leggibile)
  const WIND_BG_STOPS = [
    {v:0,   c:[ 60,  80, 255, 0.00]},
    {v:10,  c:[ 60,  80, 255, 0.28]},
    {v:20,  c:[  0, 210, 255, 0.34]},
    {v:35,  c:[  0, 255, 120, 0.40]},
    {v:50,  c:[255, 255,   0, 0.46]},
    {v:70,  c:[255, 130,   0, 0.52]},
    {v:90,  c:[255,   0,   0, 0.58]},
    {v:110, c:[255,   0, 255, 0.62]}
  ];

  function colorFromStops(val, stops) {
    if(val <= stops[0].v) return stops[0].c;
    for(let i=0;i<stops.length-1;i++){
      const a = stops[i], b = stops[i+1];
      if(val >= a.v && val <= b.v){
        const t = (val-a.v)/(b.v-a.v);
        return [
          Math.round(lerp(a.c[0], b.c[0], t)),
          Math.round(lerp(a.c[1], b.c[1], t)),
          Math.round(lerp(a.c[2], b.c[2], t)),
          lerp(a.c[3], b.c[3], t)
        ];
      }
    }
    return stops[stops.length-1].c;
  }

  function drawScalarOverlaysHD() {
    const ctx = heatCanvas.getContext('2d');
    const s = resizeCanvasToMap(heatCanvas);
    ctx.clearRect(0,0,s.x,s.y);
    if(!currentData || !currentData.meta) return;

    const m = currentData.meta;
    const rect = gridDomainToScreenRect(m);

    // niente da disegnare se fuori schermo
    if(rect.w < 2 || rect.h < 2) return;

    // Offscreen: bitmap nx*ny
    const off = document.createElement('canvas');
    off.width = m.nx;
    off.height = m.ny;
    const octx = off.getContext('2d', { willReadFrequently: false });
    const img = octx.createImageData(m.nx, m.ny);
    const data = img.data;

    // ordine overlay: prima background vento (se wind attivo), poi gli altri (cos√¨ puoi sovrapporre)
    // IMPORTANTE: ogni overlay ha alpha proprio, quindi resta trasparente come vuoi tu
    const order = [];
    if(activeOverlays.has('wind')) order.push('windbg');
    ['temp','press','rain','rh','clouds'].forEach(t => { if(activeOverlays.has(t)) order.push(t); });

    if(order.length === 0) return;

    // per evitare ‚Äúimpasto‚Äù: riduciamo un filo alpha del windbg se ci sono altri layer
    const hasOther = order.some(x => x !== 'windbg');
    const windbgAlphaFactor = hasOther ? 0.78 : 1.00;

    // compone overlay uno sopra l‚Äôaltro direttamente nel buffer (semplice alpha-composite)
    // (evitiamo drawImage multipli: una sola bitmap finale = pi√π fluido su mobile)
    const accum = new Float32Array(m.nx * m.ny * 4); // RGBA accumulati

    function blendPixel(i, r,g,b,a){
      const idx = i*4;
      const dstA = accum[idx+3];
      const srcA = a;
      const outA = srcA + dstA*(1-srcA);
      if(outA <= 0.00001) return;

      accum[idx+0] = (r*srcA + accum[idx+0]*dstA*(1-srcA)) / outA;
      accum[idx+1] = (g*srcA + accum[idx+1]*dstA*(1-srcA)) / outA;
      accum[idx+2] = (b*srcA + accum[idx+2]*dstA*(1-srcA)) / outA;
      accum[idx+3] = outA;
    }

    for(const layer of order){
      const arr = getScalarArray(layer);
      if(!arr || arr.length !== m.nx*m.ny) continue;

      for(let i=0;i<arr.length;i++){
        let v = arr[i];

        // clouds: se 0..1 converti a 0..100
        if(layer === 'clouds') {
          if(v <= 1.01) v = v * 100.0;
        }

        let c;
        if(layer === 'temp') {
          const T = Math.round(clamp(v, TEMP_MIN, TEMP_MAX));
          const rgb = TEMP_LUT[T];
          // opacit√†: come il tuo esempio (visibile ma lascia vedere sotto)
          c = [rgb[0], rgb[1], rgb[2], 0.50];
        } else if(layer === 'windbg') {
          c = colorFromStops(v, WIND_BG_STOPS);
          c = [c[0],c[1],c[2], c[3]*windbgAlphaFactor];
        } else {
          c = getColorStops(v, layer);
          // rendi un filo pi√π evidente gli altri layer (senza farli coprire)
          if(layer === 'press') c[3] = Math.min(0.56, c[3] + 0.06);
          if(layer === 'rain')  c[3] = Math.min(0.70, c[3] + 0.06);
          if(layer === 'rh')    c[3] = Math.min(0.62, c[3] + 0.05);
          if(layer === 'clouds') c[3] = Math.min(0.72, c[3] + 0.08);
        }

        if(c[3] <= 0) continue;
        blendPixel(i, c[0],c[1],c[2], c[3]);
      }
    }

    // scrivi bitmap finale
    for(let i=0;i<m.nx*m.ny;i++){
      const idx = i*4;
      data[idx+0] = Math.round(accum[idx+0] || 0);
      data[idx+1] = Math.round(accum[idx+1] || 0);
      data[idx+2] = Math.round(accum[idx+2] || 0);
      data[idx+3] = Math.round(clamp((accum[idx+3] || 0)*255, 0, 255));
    }

    octx.putImageData(img, 0, 0);

    // draw "HD" (smooth)
    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(off, rect.x, rect.y, rect.w, rect.h);
    ctx.restore();
  }

  // =========================
  // ISOBARE + LABEL su linee
  // =========================
  function drawIsobars() {
    const ctx = isoCanvas.getContext('2d');
    const s = resizeCanvasToMap(isoCanvas);
    ctx.clearRect(0,0,s.x,s.y);

    if(!showIso || !currentData || !currentData.press) return;

    const m = currentData.meta;
    const values = currentData.press;

    // step 2 hPa (sinottico pulito)
    const contours = d3.contours()
      .size([m.nx, m.ny])
      .thresholds(d3.range(960, 1050, 2))(values);

    // richiesto: su mappa grigia, bianche ben visibili
    ctx.lineWidth = 1.6;
    ctx.strokeStyle = "rgba(255,255,255,0.88)";
    ctx.font = "900 12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    contours.forEach(c => {
      ctx.beginPath();
      const labelCandidates = [];

      c.coordinates.forEach(ring => {
        ring.forEach(pts => {
          let first = true;
          const linePts = [];
          pts.forEach(coord => {
            const lat = m.la1 - (coord[1] * m.dy);
            const lon = m.lo1 + (coord[0] * m.dx);
            const p = map.latLngToContainerPoint([lat, lon]);
            linePts.push(p);
            if(first) { ctx.moveTo(p.x, p.y); first=false; }
            else ctx.lineTo(p.x, p.y);
          });
          if(linePts.length > 70) labelCandidates.push(linePts);
        });
      });

      ctx.stroke();

      // label (valore pressione) su ogni isolinea principale
      labelCandidates.slice(0, 3).forEach(pts => {
        const mid = pts[Math.floor(pts.length/2)];
        const val = Math.round(c.value);

        // box scuro trasparente dietro al testo
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(mid.x-18, mid.y-9, 36, 18);

        ctx.fillStyle = "#fff";
        ctx.fillText(val.toString(), mid.x, mid.y);
      });
    });
  }

  window.toggleIso = function() {
    showIso = !showIso;
    document.getElementById('btn-iso').classList.toggle('active', showIso);
    redrawAll();
  };

  // =========================
  // WIND ARROWS (sinottico): direzione + intensit√†
  // (NON tocchiamo la tua logica ‚Äúgi√† perfetta‚Äù: qui √® una versione stabile e leggibile)
  // =========================
  function drawWindArrows() {
    const ctx = arrowsCanvas.getContext('2d');
    const s = resizeCanvasToMap(arrowsCanvas);
    ctx.clearRect(0,0,s.x,s.y);

    if(!currentData || !currentData.wind_u || !currentData.wind_v) return;
    if(!activeOverlays.has('wind')) return;

    const m = currentData.meta;
    const u = currentData.wind_u.data;
    const v = currentData.wind_v.data;

    // densit√† frecce: adattiva allo zoom (pi√π zoom = pi√π frecce)
    const z = map.getZoom();
    const step = (z <= 6) ? 10 : (z === 7 ? 8 : (z === 8 ? 6 : 5));

    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    for(let gy=0; gy<m.ny; gy+=step){
      for(let gx=0; gx<m.nx; gx+=step){
        const idx = gy*m.nx + gx;
        const uu = u[idx], vv = v[idx];
        const sp = Math.sqrt(uu*uu + vv*vv) * 3.6; // km/h

        // posizione
        const lat = m.la1 - (gy*m.dy);
        const lon = m.lo1 + (gx*m.dx);
        const p = map.latLngToContainerPoint([lat, lon]);

        // fuori schermo
        if(p.x < -20 || p.x > s.x+20 || p.y < -20 || p.y > s.y+20) continue;

        // direzione: attenzione: u est, v nord. Per canvas y cresce verso il basso.
        const ang = Math.atan2(-vv, uu);

        // lunghezza: aumenta con intensit√†, ma clamp per leggibilit√†
        const L = clamp(6 + sp*0.18, 7, 20);

        // colore: stessi colori ‚Äúparticelle‚Äù, ma applicati alle frecce
        const c = colorFromStops(sp, WIND_BG_STOPS);
        // freccia pi√π ‚Äúpresente‚Äù su base chiara/grigia
        const alpha = (currentBase === 'sat') ? 0.90 : 0.85;
        ctx.strokeStyle = `rgba(${c[0]},${c[1]},${c[2]},${alpha})`;
        ctx.lineWidth = 2.0;

        // disegno freccia
        ctx.beginPath();
        const x2 = p.x + Math.cos(ang)*L;
        const y2 = p.y + Math.sin(ang)*L;
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        // punta
        const head = 4.5;
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - Math.cos(ang-0.55)*head, y2 - Math.sin(ang-0.55)*head);
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - Math.cos(ang+0.55)*head, y2 - Math.sin(ang+0.55)*head);
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  // =========================
  // WIND PARTICLES (toggle): scure + leggere (FPS)
  // =========================
  window.toggleParticles = function () {
    showParticles = !showParticles;
    document.getElementById('btn-particles').classList.toggle('active', showParticles);
    updateWindParticles();
  };

  function updateWindParticles() {
    if(velocityLayer) { map.removeLayer(velocityLayer); velocityLayer = null; }
    if(!activeOverlays.has('wind') || !currentData) return;

    // particelle sempre rimovibili
    if(!showParticles) return;

    const isMobile = Math.min(window.innerWidth, window.innerHeight) < 900;
    const dpr = window.devicePixelRatio || 1;

    // meno particelle = pi√π FPS
    let particleMult = isMobile ? (1/300) : (1/210);
    if(dpr >= 2) particleMult = isMobile ? (1/380) : (1/270);

    // se hai altri overlay oltre il vento, rendi le particelle meno invadenti
    const hasOtherOverlay = Array.from(activeOverlays).some(x => x !== 'wind');
    const particleOpacity = hasOtherOverlay ? 0.28 : 0.48;

    const particleColor = `rgba(0,0,0,${particleOpacity})`;

    try {
      velocityLayer = L.velocityLayer({
        displayValues: false,
        data: [ currentData.wind_u, currentData.wind_v ],
        maxVelocity: 18.0,
        velocityScale: 0.006,

        // performance
        particleMultiplier: particleMult,
        particleAge: 80,
        lineWidth: 0.9,
        opacity: 1.0,

        // scure
        colorScale: [particleColor]
      });
      velocityLayer.addTo(map);
    } catch(e) {}
  }

  // =========================
  // PICKER (valore al click)
  // =========================
  function valueAtLatLng(latlng, type) {
    if(!currentData || !currentData.meta) return null;
    const m = currentData.meta;

    const y = Math.round((m.la1 - latlng.lat) / m.dy);
    const x = Math.round((latlng.lng - m.lo1) / m.dx);
    if(x < 0 || x >= m.nx || y < 0 || y >= m.ny) return null;

    const idx = y*m.nx + x;

    if(type === 'wind') {
      const u = currentData.wind_u.data[idx];
      const v = currentData.wind_v.data[idx];
      return Math.sqrt(u*u + v*v) * 3.6;
    }
    if(type === 'temp' && currentData.temp) return currentData.temp[idx];
    if(type === 'rain' && currentData.rain) return currentData.rain[idx];
    if(type === 'rh' && currentData.rh) return currentData.rh[idx];
    if(type === 'press' && currentData.press) return currentData.press[idx];

    if(type === 'clouds') {
      const arr = currentData.clouds || currentData.tcc;
      if(!arr) return null;
      let v = arr[idx];
      if(v <= 1.01) v = v*100;
      return v;
    }

    return null;
  }

  function updatePickerFromEvent(e) {
    // Mostra valore del primo overlay ‚Äúin cima‚Äù (priorit√†: temp, press, rain, rh, clouds, wind)
    const priority = ['temp','press','rain','rh','clouds','wind'];
    let chosen = null;
    for(const t of priority){
      if(activeOverlays.has(t)) { chosen = t; break; }
    }
    if(!chosen) chosen = 'wind';

    const val = valueAtLatLng(e.latlng, chosen);
    if(val === null || val === undefined) return;

    let out = '--';
    if(chosen === 'wind') out = val.toFixed(1);
    else if(chosen === 'temp') out = val.toFixed(1);
    else if(chosen === 'rain') out = val.toFixed(1);
    else if(chosen === 'rh') out = Math.round(val).toString();
    else if(chosen === 'press') out = Math.round(val).toString();
    else if(chosen === 'clouds') out = Math.round(val).toString();

    document.getElementById('val-display').innerText = out;
    document.getElementById('unit-display').innerText = unitFor(chosen);
  }

  // =========================
  // PLAY
  // =========================
  window.togglePlay = function() {
    if(isPlaying) { isPlaying = false; document.getElementById('play-btn').innerText = "‚ñ∫"; return; }
    isPlaying = true;

    const s = document.getElementById('time-slider');
    const btn = document.getElementById('play-btn');
    btn.innerText = "‚ùö‚ùö";

    let i = parseInt(s.value, 10);
    const max = parseInt(s.max, 10);

    const interval = setInterval(() => {
      if(!isPlaying) { clearInterval(interval); btn.innerText = "‚ñ∫"; return; }
      if(i >= max) { clearInterval(interval); isPlaying=false; btn.innerText="‚ñ∫"; return; }
      i++;
      s.value = i;
      loadStep(i);
    }, 800);
  };
</script>

</body>
</html>
```Ó®Å0Ó®Ç