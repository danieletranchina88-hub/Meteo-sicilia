<!DOCTYPE html>
<html>
<head>
  <title>Sicilia MeteoHub - PRO (Sinottica)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.css" />
  <script src="https://unpkg.com/leaflet-velocity@1.8.0/dist/leaflet-velocity.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body { margin: 0; background: #111; font-family: 'Segoe UI', sans-serif; color: white; overflow: hidden; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #111; }

    /* UI */
    #ui-container {
      position: absolute; top: 10px; right: 10px; z-index: 2000;
      display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
    }
    .panel {
      background: rgba(0,0,0,0.82);
      backdrop-filter: blur(8px);
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
    }
    .layer-row { display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .toggle {
      width: 160px;
      display:flex; align-items:center; justify-content:space-between;
      padding: 10px 12px; margin: 6px 0;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color: #ddd;
      border-radius: 10px;
      cursor: pointer;
      user-select:none;
      font-weight: 800;
      letter-spacing: 0.2px;
      transition: all 0.15s;
    }
    .toggle:hover { background: rgba(255,255,255,0.10); color:#fff; }
    .toggle.active {
      background: linear-gradient(90deg, rgba(0,136,255,0.95), rgba(0,60,160,0.95));
      border-color: rgba(120,180,255,0.55);
      color: #fff;
      box-shadow: 0 0 16px rgba(0,136,255,0.35);
    }
    .mini {
      width: 160px;
      padding: 9px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color:#ddd;
      cursor:pointer;
      font-weight:900;
    }
    .mini:hover { background: rgba(255,255,255,0.10); color:#fff; }
    .mini.active {
      background: rgba(255,255,255,0.18);
      border-color: rgba(255,255,255,0.25);
      color:#fff;
    }

    /* Info */
    #info-box { position: absolute; top: 18px; left: 18px; z-index: 2000; pointer-events: none; text-shadow: 0 2px 10px rgba(0,0,0,0.9); }
    #val-display { font-size: 3.6em; font-weight: 950; line-height: 1; }
    #unit-display { font-size: 1.15em; color: #cfcfcf; font-weight: 850; margin-top: 4px; }

    /* Bottom */
    #bottom-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: 92px;
      background: linear-gradient(to top, rgba(0,0,0,0.92), transparent);
      display: flex; align-items: center; padding: 0 18px; z-index: 2000;
    }
    #play-btn { font-size: 2.6em; background: none; border: none; color: white; cursor: pointer; margin-right: 14px; }
    #time-label { font-size: 1.45em; font-weight: 950; margin-left: 14px; min-width: 150px; text-align: center; text-shadow: 0 2px 12px rgba(0,0,0,0.95); }
    input[type=range] { flex-grow: 1; height: 6px; cursor: pointer; accent-color: #0088ff; }

    /* Base-map relief look */
    .hillshade-tiles { mix-blend-mode: multiply; filter: contrast(1.85) brightness(0.95); }

    /* Canvas */
    canvas.leaflet-layer { image-rendering: auto; }
  </style>
</head>

<body>
  <div id="info-box">
    <div id="val-display">--</div>
    <div id="unit-display">Caricamento...</div>
  </div>

  <div id="ui-container">
    <div class="panel">
      <button id="btn-flow" class="mini active" onclick="toggleParticles()">FLUSSO üå¨Ô∏è (ON)</button>
    </div>

    <div class="panel">
      <div style="font-weight:950; opacity:0.9; margin-bottom:6px;">LIVELLI (multi)</div>

      <div class="toggle active" onclick="toggleLayer('wind')">
        <span>VENTO (frecce) üß≠</span><span id="dot-wind">‚óè</span>
      </div>

      <div class="toggle" onclick="toggleLayer('temp')">
        <span>TEMP üå°Ô∏è</span><span id="dot-temp">‚óè</span>
      </div>

      <div class="toggle" onclick="toggleLayer('rain')">
        <span>PIOGGIA ‚òî</span><span id="dot-rain">‚óè</span>
      </div>

      <div class="toggle" onclick="toggleLayer('rh')">
        <span>UMIDIT√Ä üíß</span><span id="dot-rh">‚óè</span>
      </div>

      <div class="toggle" onclick="toggleLayer('press')">
        <span>PRESSIONE ‚è≤Ô∏è</span><span id="dot-press">‚óè</span>
      </div>

      <div class="toggle" onclick="toggleLayer('cloud')">
        <span>NUVOLE ‚òÅÔ∏è</span><span id="dot-cloud">‚óè</span>
      </div>

      <div style="height:1px; background: rgba(255,255,255,0.16); margin:10px 0;"></div>

      <div class="toggle" id="btn-iso" onclick="toggleIsobars()">
        <span>ISOBARE „Ä∞Ô∏è</span><span> </span>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <div id="bottom-bar">
    <button id="play-btn" onclick="togglePlay()">‚ñ∫</button>
    <input type="range" id="time-slider" min="0" max="0" value="0">
    <div id="time-label">--/-- --:--</div>
  </div>

<script>
  // =========================
  // CONFIG
  // =========================

  // Bounding box Sicilia (coerente col tuo python)
  const SICILY_BOUNDS = L.latLngBounds(
    L.latLng(35.0, 11.0),
    L.latLng(39.5, 16.5)
  );

  // Colori vento (identici ai tuoi originali)
  const WIND_COLOR_SCALE_DARK = ["#000080", "#0044ff", "#00ddff", "#00ff55", "#ffff00", "#ff6600", "#ff0000", "#ff00ff"];

  // Versione pi√π scura/contrastata per basemap chiara (stessa logica, pi√π ‚Äúink‚Äù)
  const WIND_COLOR_SCALE_LIGHT = ["#00004d", "#002c99", "#007a99", "#007a2a", "#b38f00", "#b34700", "#990000", "#800080"];

  // Palette temperatura richiesta: -15 viola scuro -> 0 ciano -> 15 giallo chiaro -> 20 giallo -> 25 arancione chiaro -> 30 arancione -> 35 rosso -> 45 rosso scuro
  const TEMP_STOPS = [
    {v:-15, c:[55, 0, 110]},   // viola scuro
    {v:  0, c:[0, 220, 255]},  // ciano
    {v: 15, c:[255, 255, 160]},// giallo chiaro
    {v: 20, c:[255, 235, 0]},  // giallo
    {v: 25, c:[255, 170, 70]}, // arancione chiaro
    {v: 30, c:[255, 120, 0]},  // arancione
    {v: 35, c:[235, 30, 0]},   // rosso
    {v: 45, c:[120, 0, 0]}     // rosso scuro
  ];

  // Nuvole: bianco -> grigio scuro (0 trasparente)
  const CLOUD_STOPS = [
    {v:  0, c:[0,0,0],   a:0.00},
    {v: 20, c:[235,235,235], a:0.22},
    {v: 50, c:[190,190,190], a:0.34},
    {v: 80, c:[120,120,120], a:0.48},
    {v:100, c:[60,60,60],    a:0.62}
  ];

  // Pioggia, RH, Pressione (lasciate coerenti con la tua logica precedente)
  const RAIN_STOPS = [
    {v:0.0,  c:[0,0,0], a:0.00},
    {v:0.1,  c:[0,200,255], a:0.40},
    {v:2.0,  c:[0,0,255],   a:0.55},
    {v:10.0, c:[150,0,200], a:0.70}
  ];

  const RH_STOPS = [
    {v:20,c:[200,150,50], a:0.35},
    {v:40,c:[210,210,210], a:0.33},
    {v:60,c:[110,255,120], a:0.35},
    {v:80,c:[60,160,255],  a:0.40},
    {v:95,c:[0,0,200],     a:0.45}
  ];

  // Pressione: NON cambio ‚Äúschema‚Äù che ti piaceva (blu->rosso senza buchi)
  const PRESS_STOPS = [
    {v:980,  c:[0,70,255],   a:0.38},
    {v:995,  c:[0,170,255],  a:0.38},
    {v:1005, c:[0,255,200],  a:0.38},
    {v:1013, c:[255,255,255],a:0.40},
    {v:1022, c:[255,200,0],  a:0.38},
    {v:1035, c:[255,60,0],   a:0.42}
  ];

  // =========================
  // GLOBALS
  // =========================
  let map;
  let baseGray, baseRef, baseHill;
  let isLightBase = true; // la tua mappa grigia √® "chiara" come base

  let currentData = null;
  let catalog = [];

  // Multi-layer selection
  const selected = new Set(['wind']); // default: vento frecce ON
  let showIsobars = false;

  // Particles overlay (sempre possibile, indipendente dai layer)
  let particlesOn = true;
  let velocityLayer = null;

  // Canvas layers
  let heatCanvas, windBgCanvas, arrowCanvas, isoCanvas;

  // Play
  let isPlaying = false;
  let playTimer = null;

  // =========================
  // UTILS
  // =========================
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function lerp(a,b,t){ return a+(b-a)*t; }

  function interpStops(val, stops) {
    if(!stops || stops.length < 2) return {r:0,g:0,b:0,a:0};
    if(val <= stops[0].v) {
      const s = stops[0]; return {r:s.c[0],g:s.c[1],b:s.c[2],a:('a' in s)?s.a:0.4};
    }
    for(let i=0;i<stops.length-1;i++){
      const s1=stops[i], s2=stops[i+1];
      if(val>=s1.v && val<=s2.v){
        const t=(val-s1.v)/(s2.v-s1.v);
        const a1=('a'in s1)?s1.a:0.4, a2=('a'in s2)?s2.a:0.4;
        return {
          r:Math.round(lerp(s1.c[0],s2.c[0],t)),
          g:Math.round(lerp(s1.c[1],s2.c[1],t)),
          b:Math.round(lerp(s1.c[2],s2.c[2],t)),
          a:lerp(a1,a2,t)
        };
      }
    }
    const s=stops[stops.length-1];
    return {r:s.c[0],g:s.c[1],b:s.c[2],a:('a'in s)?s.a:0.4};
  }

  function speedAtIdx(idx){
    if(!currentData) return 0;
    const u=currentData.wind_u?.data?.[idx] ?? 0;
    const v=currentData.wind_v?.data?.[idx] ?? 0;
    return Math.sqrt(u*u+v*v); // m/s
  }

  function windColorForSpeed(speedMs){
    // Mappa speed (0..18 m/s) -> colorScale 8 stop
    const scale = isLightBase ? WIND_COLOR_SCALE_LIGHT : WIND_COLOR_SCALE_DARK;
    const maxV = 18.0;
    const t = clamp(speedMs / maxV, 0, 0.999999);
    const n = scale.length;
    const pos = t*(n-1);
    const i = Math.floor(pos);
    const f = pos - i;

    // parse hex
    function hexToRgb(h){
      const x = h.replace('#','');
      return {r:parseInt(x.slice(0,2),16), g:parseInt(x.slice(2,4),16), b:parseInt(x.slice(4,6),16)};
    }
    const c1 = hexToRgb(scale[i]);
    const c2 = hexToRgb(scale[Math.min(i+1,n-1)]);
    return {
      r:Math.round(lerp(c1.r,c2.r,f)),
      g:Math.round(lerp(c1.g,c2.g,f)),
      b:Math.round(lerp(c1.b,c2.b,f))
    };
  }

  function unitForPicker(){
    // Mostra unit√† ‚Äúsensata‚Äù rispetto a cosa stai puntando (priorit√†: layer pi√π ‚Äúpesante‚Äù attivo)
    if(selected.has('temp')) return '¬∞C';
    if(selected.has('rain')) return 'mm';
    if(selected.has('press')) return 'hPa';
    if(selected.has('rh')) return '%';
    if(selected.has('cloud')) return '%';
    if(selected.has('wind')) return 'km/h';
    return '';
  }

  function valueForPicker(latlng){
    if(!currentData?.meta) return null;
    const m = currentData.meta;
    const y = Math.round((m.la1 - latlng.lat) / m.dy);
    const x = Math.round((latlng.lng - m.lo1) / m.dx);
    if(x<0||x>=m.nx||y<0||y>=m.ny) return null;
    const idx=y*m.nx+x;

    // Priorit√†: temp > rain > press > rh > cloud > wind
    if(selected.has('temp')) return {v: currentData.temp[idx], fmt: (z)=>z.toFixed(1)};
    if(selected.has('rain')) return {v: currentData.rain[idx], fmt: (z)=>z.toFixed(1)};
    if(selected.has('press')) return {v: currentData.press[idx], fmt: (z)=>Math.round(z).toString()};
    if(selected.has('rh')) return {v: currentData.rh[idx], fmt: (z)=>Math.round(z).toString()};
    if(selected.has('cloud')) {
      const arr = (currentData.cloud ?? currentData.cld ?? currentData.tcc);
      if(Array.isArray(arr)) return {v: arr[idx], fmt: (z)=>Math.round(z).toString()};
    }
    // vento (km/h)
    const sp = speedAtIdx(idx) * 3.6;
    return {v: sp, fmt: (z)=>z.toFixed(1)};
  }

  // =========================
  // INIT
  // =========================
  window.addEventListener('load', async () => {
    map = L.map('map', {
      zoomControl: false,
      maxBounds: SICILY_BOUNDS.pad(0.22),
      maxBoundsViscosity: 0.9
    }).fitBounds(SICILY_BOUNDS);

    // Base: ESRI Light Gray Canvas + hillshade + reference labels
    baseGray = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution: 'Tiles ¬© Esri' }
    ).addTo(map);

    baseHill = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, opacity: 0.85, className: 'hillshade-tiles', attribution: 'Hillshade ¬© Esri' }
    ).addTo(map);

    baseRef = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution: 'Labels ¬© Esri' }
    ).addTo(map);

    createCanvasLayers();
    await loadCatalog();

    map.on('mousemove', onPick);
    map.on('click', onPick);

    // Redraw on move
    map.on('moveend zoomend resize', () => redrawAll());

    document.getElementById('unit-display').innerText = unitForPicker();
  });

  function createCanvasLayers(){
    function mkCanvas(z){
      const c = L.DomUtil.create('canvas', 'leaflet-layer');
      c.style.pointerEvents = 'none';
      c.style.zIndex = z;
      map.getPanes().overlayPane.appendChild(c);
      return c;
    }
    // z-order: heatmaps < wind background < arrows < isobars < particles (velocity pane is separate)
    heatCanvas   = mkCanvas(300);
    windBgCanvas = mkCanvas(340);
    arrowCanvas  = mkCanvas(380);
    isoCanvas    = mkCanvas(420);
  }

  // =========================
  // DATA
  // =========================
  async function loadCatalog(){
    try{
      const r = await fetch('data_weather/catalog.json?t=' + Date.now());
      if(!r.ok) throw new Error('catalog missing');
      catalog = await r.json();
      if(!catalog?.length) throw new Error('catalog empty');

      const slider = document.getElementById('time-slider');
      slider.max = catalog.length - 1;
      slider.value = 0;
      slider.addEventListener('input', (e)=> loadStep(parseInt(e.target.value,10)));

      await loadStep(0);
      document.getElementById('unit-display').innerText = unitForPicker();
    } catch(e){
      document.getElementById('unit-display').innerText = 'Errore dati';
    }
  }

  async function loadStep(i){
    if(!catalog[i]) return;
    document.getElementById('time-label').innerText = catalog[i].label;
    try{
      const r = await fetch('data_weather/' + catalog[i].file + '?t=' + Date.now());
      if(!r.ok) throw new Error('frame missing');
      currentData = await r.json();
      redrawAll();
    } catch(e){}
  }

  // =========================
  // DRAW PIPELINE
  // =========================
  function redrawAll(){
    if(!currentData) return;

    drawHeatmapsHD();
    drawWindBackground();
    drawWindArrows();
    drawIsobars();

    // Particelle: SEMPRE possibili e indipendenti dai layer
    updateParticles();
  }

  // --- HD heatmaps (NO quadrati): render su griglia offscreen e poi scala con smoothing ---
  function drawHeatmapsHD(){
    const ctx = heatCanvas.getContext('2d');
    const s = map.getSize();
    heatCanvas.width = s.x;
    heatCanvas.height = s.y;
    L.DomUtil.setPosition(heatCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    if(!currentData?.meta) return;

    // Se nessun layer ‚Äúgriglia‚Äù √® selezionato, niente heat
    const gridLayers = ['temp','rain','rh','press','cloud'];
    const activeGrids = gridLayers.filter(k => selected.has(k));
    if(activeGrids.length === 0) return;

    const m = currentData.meta;

    // Opacit√† intelligente: pi√π layer => meno alpha per ciascuno, ma senza diventare invisibile
    const alphaFactor = clamp(1.0 / Math.sqrt(activeGrids.length), 0.45, 1.0);

    // Offscreen a risoluzione griglia
    const off = document.createElement('canvas');
    off.width = m.nx;
    off.height = m.ny;
    const octx = off.getContext('2d', { willReadFrequently: false });
    const img = octx.createImageData(m.nx, m.ny);
    const data = img.data;

    // Helper: prendi array del layer
    function getArr(layer){
      if(layer==='temp') return currentData.temp;
      if(layer==='rain') return currentData.rain;
      if(layer==='rh') return currentData.rh;
      if(layer==='press') return currentData.press;
      if(layer==='cloud') return (currentData.cloud ?? currentData.cld ?? currentData.tcc);
      return null;
    }

    // Per evitare ‚Äúdominanza‚Äù di un layer solo, disegniamo uno per volta
    activeGrids.forEach(layer => {
      const arr = getArr(layer);
      if(!Array.isArray(arr)) return;

      // reset offscreen pixels a trasparente ogni layer
      data.fill(0);

      for(let y=0;y<m.ny;y++){
        for(let x=0;x<m.nx;x++){
          const idx = y*m.nx + x;
          let val = arr[idx] ?? 0;

          // unit√†/normalizzazioni:
          // - cloud: ci aspettiamo 0..100
          // - rain: gi√† mm
          // - temp: ¬∞C
          // - rh: %
          // - press: hPa

          let col;
          if(layer==='temp') col = interpStops(val, TEMP_STOPS);
          else if(layer==='rain') col = interpStops(val, RAIN_STOPS);
          else if(layer==='rh') col = interpStops(val, RH_STOPS);
          else if(layer==='press') col = interpStops(val, PRESS_STOPS);
          else if(layer==='cloud') col = interpStops(val, CLOUD_STOPS);
          else col = {r:0,g:0,b:0,a:0};

          // Filtri trasparenza minimi per ‚Äúsporcare‚Äù meno
          if(layer==='rain' && val < 0.1) col.a = 0;
          if(layer==='cloud' && val < 5) col.a = 0;

          // Applica alphaFactor e ‚Äúboost‚Äù per colori pi√π evidenti (come richiesto), mantenendo trasparenza
          let a = col.a * alphaFactor;

          // Boost controllato: aumentiamo saturazione percepita via alpha (non altera la gradazione)
          if(layer==='temp') a *= 1.20;
          if(layer==='press') a *= 1.15;
          if(layer==='rain') a *= 1.25;
          if(layer==='cloud') a *= 1.15;
          if(layer==='rh') a *= 1.10;

          a = clamp(a, 0, 0.82);

          const p = (y*m.nx + x)*4;
          data[p+0] = col.r;
          data[p+1] = col.g;
          data[p+2] = col.b;
          data[p+3] = Math.round(a*255);
        }
      }

      octx.putImageData(img, 0, 0);

      // Proietta sull‚Äôarea Sicilia in pixel (rettangolo)
      const topLeft = map.latLngToContainerPoint([m.la1, m.lo1]);
      const bottomRight = map.latLngToContainerPoint([m.la2, m.lo2]);

      const x0 = Math.min(topLeft.x, bottomRight.x);
      const y0 = Math.min(topLeft.y, bottomRight.y);
      const w  = Math.abs(bottomRight.x - topLeft.x);
      const h  = Math.abs(bottomRight.y - topLeft.y);

      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.globalCompositeOperation = 'source-over';
      ctx.drawImage(off, x0, y0, w, h);
      ctx.restore();
    });
  }

  // --- Wind intensity background (solo se layer vento selezionato) ---
  function drawWindBackground(){
    const ctx = windBgCanvas.getContext('2d');
    const s = map.getSize();
    windBgCanvas.width = s.x;
    windBgCanvas.height = s.y;
    L.DomUtil.setPosition(windBgCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    if(!selected.has('wind') || !currentData?.meta) return;

    const m = currentData.meta;

    // Offscreen a griglia
    const off = document.createElement('canvas');
    off.width = m.nx;
    off.height = m.ny;
    const octx = off.getContext('2d');
    const img = octx.createImageData(m.nx, m.ny);
    const d = img.data;

    for(let y=0;y<m.ny;y++){
      for(let x=0;x<m.nx;x++){
        const idx = y*m.nx + x;
        const sp = speedAtIdx(idx); // m/s
        const c = windColorForSpeed(sp);
        // sfondo ‚Äúsinottico‚Äù leggero, cos√¨ non copre gli altri layer
        const a = 0.18; // fisso, leggero ma visibile
        const p = idx*4;
        d[p+0]=c.r; d[p+1]=c.g; d[p+2]=c.b; d[p+3]=Math.round(a*255);
      }
    }
    octx.putImageData(img, 0, 0);

    const topLeft = map.latLngToContainerPoint([m.la1, m.lo1]);
    const bottomRight = map.latLngToContainerPoint([m.la2, m.lo2]);

    const x0 = Math.min(topLeft.x, bottomRight.x);
    const y0 = Math.min(topLeft.y, bottomRight.y);
    const w  = Math.abs(bottomRight.x - topLeft.x);
    const h  = Math.abs(bottomRight.y - topLeft.y);

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(off, x0, y0, w, h);
    ctx.restore();
  }

  // --- Wind arrows (pi√π evidenti, pi√π numerose, direzione coerente con u/v) ---
  function drawWindArrows(){
    const ctx = arrowCanvas.getContext('2d');
    const s = map.getSize();
    arrowCanvas.width = s.x;
    arrowCanvas.height = s.y;
    L.DomUtil.setPosition(arrowCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    if(!selected.has('wind') || !currentData?.meta) return;

    const m = currentData.meta;
    const zoom = map.getZoom();

    // densit√† frecce: pi√π zoom => pi√π fitte
    let stride = 8;
    if(zoom >= 9) stride = 6;
    if(zoom >= 10) stride = 5;
    if(zoom >= 11) stride = 4;

    // grandezza frecce
    const baseLen = (zoom >= 11) ? 14 : (zoom >= 10 ? 12 : 10);
    const head = 4.5;

    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.lineWidth = 2.0;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Per direzione coerente: convertiamo un piccolo passo in lat/lon
    // u = est (lon+), v = nord (lat+)
    for(let y=0; y<m.ny; y+=stride){
      const lat = m.la1 - (y*m.dy);
      const cosLat = Math.cos(lat * Math.PI/180);
      for(let x=0; x<m.nx; x+=stride){
        const lon = m.lo1 + (x*m.dx);
        const idx = y*m.nx + x;

        const u = currentData.wind_u?.data?.[idx] ?? 0;
        const v = currentData.wind_v?.data?.[idx] ?? 0;
        const sp = Math.sqrt(u*u+v*v);
        if(sp < 0.6) continue;

        const p0 = map.latLngToContainerPoint([lat, lon]);

        // direzione: passo in gradi proporzionale al vettore (normalizzato)
        const nx = u / sp;
        const ny = v / sp;

        // lunghezza proporzionale alla velocit√† (m/s) ma clamped
        const len = baseLen * clamp(sp/6.0, 0.65, 2.2);

        // trasforma in pixel: uso un delta lat/lon piccolo per ottenere un p1 coerente
        const degStep = 0.06; // piccolo (non dipende dall'unit√†)
        const lat2 = lat + (ny * degStep);
        const lon2 = lon + (nx * degStep / Math.max(0.25, cosLat));
        const pRef = map.latLngToContainerPoint([lat2, lon2]);

        // direzione in pixel
        let dx = pRef.x - p0.x;
        let dy = pRef.y - p0.y;
        const dLen = Math.sqrt(dx*dx + dy*dy) || 1;
        dx /= dLen; dy /= dLen;

        const p1 = { x: p0.x + dx*len, y: p0.y + dy*len };

        const col = windColorForSpeed(sp);
        ctx.strokeStyle = `rgb(${col.r},${col.g},${col.b})`;

        // asta
        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();

        // punta
        const ang = Math.atan2(dy, dx);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p1.x - head*Math.cos(ang - 0.6), p1.y - head*Math.sin(ang - 0.6));
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p1.x - head*Math.cos(ang + 0.6), p1.y - head*Math.sin(ang + 0.6));
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  // --- Isobars (sempre visibili sopra, e SU DARK bianche: qui base √® chiara => scure) ---
  function drawIsobars(){
    const ctx = isoCanvas.getContext('2d');
    const s = map.getSize();
    isoCanvas.width = s.x;
    isoCanvas.height = s.y;
    L.DomUtil.setPosition(isoCanvas, map.containerPointToLayerPoint([0,0]));
    ctx.clearRect(0,0,s.x,s.y);

    if(!showIsobars || !currentData?.press || !currentData?.meta) return;

    const m = currentData.meta;
    const values = currentData.press;

    // range adattivo
    let minP = Infinity, maxP = -Infinity;
    for(let i=0;i<values.length;i++){
      const v = values[i];
      if(!isFinite(v)) continue;
      if(v<minP) minP=v;
      if(v>maxP) maxP=v;
    }
    if(!isFinite(minP) || !isFinite(maxP)) return;

    const start = Math.floor(minP/2)*2;
    const end   = Math.ceil(maxP/2)*2 + 2;

    const contours = d3.contours()
      .size([m.nx, m.ny])
      .thresholds(d3.range(start, end, 2))(values);

    ctx.save();
    ctx.lineWidth = 1.6;

    // Base chiara => isobare pi√π scure (se in futuro passi a dark base, qui puoi invertire)
    ctx.strokeStyle = "rgba(0,0,0,0.70)";
    ctx.font = "900 12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(255,255,255,0.85)";

    contours.forEach(c => {
      ctx.beginPath();

      const labelCandidates = [];

      c.coordinates.forEach(ring => {
        ring.forEach(pts => {
          let first = true;
          const linePts = [];
          pts.forEach(coord => {
            const lat = m.la1 - (coord[1] * m.dy);
            const lon = m.lo1 + (coord[0] * m.dx);
            const p = map.latLngToContainerPoint([lat, lon]);
            linePts.push(p);
            if(first){ ctx.moveTo(p.x,p.y); first=false; }
            else ctx.lineTo(p.x,p.y);
          });
          if(linePts.length > 80) labelCandidates.push(linePts);
        });
      });

      ctx.stroke();

      // Etichette pressione
      labelCandidates.forEach(pts => {
        const mid = pts[Math.floor(pts.length/2)];
        // box
        ctx.fillStyle = "rgba(255,255,255,0.88)";
        ctx.fillRect(mid.x-18, mid.y-9, 36, 18);
        // testo
        ctx.fillStyle = "rgba(0,0,0,0.92)";
        ctx.fillText(Math.round(c.value), mid.x, mid.y);
      });
    });

    ctx.restore();
  }

  // =========================
  // PARTICLES (velocity layer)
  // =========================
  function updateParticles(){
    // sempre rimovibile col tasto
    if(velocityLayer){
      map.removeLayer(velocityLayer);
      velocityLayer = null;
    }
    if(!particlesOn || !currentData) return;

    // performance: meno particelle su schermi grandi / dpr alto
    const dpr = window.devicePixelRatio || 1;
    const bigScreen = (window.innerWidth * window.innerHeight) > 1400000;
    let particleMult = 1/140;
    if(bigScreen) particleMult = 1/180;
    if(dpr >= 2) particleMult = 1/220;

    try{
      velocityLayer = L.velocityLayer({
        displayValues: false,
        data: [ currentData.wind_u, currentData.wind_v ],
        // parametri originali (non tocchiamo fisica ‚Äúdi base‚Äù)
        maxVelocity: 18.0,
        velocityScale: 0.006,
        particleMultiplier: particleMult,
        lineWidth: 0.8,
        particleAge: 140,
        frameRate: 60,
        opacity: 0.90,
        // Le particelle DEVONO essere scure: qui usiamo una scala scura (non bianco),
        // ma coerente: pi√π veloce => pi√π ‚Äúacceso‚Äù (nero -> grigio scuro -> quasi nero violaceo).
        // Se vuoi ESATTAMENTE ‚Äúnere‚Äù sempre, dimmelo e le fisso a #111.
        colorScale: isLightBase
          ? ["#111111", "#151515", "#1a1a1a", "#202020", "#262626", "#2c2c2c", "#333333", "#3a3a3a"]
          : ["#000000", "#050505", "#0a0a0a", "#0f0f0f", "#141414", "#1a1a1a", "#202020", "#262626"]
      });
      velocityLayer.addTo(map);
    } catch(e){}
  }

  // =========================
  // UI ACTIONS
  // =========================
  window.toggleLayer = function(name){
    const el = findToggleEl(name);
    if(selected.has(name)){
      selected.delete(name);
      if(el) el.classList.remove('active');
    } else {
      selected.add(name);
      if(el) el.classList.add('active');
    }

    // Se spengo vento, spengo anche isobare? (NO: le isobare sono un overlay separato)
    // Picker unit
    document.getElementById('unit-display').innerText = unitForPicker();

    // Se le nuvole non esistono nel JSON, avviso e non crasha
    if(name === 'cloud' && selected.has('cloud')){
      const arr = (currentData?.cloud ?? currentData?.cld ?? currentData?.tcc);
      if(currentData && !Array.isArray(arr)){
        // Non faccio alert per non ‚Äúrompere‚Äù mobile, ma spengo subito
        selected.delete('cloud');
        if(el) el.classList.remove('active');
        document.getElementById('unit-display').innerText = unitForPicker();
      }
    }

    redrawAll();
  };

  function findToggleEl(name){
    // recupero tramite testo: uso i pallini id dot-*
    const mapId = {
      wind: 'dot-wind',
      temp: 'dot-temp',
      rain: 'dot-rain',
      rh: 'dot-rh',
      press: 'dot-press',
      cloud: 'dot-cloud'
    };
    const dot = document.getElementById(mapId[name]);
    return dot ? dot.closest('.toggle') : null;
  }

  window.toggleIsobars = function(){
    showIsobars = !showIsobars;
    document.getElementById('btn-iso').classList.toggle('active');
    redrawAll();
  };

  window.toggleParticles = function(){
    particlesOn = !particlesOn;
    const b = document.getElementById('btn-flow');
    b.classList.toggle('active', particlesOn);
    b.textContent = particlesOn ? "FLUSSO üå¨Ô∏è (ON)" : "FLUSSO üå¨Ô∏è (OFF)";
    redrawAll();
  };

  window.togglePlay = function(){
    const btn = document.getElementById('play-btn');
    const slider = document.getElementById('time-slider');

    if(isPlaying){
      isPlaying = false;
      btn.textContent = "‚ñ∫";
      if(playTimer) { clearInterval(playTimer); playTimer = null; }
      return;
    }

    isPlaying = true;
    btn.textContent = "‚ùö‚ùö";

    let i = parseInt(slider.value,10);
    const max = parseInt(slider.max,10);

    playTimer = setInterval(() => {
      if(!isPlaying){ clearInterval(playTimer); playTimer=null; return; }
      if(i >= max){
        isPlaying = false;
        btn.textContent = "‚ñ∫";
        clearInterval(playTimer); playTimer=null;
        return;
      }
      i++;
      slider.value = i;
      loadStep(i);
    }, 850);
  };

  // =========================
  // PICKER
  // =========================
  function onPick(e){
    const out = valueForPicker(e.latlng);
    if(!out) return;
    document.getElementById('val-display').innerText = out.fmt(out.v);
    document.getElementById('unit-display').innerText = unitForPicker();
  }
</script>

</body>
</html>